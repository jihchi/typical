// This file was automatically generated by Typical 0.0.0.
// Visit https://github.com/stepchowfun/typical for more information.

/* eslint-disable */

export function unreachable(x: never): never {
  return x;
}

function zigzagEncode(value: bigint): bigint {
  const twice = value << 1n;
  return value < 0n ? -1n - twice : twice;
}

function zigzagDecode(value: bigint): bigint {
  const half = (value + 1n) >> 1n;
  return (value & 1n) === 0n ? half : -half;
}

function varintSizeFromValue(value: bigint): number {
  if (value < 128n) {
    return 1;
  } else if (value < 16_512n) {
    return 2;
  } else if (value < 2_113_664n) {
    return 3;
  } else if (value < 270_549_120n) {
    return 4;
  } else if (value < 34_630_287_488n) {
    return 5;
  } else if (value < 4_432_676_798_592n) {
    return 6;
  } else if (value < 567_382_630_219_904n) {
    return 7;
  } else if (value < 72_624_976_668_147_840n) {
    return 8;
  } else {
    return 9;
  }
}

function varintSizeFromFirstByte(firstByte: number): number {
  let trailingZeros = 0;

  while (trailingZeros < 8 && (firstByte & 1) !== 1) {
    ++trailingZeros;
    firstByte >>= 1;
  }

  return trailingZeros + 1;
}

const dataView64 = new DataView(new ArrayBuffer(8));

function serializeVarint(
  dataView: DataView,
  offset: number,
  value: bigint,
): number {
  if (value < 128n) {
    dataView.setUint8(offset, Number(value << 1n) | 0b0000_0001);
    return offset + 1;
  } else if (value < 16_512n) {
    value -= 128n;
    dataView.setUint8(offset, Number((value << 2n) % 256n) | 0b0000_0010);
    dataView.setUint8(offset + 1, Number(value >> 6n));
    return offset + 2;
  } else if (value < 2_113_664n) {
    value -= 16_512n;
    dataView.setUint8(offset, Number((value << 3n) % 256n) | 0b0000_0100);
    dataView.setUint16(offset + 1, Number((value >> 5n) % 65_536n), true);
    return offset + 3;
  } else if (value < 270_549_120n) {
    value -= 2_113_664n;
    dataView.setUint8(offset, Number((value << 4n) % 256n) | 0b0000_1000);
    dataView.setUint8(offset + 1, Number((value >> 4n) % 256n));
    dataView.setUint16(offset + 2, Number((value >> 12n) % 65_536n), true);
    return offset + 4;
  } else if (value < 34_630_287_488n) {
    value -= 270_549_120n;
    dataView.setUint8(offset, Number((value << 5n) % 256n) | 0b0001_0000);
    dataView.setUint32(
      offset + 1,
      Number((value >> 3n) % 4_294_967_296n),
      true,
    );
    return offset + 5;
  } else if (value < 4_432_676_798_592n) {
    value -= 34_630_287_488n;
    dataView.setUint8(offset, Number((value << 6n) % 256n) | 0b0010_0000);
    dataView.setUint8(offset + 1, Number((value >> 2n) % 256n));
    dataView.setUint32(
      offset + 2,
      Number((value >> 10n) % 4_294_967_296n),
      true,
    );
    return offset + 6;
  } else if (value < 567_382_630_219_904n) {
    value -= 4_432_676_798_592n;
    dataView.setUint8(offset, Number((value << 7n) % 256n) | 0b0100_0000);
    dataView.setUint16(offset + 1, Number((value >> 1n) % 65_536n), true);
    dataView.setUint32(
      offset + 3,
      Number((value >> 17n) % 4_294_967_296n),
      true,
    );
    return offset + 7;
  } else if (value < 72_624_976_668_147_840n) {
    value -= 567_382_630_219_904n;
    dataView.setUint8(offset, 0b1000_0000);
    dataView.setUint8(offset + 1, Number(value % 256n));
    dataView.setUint16(offset + 2, Number((value >> 8n) % 65_536n), true);
    dataView.setUint32(
      offset + 4,
      Number((value >> 24n) % 4_294_967_296n),
      true,
    );
    return offset + 8;
  } else {
    value -= 72_624_976_668_147_840n;
    dataView.setUint8(offset, 0b0000_0000);
    dataView.setBigUint64(offset + 1, value, true);
    return offset + 9;
  }
}

function deserializeVarint(
  dataView: DataView,
  offset: number,
): [number, bigint] {
  const firstByte = dataView.getUint8(offset);
  const sizeMinusOne = varintSizeFromFirstByte(firstByte) - 1;
  const offsetPlusOne = offset + 1;
  dataView64.setBigUint64(0, 0n, true);
  for (let i = 0; i < sizeMinusOne; ++i) {
    dataView64.setUint8(i, dataView.getUint8(offsetPlusOne + i));
  }
  const remainingBytesValue = dataView64.getBigUint64(0, true);
  switch (sizeMinusOne) {
    case 0:
      return [offset + 1, BigInt(firstByte >> 1)];
    case 1:
      return [
        offset + 2,
        128n + BigInt(firstByte >> 2) + (remainingBytesValue << 6n),
      ];
    case 2:
      return [
        offset + 3,
        16_512n + BigInt(firstByte >> 3) + (remainingBytesValue << 5n),
      ];
    case 3:
      return [
        offset + 4,
        2_113_664n + BigInt(firstByte >> 4) + (remainingBytesValue << 4n),
      ];
    case 4:
      return [
        offset + 5,
        270_549_120n + BigInt(firstByte >> 5) + (remainingBytesValue << 3n),
      ];
    case 5:
      return [
        offset + 6,
        34_630_287_488n + BigInt(firstByte >> 6) + (remainingBytesValue << 2n),
      ];
    case 6:
      return [
        offset + 7,
        4_432_676_798_592n +
          BigInt(firstByte >> 7) +
          (remainingBytesValue << 1n),
      ];
    case 7:
      return [offset + 8, 567_382_630_219_904n + remainingBytesValue];
    default:
      return [
        offset + 9,
        (72_624_976_668_147_840n + remainingBytesValue) %
          18_446_744_073_709_551_616n,
      ];
  }
}

function fieldHeaderSize(
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {
  switch (payloadSize) {
    case 0:
      return varintSizeFromValue((index << 2n) | BigInt(0b00));
    case 8:
      return varintSizeFromValue((index << 2n) | BigInt(0b01));
    default:
      if (integerEncoded) {
        return varintSizeFromValue((index << 2n) | BigInt(0b10));
      } else {
        return (
          varintSizeFromValue((index << 2n) | BigInt(0b11)) +
          varintSizeFromValue(BigInt(payloadSize))
        );
      }
  }
}

function serializeFieldHeader(
  dataView: DataView,
  offset: number,
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {
  switch (payloadSize) {
    case 0:
      return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b00));
    case 1:
      return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b01));
    default:
      if (integerEncoded) {
        return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b10));
      } else {
        offset = serializeVarint(
          dataView,
          offset,
          (index << 2n) | BigInt(0b11),
        );
        return serializeVarint(dataView, offset, BigInt(payloadSize));
      }
  }
}

function deserializeFieldHeader(
  dataView: DataView,
  offset: number,
): [number, bigint, number] {
  const [newOffset, tag] = deserializeVarint(dataView, offset);
  offset = newOffset;

  const index = tag >> 2n;

  let size;
  switch (tag & 3n) {
    case 0n:
      size = 0;
      break;
    case 1n:
      size = 8;
      break;
    case 2n:
      size = varintSizeFromFirstByte(dataView.getUint8(offset));
      break;
    default:
      const [newNewOffset, sizeValue] = deserializeVarint(dataView, offset);
      offset = newNewOffset;
      size = Number(sizeValue);
      break;
  }

  return [offset, index, size];
}

const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

export namespace CircularDependency {
  export namespace Dependency {
    export namespace Types {
      export type StructFromBelowOut = {
        x: CircularDependency.Types.StructFromAboveOut;
      };

      export type StructFromBelowIn = {
        x: CircularDependency.Types.StructFromAboveIn;
      };

      export namespace StructFromBelow {
        export function size(value: StructFromBelowOut): number {
          let valueSize = 0;
          let payloadSize = 0;

          {
            const payload = value.x;
            payloadSize = CircularDependency.Types.StructFromAbove.size(payload);
            valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }

          return valueSize;
        }

        export function serialize(
          dataView: DataView,
          offset: number,
          value: StructFromBelowOut,
        ): number {
          let payloadSize = 0;

          {
            const payload = value.x;
            payloadSize = CircularDependency.Types.StructFromAbove.size(payload);
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            offset = CircularDependency.Types.StructFromAbove.serialize(dataView, offset, payload);
          }

          return offset;
        }

        export function deserialize(
          dataView: DataView,
          offset: number,
        ): [number, StructFromBelowIn] {
          let xField;

          while (true) {
            let index, payloadSize;
            try {
              [offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
            } catch (e) {
              if (e instanceof RangeError) {
                break;
              } else {
                throw e;
              }
            }
            switch (index) {
              case 0n: {
                let payload;
                [offset, payload] = CircularDependency.Types.StructFromAbove.deserialize(dataView, offset);
                xField = payload;
                break;
              }
              default:
                offset += payloadSize;
                break;
            }
          }

          if (xField === undefined) {
            throw new Error('Struct missing one or more field(s).');
          }

          return [
            offset,
            {
              x: xField,
            }
          ];
        }

        export function outToIn(value: StructFromBelowOut): StructFromBelowIn {
          return value;
        }
      }
    }
  }

  export namespace Types {
    export type StructFromAboveOut = {
    };

    export type StructFromAboveIn = {
    };

    export namespace StructFromAbove {
      export function size(value: StructFromAboveOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: StructFromAboveOut,
      ): number {
        let payloadSize = 0;

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, StructFromAboveIn] {
        return [
          offset,
          {
          }
        ];
      }

      export function outToIn(value: StructFromAboveOut): StructFromAboveIn {
        return value;
      }
    }
  }
}

export namespace Comprehensive {
  export namespace Types {
    export type LocalStructOut = {
    };

    export type LocalStructIn = {
    };

    export namespace LocalStruct {
      export function size(value: LocalStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: LocalStructOut,
      ): number {
        let payloadSize = 0;

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, LocalStructIn] {
        return [
          offset,
          {
          }
        ];
      }

      export function outToIn(value: LocalStructOut): LocalStructIn {
        return value;
      }
    }

    export type FooOut = {
      aRequired: undefined;
      bRequired: number;
      cRequired: bigint;
      dRequired: bigint;
      eRequired: boolean;
      fRequired: ArrayBuffer;
      gRequired: string;
      hRequired: Comprehensive.Types.LocalStructOut;
      iRequired: Degenerate.Types.EmptyStructOut;
      jRequired: undefined[];
      kRequired: number[];
      lRequired: bigint[];
      mRequired: bigint[];
      nRequired: boolean[];
      oRequired: ArrayBuffer[];
      pRequired: string[];
      qRequired: Comprehensive.Types.LocalStructOut[];
      rRequired: Degenerate.Types.EmptyStructOut[];
      sRequired: undefined[][];
      tRequired: number[][];
      uRequired: bigint[][];
      vRequired: bigint[][];
      wRequired: boolean[][];
      xRequired: ArrayBuffer[][];
      yRequired: string[][];
      zRequired: Comprehensive.Types.LocalStructOut[][];
      aaRequired: Degenerate.Types.EmptyStructOut[][];
      aAsymmetric: undefined;
      bAsymmetric: number;
      cAsymmetric: bigint;
      dAsymmetric: bigint;
      eAsymmetric: boolean;
      fAsymmetric: ArrayBuffer;
      gAsymmetric: string;
      hAsymmetric: Comprehensive.Types.LocalStructOut;
      iAsymmetric: Degenerate.Types.EmptyStructOut;
      jAsymmetric: undefined[];
      kAsymmetric: number[];
      lAsymmetric: bigint[];
      mAsymmetric: bigint[];
      nAsymmetric: boolean[];
      oAsymmetric: ArrayBuffer[];
      pAsymmetric: string[];
      qAsymmetric: Comprehensive.Types.LocalStructOut[];
      rAsymmetric: Degenerate.Types.EmptyStructOut[];
      sAsymmetric: undefined[][];
      tAsymmetric: number[][];
      uAsymmetric: bigint[][];
      vAsymmetric: bigint[][];
      wAsymmetric: boolean[][];
      xAsymmetric: ArrayBuffer[][];
      yAsymmetric: string[][];
      zAsymmetric: Comprehensive.Types.LocalStructOut[][];
      aaAsymmetric: Degenerate.Types.EmptyStructOut[][];
      aOptional?: undefined;
      bOptional?: number;
      cOptional?: bigint;
      dOptional?: bigint;
      eOptional?: boolean;
      fOptional?: ArrayBuffer;
      gOptional?: string;
      hOptional?: Comprehensive.Types.LocalStructOut;
      iOptional?: Degenerate.Types.EmptyStructOut;
      jOptional?: undefined[];
      kOptional?: number[];
      lOptional?: bigint[];
      mOptional?: bigint[];
      nOptional?: boolean[];
      oOptional?: ArrayBuffer[];
      pOptional?: string[];
      qOptional?: Comprehensive.Types.LocalStructOut[];
      rOptional?: Degenerate.Types.EmptyStructOut[];
      sOptional?: undefined[][];
      tOptional?: number[][];
      uOptional?: bigint[][];
      vOptional?: bigint[][];
      wOptional?: boolean[][];
      xOptional?: ArrayBuffer[][];
      yOptional?: string[][];
      zOptional?: Comprehensive.Types.LocalStructOut[][];
      aaOptional?: Degenerate.Types.EmptyStructOut[][];
    };

    export type FooIn = {
      aRequired: undefined;
      bRequired: number;
      cRequired: bigint;
      dRequired: bigint;
      eRequired: boolean;
      fRequired: ArrayBuffer;
      gRequired: string;
      hRequired: Comprehensive.Types.LocalStructIn;
      iRequired: Degenerate.Types.EmptyStructIn;
      jRequired: undefined[];
      kRequired: number[];
      lRequired: bigint[];
      mRequired: bigint[];
      nRequired: boolean[];
      oRequired: ArrayBuffer[];
      pRequired: string[];
      qRequired: Comprehensive.Types.LocalStructIn[];
      rRequired: Degenerate.Types.EmptyStructIn[];
      sRequired: undefined[][];
      tRequired: number[][];
      uRequired: bigint[][];
      vRequired: bigint[][];
      wRequired: boolean[][];
      xRequired: ArrayBuffer[][];
      yRequired: string[][];
      zRequired: Comprehensive.Types.LocalStructIn[][];
      aaRequired: Degenerate.Types.EmptyStructIn[][];
      aAsymmetric?: undefined;
      bAsymmetric?: number;
      cAsymmetric?: bigint;
      dAsymmetric?: bigint;
      eAsymmetric?: boolean;
      fAsymmetric?: ArrayBuffer;
      gAsymmetric?: string;
      hAsymmetric?: Comprehensive.Types.LocalStructIn;
      iAsymmetric?: Degenerate.Types.EmptyStructIn;
      jAsymmetric?: undefined[];
      kAsymmetric?: number[];
      lAsymmetric?: bigint[];
      mAsymmetric?: bigint[];
      nAsymmetric?: boolean[];
      oAsymmetric?: ArrayBuffer[];
      pAsymmetric?: string[];
      qAsymmetric?: Comprehensive.Types.LocalStructIn[];
      rAsymmetric?: Degenerate.Types.EmptyStructIn[];
      sAsymmetric?: undefined[][];
      tAsymmetric?: number[][];
      uAsymmetric?: bigint[][];
      vAsymmetric?: bigint[][];
      wAsymmetric?: boolean[][];
      xAsymmetric?: ArrayBuffer[][];
      yAsymmetric?: string[][];
      zAsymmetric?: Comprehensive.Types.LocalStructIn[][];
      aaAsymmetric?: Degenerate.Types.EmptyStructIn[][];
      aOptional?: undefined;
      bOptional?: number;
      cOptional?: bigint;
      dOptional?: bigint;
      eOptional?: boolean;
      fOptional?: ArrayBuffer;
      gOptional?: string;
      hOptional?: Comprehensive.Types.LocalStructIn;
      iOptional?: Degenerate.Types.EmptyStructIn;
      jOptional?: undefined[];
      kOptional?: number[];
      lOptional?: bigint[];
      mOptional?: bigint[];
      nOptional?: boolean[];
      oOptional?: ArrayBuffer[];
      pOptional?: string[];
      qOptional?: Comprehensive.Types.LocalStructIn[];
      rOptional?: Degenerate.Types.EmptyStructIn[];
      sOptional?: undefined[][];
      tOptional?: number[][];
      uOptional?: bigint[][];
      vOptional?: bigint[][];
      wOptional?: boolean[][];
      xOptional?: ArrayBuffer[][];
      yOptional?: string[][];
      zOptional?: Comprehensive.Types.LocalStructIn[][];
      aaOptional?: Degenerate.Types.EmptyStructIn[][];
    };

    export namespace Foo {
      export function size(value: FooOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.aRequired;
          payloadSize = 0;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.bRequired;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.cRequired;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(2n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.dRequired;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(3n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.eRequired;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(4n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.fRequired;
          payloadSize = payload.byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.gRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.hRequired;
          payloadSize = Comprehensive.Types.LocalStruct.size(payload);
          valueSize += fieldHeaderSize(7n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.iRequired;
          payloadSize = Degenerate.Types.EmptyStruct.size(payload);
          valueSize += fieldHeaderSize(8n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.jRequired;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.kRequired;
          payloadSize = 8 * payload.length;
          valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.lRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(11n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.mRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(12n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.oRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.pRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(15n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.qRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(16n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.rRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(17n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.sRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(18n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.tRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 8 * payload.length;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(19n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.uRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(20n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.vRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(21n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.wRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(22n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.xRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(23n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.yRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(24n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.zRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(25n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aaRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(26n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aAsymmetric;
          payloadSize = 0;
          valueSize += fieldHeaderSize(28n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.bAsymmetric;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(29n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.cAsymmetric;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(30n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.dAsymmetric;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(31n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.eAsymmetric;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(32n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.fAsymmetric;
          payloadSize = payload.byteLength;
          valueSize += fieldHeaderSize(33n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.gAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(34n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.hAsymmetric;
          payloadSize = Comprehensive.Types.LocalStruct.size(payload);
          valueSize += fieldHeaderSize(35n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.iAsymmetric;
          payloadSize = Degenerate.Types.EmptyStruct.size(payload);
          valueSize += fieldHeaderSize(36n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.jAsymmetric;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          valueSize += fieldHeaderSize(37n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.kAsymmetric;
          payloadSize = 8 * payload.length;
          valueSize += fieldHeaderSize(38n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.lAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(39n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.mAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(40n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(41n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.oAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(42n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.pAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(43n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.qAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(44n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.rAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(45n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.sAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(46n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.tAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 8 * payload.length;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(47n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.uAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(48n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.vAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(49n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.wAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(50n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.xAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(51n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.yAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(52n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.zAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(53n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aaAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(54n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(56n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.bOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(57n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.cOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(58n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.dOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
          }
          valueSize += fieldHeaderSize(59n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.eOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
          }
          valueSize += fieldHeaderSize(60n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.fOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = payload.byteLength;
          }
          valueSize += fieldHeaderSize(61n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.gOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(62n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.hOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
          }
          valueSize += fieldHeaderSize(63n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.iOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
          }
          valueSize += fieldHeaderSize(64n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.jOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
          }
          valueSize += fieldHeaderSize(65n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.kOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = 8 * payload.length;
          }
          valueSize += fieldHeaderSize(66n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.lOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(67n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.mOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(68n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(69n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.oOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(70n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.pOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(71n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.qOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(72n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.rOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(73n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.sOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(74n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.tOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(75n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.uOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(76n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.vOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(77n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.wOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(78n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.xOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(79n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.yOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(80n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.zOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(81n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aaOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(82n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: FooOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.aRequired;
          payloadSize = 0;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
        }

        {
          const payload = value.bRequired;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          if (payloadSize !== 0) {
            dataView.setFloat64(offset, payload, true);
          }
        }

        {
          const payload = value.cRequired;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.dRequired;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.eRequired;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.fRequired;
          payloadSize = payload.byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const buffer = new Uint8Array(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.gRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.hRequired;
          payloadSize = Comprehensive.Types.LocalStruct.size(payload);
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
        }

        {
          const payload = value.iRequired;
          payloadSize = Degenerate.Types.EmptyStruct.size(payload);
          offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
          offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
        }

        {
          const payload = value.jRequired;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.kRequired;
          payloadSize = 8 * payload.length;
          offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 8;
              dataView.setFloat64(offset, payload, true);
            }
          }
        }

        {
          const payload = value.lRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(payload);
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.mRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.nRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 1;
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.oRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = payload.byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = new Uint8Array(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.pRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 15n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = textEncoder.encode(payload).byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = textEncoder.encode(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.qRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 16n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
            }
          }
        }

        {
          const payload = value.rRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
            }
          }
        }

        {
          const payload = value.sRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const varint = BigInt(payload.length);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.tRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 8 * payload.length;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 19n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 8 * payload.length;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = 8;
                  dataView.setFloat64(offset, payload, true);
                }
              }
            }
          }
        }

        {
          const payload = value.uRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 20n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = varintSizeFromValue(payload);
                  {
                    const varint = payload;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.vRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 21n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  {
                    const varint = zigzagEncode(payload);
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.wRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 22n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = 1;
                  {
                    const varint = payload ? 1n : 0n;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.xRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 23n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = payload.byteLength;
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  {
                    const buffer = new Uint8Array(payload);
                    for (let i = 0; i < buffer.byteLength; ++i) {
                      dataView.setUint8(offset + i, buffer[i]);
                    }
                    offset += buffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.yRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 24n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = textEncoder.encode(payload).byteLength;
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  {
                    const buffer = textEncoder.encode(payload);
                    for (let i = 0; i < buffer.byteLength; ++i) {
                      dataView.setUint8(offset + i, buffer[i]);
                    }
                    offset += buffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.zRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 25n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                }
              }
            }
          }
        }

        {
          const payload = value.aaRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 26n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                }
              }
            }
          }
        }

        {
          const payload = value.aAsymmetric;
          payloadSize = 0;
          offset = serializeFieldHeader(dataView, offset, 28n, payloadSize, false);
        }

        {
          const payload = value.bAsymmetric;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 29n, payloadSize, false);
          if (payloadSize !== 0) {
            dataView.setFloat64(offset, payload, true);
          }
        }

        {
          const payload = value.cAsymmetric;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 30n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.dAsymmetric;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          offset = serializeFieldHeader(dataView, offset, 31n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.eAsymmetric;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          offset = serializeFieldHeader(dataView, offset, 32n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.fAsymmetric;
          payloadSize = payload.byteLength;
          offset = serializeFieldHeader(dataView, offset, 33n, payloadSize, false);
          {
            const buffer = new Uint8Array(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.gAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 34n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.hAsymmetric;
          payloadSize = Comprehensive.Types.LocalStruct.size(payload);
          offset = serializeFieldHeader(dataView, offset, 35n, payloadSize, false);
          offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
        }

        {
          const payload = value.iAsymmetric;
          payloadSize = Degenerate.Types.EmptyStruct.size(payload);
          offset = serializeFieldHeader(dataView, offset, 36n, payloadSize, false);
          offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
        }

        {
          const payload = value.jAsymmetric;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          offset = serializeFieldHeader(dataView, offset, 37n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.kAsymmetric;
          payloadSize = 8 * payload.length;
          offset = serializeFieldHeader(dataView, offset, 38n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 8;
              dataView.setFloat64(offset, payload, true);
            }
          }
        }

        {
          const payload = value.lAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 39n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(payload);
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.mAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 40n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.nAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 41n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 1;
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.oAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 42n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = payload.byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = new Uint8Array(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.pAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 43n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = textEncoder.encode(payload).byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = textEncoder.encode(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.qAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 44n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = Comprehensive.Types.LocalStruct.size(payload);
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
            }
          }
        }

        {
          const payload = value.rAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 45n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = Degenerate.Types.EmptyStruct.size(payload);
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
            }
          }
        }

        {
          const payload = value.sAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 46n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                const oldPayload = payload;
                {
                  const payload = BigInt(oldPayload.length);
                  payloadSize = varintSizeFromValue(payload);
                }
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const varint = BigInt(payload.length);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.tAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 8 * payload.length;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 47n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 8 * payload.length;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = 8;
                  dataView.setFloat64(offset, payload, true);
                }
              }
            }
          }
        }

        {
          const payload = value.uAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 48n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(payload);
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = varintSizeFromValue(payload);
                  {
                    const varint = payload;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.vAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 49n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = varintSizeFromValue(zigzagEncode(payload));
                  {
                    const varint = zigzagEncode(payload);
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.wAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 50n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = 1;
                  arraySize += payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = 1;
                  {
                    const varint = payload ? 1n : 0n;
                    offset = serializeVarint(dataView, offset, varint);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.xAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 51n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = payload.byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = payload.byteLength;
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  {
                    const buffer = new Uint8Array(payload);
                    for (let i = 0; i < buffer.byteLength; ++i) {
                      dataView.setUint8(offset + i, buffer[i]);
                    }
                    offset += buffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.yAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 52n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = textEncoder.encode(payload).byteLength;
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  {
                    const buffer = textEncoder.encode(payload);
                    for (let i = 0; i < buffer.byteLength; ++i) {
                      dataView.setUint8(offset + i, buffer[i]);
                    }
                    offset += buffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.zAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 53n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                }
              }
            }
          }
        }

        {
          const payload = value.aaAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 54n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                }
              }
            }
          }
        }

        {
          const payload = value.aOptional;
          if (payload !== undefined) {
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 56n, payloadSize, false);
          }
        }

        {
          const payload = value.bOptional;
          if (payload !== undefined) {
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 57n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
          }
        }

        {
          const payload = value.cOptional;
          if (payload !== undefined) {
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 58n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.dOptional;
          if (payload !== undefined) {
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 59n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.eOptional;
          if (payload !== undefined) {
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 60n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.fOptional;
          if (payload !== undefined) {
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 61n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.gOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 62n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.hOptional;
          if (payload !== undefined) {
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 63n, payloadSize, false);
            offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
          }
        }

        {
          const payload = value.iOptional;
          if (payload !== undefined) {
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 64n, payloadSize, false);
            offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
          }
        }

        {
          const payload = value.jOptional;
          if (payload !== undefined) {
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 65n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.kOptional;
          if (payload !== undefined) {
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 66n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
          }
        }

        {
          const payload = value.lOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 67n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.mOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 68n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.nOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 69n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.oOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 70n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
          }
        }

        {
          const payload = value.pOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 71n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
          }
        }

        {
          const payload = value.qOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 72n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
              }
            }
          }
        }

        {
          const payload = value.rOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 73n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
              }
            }
          }
        }

        {
          const payload = value.sOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 74n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const varint = BigInt(payload.length);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.tOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 75n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8 * payload.length;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = 8;
                    dataView.setFloat64(offset, payload, true);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.uOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 76n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = varintSizeFromValue(payload);
                    {
                      const varint = payload;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.vOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 77n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    {
                      const varint = zigzagEncode(payload);
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.wOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 78n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = 1;
                    {
                      const varint = payload ? 1n : 0n;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.xOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 79n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = payload.byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = new Uint8Array(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.yOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 80n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = textEncoder.encode(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.zOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 81n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.aaOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 82n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, FooIn] {
        let aRequiredField, bRequiredField, cRequiredField, dRequiredField, eRequiredField, fRequiredField, gRequiredField, hRequiredField, iRequiredField, jRequiredField, kRequiredField, lRequiredField, mRequiredField, nRequiredField, oRequiredField, pRequiredField, qRequiredField, rRequiredField, sRequiredField, tRequiredField, uRequiredField, vRequiredField, wRequiredField, xRequiredField, yRequiredField, zRequiredField, aaRequiredField, aAsymmetricField, bAsymmetricField, cAsymmetricField, dAsymmetricField, eAsymmetricField, fAsymmetricField, gAsymmetricField, hAsymmetricField, iAsymmetricField, jAsymmetricField, kAsymmetricField, lAsymmetricField, mAsymmetricField, nAsymmetricField, oAsymmetricField, pAsymmetricField, qAsymmetricField, rAsymmetricField, sAsymmetricField, tAsymmetricField, uAsymmetricField, vAsymmetricField, wAsymmetricField, xAsymmetricField, yAsymmetricField, zAsymmetricField, aaAsymmetricField, aOptionalField, bOptionalField, cOptionalField, dOptionalField, eOptionalField, fOptionalField, gOptionalField, hOptionalField, iOptionalField, jOptionalField, kOptionalField, lOptionalField, mOptionalField, nOptionalField, oOptionalField, pOptionalField, qOptionalField, rOptionalField, sOptionalField, tOptionalField, uOptionalField, vOptionalField, wOptionalField, xOptionalField, yOptionalField, zOptionalField, aaOptionalField;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              break;
            }
            case 1n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              bRequiredField = payload;
              break;
            }
            case 2n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              cRequiredField = payload;
              break;
            }
            case 3n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              dRequiredField = payload;
              break;
            }
            case 4n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              eRequiredField = payload;
              break;
            }
            case 5n: {
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + offset + payloadSize,
              );
              offset += payloadSize;
              fRequiredField = payload;
              break;
            }
            case 6n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              gRequiredField = payload;
              break;
            }
            case 7n: {
              let payload;
              [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
              hRequiredField = payload;
              break;
            }
            case 8n: {
              let payload;
              [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
              iRequiredField = payload;
              break;
            }
            case 9n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              jRequiredField = payload;
              break;
            }
            case 10n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              kRequiredField = payload;
              break;
            }
            case 11n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              lRequiredField = payload;
              break;
            }
            case 12n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              mRequiredField = payload;
              break;
            }
            case 13n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              nRequiredField = payload;
              break;
            }
            case 14n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + offset + payloadSize,
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              oRequiredField = payload;
              break;
            }
            case 15n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(
                      dataView.buffer.slice(
                        dataView.byteOffset + offset,
                        dataView.byteOffset + offset + payloadSize,
                      ),
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              pRequiredField = payload;
              break;
            }
            case 16n: {
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              qRequiredField = payload;
              break;
            }
            case 17n: {
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              rRequiredField = payload;
              break;
            }
            case 18n: {
              let payload: undefined[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(undefined);
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              sRequiredField = payload;
              break;
            }
            case 19n: {
              let payload: number[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: number[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload = dataView.getFloat64(offset, true);
                          offset += 8;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              tRequiredField = payload;
              break;
            }
            case 20n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              uRequiredField = payload;
              break;
            }
            case 21n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payload = zigzagDecode(payload);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              vRequiredField = payload;
              break;
            }
            case 22n: {
              let payload: boolean[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: boolean[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          {
                            let newPayload;
                            {
                              let payload;
                              [offset, payload] = deserializeVarint(dataView, offset);
                              newPayload = payload !== 0n;
                            }
                            payload = newPayload;
                          }
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              wRequiredField = payload;
              break;
            }
            case 23n: {
              let payload: ArrayBuffer[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: ArrayBuffer[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + offset + payloadSize,
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              xRequiredField = payload;
              break;
            }
            case 24n: {
              let payload: string[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: string[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = textDecoder.decode(
                            dataView.buffer.slice(
                              dataView.byteOffset + offset,
                              dataView.byteOffset + offset + payloadSize,
                            ),
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              yRequiredField = payload;
              break;
            }
            case 25n: {
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              zRequiredField = payload;
              break;
            }
            case 26n: {
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              aaRequiredField = payload;
              break;
            }
            case 28n: {
              break;
            }
            case 29n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              bAsymmetricField = payload;
              break;
            }
            case 30n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              cAsymmetricField = payload;
              break;
            }
            case 31n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              dAsymmetricField = payload;
              break;
            }
            case 32n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              eAsymmetricField = payload;
              break;
            }
            case 33n: {
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + offset + payloadSize,
              );
              offset += payloadSize;
              fAsymmetricField = payload;
              break;
            }
            case 34n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              gAsymmetricField = payload;
              break;
            }
            case 35n: {
              let payload;
              [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
              hAsymmetricField = payload;
              break;
            }
            case 36n: {
              let payload;
              [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
              iAsymmetricField = payload;
              break;
            }
            case 37n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              jAsymmetricField = payload;
              break;
            }
            case 38n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              kAsymmetricField = payload;
              break;
            }
            case 39n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              lAsymmetricField = payload;
              break;
            }
            case 40n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              mAsymmetricField = payload;
              break;
            }
            case 41n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              nAsymmetricField = payload;
              break;
            }
            case 42n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + offset + payloadSize,
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              oAsymmetricField = payload;
              break;
            }
            case 43n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(
                      dataView.buffer.slice(
                        dataView.byteOffset + offset,
                        dataView.byteOffset + offset + payloadSize,
                      ),
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              pAsymmetricField = payload;
              break;
            }
            case 44n: {
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              qAsymmetricField = payload;
              break;
            }
            case 45n: {
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              rAsymmetricField = payload;
              break;
            }
            case 46n: {
              let payload: undefined[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(undefined);
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              sAsymmetricField = payload;
              break;
            }
            case 47n: {
              let payload: number[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: number[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload = dataView.getFloat64(offset, true);
                          offset += 8;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              tAsymmetricField = payload;
              break;
            }
            case 48n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              uAsymmetricField = payload;
              break;
            }
            case 49n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payload = zigzagDecode(payload);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              vAsymmetricField = payload;
              break;
            }
            case 50n: {
              let payload: boolean[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: boolean[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          {
                            let newPayload;
                            {
                              let payload;
                              [offset, payload] = deserializeVarint(dataView, offset);
                              newPayload = payload !== 0n;
                            }
                            payload = newPayload;
                          }
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              wAsymmetricField = payload;
              break;
            }
            case 51n: {
              let payload: ArrayBuffer[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: ArrayBuffer[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + offset + payloadSize,
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              xAsymmetricField = payload;
              break;
            }
            case 52n: {
              let payload: string[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: string[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = textDecoder.decode(
                            dataView.buffer.slice(
                              dataView.byteOffset + offset,
                              dataView.byteOffset + offset + payloadSize,
                            ),
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              yAsymmetricField = payload;
              break;
            }
            case 53n: {
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              zAsymmetricField = payload;
              break;
            }
            case 54n: {
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              aaAsymmetricField = payload;
              break;
            }
            case 56n: {
              break;
            }
            case 57n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              bOptionalField = payload;
              break;
            }
            case 58n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              cOptionalField = payload;
              break;
            }
            case 59n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              dOptionalField = payload;
              break;
            }
            case 60n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              eOptionalField = payload;
              break;
            }
            case 61n: {
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + offset + payloadSize,
              );
              offset += payloadSize;
              fOptionalField = payload;
              break;
            }
            case 62n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              gOptionalField = payload;
              break;
            }
            case 63n: {
              let payload;
              [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
              hOptionalField = payload;
              break;
            }
            case 64n: {
              let payload;
              [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
              iOptionalField = payload;
              break;
            }
            case 65n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              jOptionalField = payload;
              break;
            }
            case 66n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              kOptionalField = payload;
              break;
            }
            case 67n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              lOptionalField = payload;
              break;
            }
            case 68n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              mOptionalField = payload;
              break;
            }
            case 69n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              nOptionalField = payload;
              break;
            }
            case 70n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + offset + payloadSize,
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              oOptionalField = payload;
              break;
            }
            case 71n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(
                      dataView.buffer.slice(
                        dataView.byteOffset + offset,
                        dataView.byteOffset + offset + payloadSize,
                      ),
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              pOptionalField = payload;
              break;
            }
            case 72n: {
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              qOptionalField = payload;
              break;
            }
            case 73n: {
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              rOptionalField = payload;
              break;
            }
            case 74n: {
              let payload: undefined[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(undefined);
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              sOptionalField = payload;
              break;
            }
            case 75n: {
              let payload: number[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: number[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload = dataView.getFloat64(offset, true);
                          offset += 8;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              tOptionalField = payload;
              break;
            }
            case 76n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              uOptionalField = payload;
              break;
            }
            case 77n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payload = zigzagDecode(payload);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              vOptionalField = payload;
              break;
            }
            case 78n: {
              let payload: boolean[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: boolean[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          {
                            let newPayload;
                            {
                              let payload;
                              [offset, payload] = deserializeVarint(dataView, offset);
                              newPayload = payload !== 0n;
                            }
                            payload = newPayload;
                          }
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              wOptionalField = payload;
              break;
            }
            case 79n: {
              let payload: ArrayBuffer[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: ArrayBuffer[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + offset + payloadSize,
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              xOptionalField = payload;
              break;
            }
            case 80n: {
              let payload: string[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: string[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = textDecoder.decode(
                            dataView.buffer.slice(
                              dataView.byteOffset + offset,
                              dataView.byteOffset + offset + payloadSize,
                            ),
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              yOptionalField = payload;
              break;
            }
            case 81n: {
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              zOptionalField = payload;
              break;
            }
            case 82n: {
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              aaOptionalField = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if (bRequiredField === undefined || cRequiredField === undefined || dRequiredField === undefined || eRequiredField === undefined || fRequiredField === undefined || gRequiredField === undefined || hRequiredField === undefined || iRequiredField === undefined || jRequiredField === undefined || kRequiredField === undefined || lRequiredField === undefined || mRequiredField === undefined || nRequiredField === undefined || oRequiredField === undefined || pRequiredField === undefined || qRequiredField === undefined || rRequiredField === undefined || sRequiredField === undefined || tRequiredField === undefined || uRequiredField === undefined || vRequiredField === undefined || wRequiredField === undefined || xRequiredField === undefined || yRequiredField === undefined || zRequiredField === undefined || aaRequiredField === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return [
          offset,
          {
            aRequired: aRequiredField,
            bRequired: bRequiredField,
            cRequired: cRequiredField,
            dRequired: dRequiredField,
            eRequired: eRequiredField,
            fRequired: fRequiredField,
            gRequired: gRequiredField,
            hRequired: hRequiredField,
            iRequired: iRequiredField,
            jRequired: jRequiredField,
            kRequired: kRequiredField,
            lRequired: lRequiredField,
            mRequired: mRequiredField,
            nRequired: nRequiredField,
            oRequired: oRequiredField,
            pRequired: pRequiredField,
            qRequired: qRequiredField,
            rRequired: rRequiredField,
            sRequired: sRequiredField,
            tRequired: tRequiredField,
            uRequired: uRequiredField,
            vRequired: vRequiredField,
            wRequired: wRequiredField,
            xRequired: xRequiredField,
            yRequired: yRequiredField,
            zRequired: zRequiredField,
            aaRequired: aaRequiredField,
            aAsymmetric: aAsymmetricField,
            bAsymmetric: bAsymmetricField,
            cAsymmetric: cAsymmetricField,
            dAsymmetric: dAsymmetricField,
            eAsymmetric: eAsymmetricField,
            fAsymmetric: fAsymmetricField,
            gAsymmetric: gAsymmetricField,
            hAsymmetric: hAsymmetricField,
            iAsymmetric: iAsymmetricField,
            jAsymmetric: jAsymmetricField,
            kAsymmetric: kAsymmetricField,
            lAsymmetric: lAsymmetricField,
            mAsymmetric: mAsymmetricField,
            nAsymmetric: nAsymmetricField,
            oAsymmetric: oAsymmetricField,
            pAsymmetric: pAsymmetricField,
            qAsymmetric: qAsymmetricField,
            rAsymmetric: rAsymmetricField,
            sAsymmetric: sAsymmetricField,
            tAsymmetric: tAsymmetricField,
            uAsymmetric: uAsymmetricField,
            vAsymmetric: vAsymmetricField,
            wAsymmetric: wAsymmetricField,
            xAsymmetric: xAsymmetricField,
            yAsymmetric: yAsymmetricField,
            zAsymmetric: zAsymmetricField,
            aaAsymmetric: aaAsymmetricField,
            aOptional: aOptionalField,
            bOptional: bOptionalField,
            cOptional: cOptionalField,
            dOptional: dOptionalField,
            eOptional: eOptionalField,
            fOptional: fOptionalField,
            gOptional: gOptionalField,
            hOptional: hOptionalField,
            iOptional: iOptionalField,
            jOptional: jOptionalField,
            kOptional: kOptionalField,
            lOptional: lOptionalField,
            mOptional: mOptionalField,
            nOptional: nOptionalField,
            oOptional: oOptionalField,
            pOptional: pOptionalField,
            qOptional: qOptionalField,
            rOptional: rOptionalField,
            sOptional: sOptionalField,
            tOptional: tOptionalField,
            uOptional: uOptionalField,
            vOptional: vOptionalField,
            wOptional: wOptionalField,
            xOptional: xOptionalField,
            yOptional: yOptionalField,
            zOptional: zOptionalField,
            aaOptional: aaOptionalField,
          }
        ];
      }

      export function outToIn(value: FooOut): FooIn {
        return value;
      }
    }

    export type BarOut =
      | { field: 'aRequired' }
      | { field: 'bRequired'; value: number }
      | { field: 'cRequired'; value: bigint }
      | { field: 'dRequired'; value: bigint }
      | { field: 'eRequired'; value: boolean }
      | { field: 'fRequired'; value: ArrayBuffer }
      | { field: 'gRequired'; value: string }
      | { field: 'hRequired'; value: Comprehensive.Types.LocalStructOut }
      | { field: 'iRequired'; value: Degenerate.Types.EmptyStructOut }
      | { field: 'jRequired'; value: undefined[] }
      | { field: 'kRequired'; value: number[] }
      | { field: 'lRequired'; value: bigint[] }
      | { field: 'mRequired'; value: bigint[] }
      | { field: 'nRequired'; value: boolean[] }
      | { field: 'oRequired'; value: ArrayBuffer[] }
      | { field: 'pRequired'; value: string[] }
      | { field: 'qRequired'; value: Comprehensive.Types.LocalStructOut[] }
      | { field: 'rRequired'; value: Degenerate.Types.EmptyStructOut[] }
      | { field: 'sRequired'; value: undefined[][] }
      | { field: 'tRequired'; value: number[][] }
      | { field: 'uRequired'; value: bigint[][] }
      | { field: 'vRequired'; value: bigint[][] }
      | { field: 'wRequired'; value: boolean[][] }
      | { field: 'xRequired'; value: ArrayBuffer[][] }
      | { field: 'yRequired'; value: string[][] }
      | { field: 'zRequired'; value: Comprehensive.Types.LocalStructOut[][] }
      | { field: 'aaRequired'; value: Degenerate.Types.EmptyStructOut[][] }
      | { field: 'aAsymmetric'; fallback: BarOut }
      | { field: 'bAsymmetric'; value: number; fallback: BarOut }
      | { field: 'cAsymmetric'; value: bigint; fallback: BarOut }
      | { field: 'dAsymmetric'; value: bigint; fallback: BarOut }
      | { field: 'eAsymmetric'; value: boolean; fallback: BarOut }
      | { field: 'fAsymmetric'; value: ArrayBuffer; fallback: BarOut }
      | { field: 'gAsymmetric'; value: string; fallback: BarOut }
      | { field: 'hAsymmetric'; value: Comprehensive.Types.LocalStructOut; fallback: BarOut }
      | { field: 'iAsymmetric'; value: Degenerate.Types.EmptyStructOut; fallback: BarOut }
      | { field: 'jAsymmetric'; value: undefined[]; fallback: BarOut }
      | { field: 'kAsymmetric'; value: number[]; fallback: BarOut }
      | { field: 'lAsymmetric'; value: bigint[]; fallback: BarOut }
      | { field: 'mAsymmetric'; value: bigint[]; fallback: BarOut }
      | { field: 'nAsymmetric'; value: boolean[]; fallback: BarOut }
      | { field: 'oAsymmetric'; value: ArrayBuffer[]; fallback: BarOut }
      | { field: 'pAsymmetric'; value: string[]; fallback: BarOut }
      | { field: 'qAsymmetric'; value: Comprehensive.Types.LocalStructOut[]; fallback: BarOut }
      | { field: 'rAsymmetric'; value: Degenerate.Types.EmptyStructOut[]; fallback: BarOut }
      | { field: 'sAsymmetric'; value: undefined[][]; fallback: BarOut }
      | { field: 'tAsymmetric'; value: number[][]; fallback: BarOut }
      | { field: 'uAsymmetric'; value: bigint[][]; fallback: BarOut }
      | { field: 'vAsymmetric'; value: bigint[][]; fallback: BarOut }
      | { field: 'wAsymmetric'; value: boolean[][]; fallback: BarOut }
      | { field: 'xAsymmetric'; value: ArrayBuffer[][]; fallback: BarOut }
      | { field: 'yAsymmetric'; value: string[][]; fallback: BarOut }
      | { field: 'zAsymmetric'; value: Comprehensive.Types.LocalStructOut[][]; fallback: BarOut }
      | { field: 'aaAsymmetric'; value: Degenerate.Types.EmptyStructOut[][]; fallback: BarOut }
      | { field: 'aOptional'; fallback: BarOut }
      | { field: 'bOptional'; value: number; fallback: BarOut }
      | { field: 'cOptional'; value: bigint; fallback: BarOut }
      | { field: 'dOptional'; value: bigint; fallback: BarOut }
      | { field: 'eOptional'; value: boolean; fallback: BarOut }
      | { field: 'fOptional'; value: ArrayBuffer; fallback: BarOut }
      | { field: 'gOptional'; value: string; fallback: BarOut }
      | { field: 'hOptional'; value: Comprehensive.Types.LocalStructOut; fallback: BarOut }
      | { field: 'iOptional'; value: Degenerate.Types.EmptyStructOut; fallback: BarOut }
      | { field: 'jOptional'; value: undefined[]; fallback: BarOut }
      | { field: 'kOptional'; value: number[]; fallback: BarOut }
      | { field: 'lOptional'; value: bigint[]; fallback: BarOut }
      | { field: 'mOptional'; value: bigint[]; fallback: BarOut }
      | { field: 'nOptional'; value: boolean[]; fallback: BarOut }
      | { field: 'oOptional'; value: ArrayBuffer[]; fallback: BarOut }
      | { field: 'pOptional'; value: string[]; fallback: BarOut }
      | { field: 'qOptional'; value: Comprehensive.Types.LocalStructOut[]; fallback: BarOut }
      | { field: 'rOptional'; value: Degenerate.Types.EmptyStructOut[]; fallback: BarOut }
      | { field: 'sOptional'; value: undefined[][]; fallback: BarOut }
      | { field: 'tOptional'; value: number[][]; fallback: BarOut }
      | { field: 'uOptional'; value: bigint[][]; fallback: BarOut }
      | { field: 'vOptional'; value: bigint[][]; fallback: BarOut }
      | { field: 'wOptional'; value: boolean[][]; fallback: BarOut }
      | { field: 'xOptional'; value: ArrayBuffer[][]; fallback: BarOut }
      | { field: 'yOptional'; value: string[][]; fallback: BarOut }
      | { field: 'zOptional'; value: Comprehensive.Types.LocalStructOut[][]; fallback: BarOut }
      | { field: 'aaOptional'; value: Degenerate.Types.EmptyStructOut[][]; fallback: BarOut };

    export type BarIn =
      | { field: 'aRequired' }
      | { field: 'bRequired'; value: number }
      | { field: 'cRequired'; value: bigint }
      | { field: 'dRequired'; value: bigint }
      | { field: 'eRequired'; value: boolean }
      | { field: 'fRequired'; value: ArrayBuffer }
      | { field: 'gRequired'; value: string }
      | { field: 'hRequired'; value: Comprehensive.Types.LocalStructIn }
      | { field: 'iRequired'; value: Degenerate.Types.EmptyStructIn }
      | { field: 'jRequired'; value: undefined[] }
      | { field: 'kRequired'; value: number[] }
      | { field: 'lRequired'; value: bigint[] }
      | { field: 'mRequired'; value: bigint[] }
      | { field: 'nRequired'; value: boolean[] }
      | { field: 'oRequired'; value: ArrayBuffer[] }
      | { field: 'pRequired'; value: string[] }
      | { field: 'qRequired'; value: Comprehensive.Types.LocalStructIn[] }
      | { field: 'rRequired'; value: Degenerate.Types.EmptyStructIn[] }
      | { field: 'sRequired'; value: undefined[][] }
      | { field: 'tRequired'; value: number[][] }
      | { field: 'uRequired'; value: bigint[][] }
      | { field: 'vRequired'; value: bigint[][] }
      | { field: 'wRequired'; value: boolean[][] }
      | { field: 'xRequired'; value: ArrayBuffer[][] }
      | { field: 'yRequired'; value: string[][] }
      | { field: 'zRequired'; value: Comprehensive.Types.LocalStructIn[][] }
      | { field: 'aaRequired'; value: Degenerate.Types.EmptyStructIn[][] }
      | { field: 'aAsymmetric' }
      | { field: 'bAsymmetric'; value: number }
      | { field: 'cAsymmetric'; value: bigint }
      | { field: 'dAsymmetric'; value: bigint }
      | { field: 'eAsymmetric'; value: boolean }
      | { field: 'fAsymmetric'; value: ArrayBuffer }
      | { field: 'gAsymmetric'; value: string }
      | { field: 'hAsymmetric'; value: Comprehensive.Types.LocalStructIn }
      | { field: 'iAsymmetric'; value: Degenerate.Types.EmptyStructIn }
      | { field: 'jAsymmetric'; value: undefined[] }
      | { field: 'kAsymmetric'; value: number[] }
      | { field: 'lAsymmetric'; value: bigint[] }
      | { field: 'mAsymmetric'; value: bigint[] }
      | { field: 'nAsymmetric'; value: boolean[] }
      | { field: 'oAsymmetric'; value: ArrayBuffer[] }
      | { field: 'pAsymmetric'; value: string[] }
      | { field: 'qAsymmetric'; value: Comprehensive.Types.LocalStructIn[] }
      | { field: 'rAsymmetric'; value: Degenerate.Types.EmptyStructIn[] }
      | { field: 'sAsymmetric'; value: undefined[][] }
      | { field: 'tAsymmetric'; value: number[][] }
      | { field: 'uAsymmetric'; value: bigint[][] }
      | { field: 'vAsymmetric'; value: bigint[][] }
      | { field: 'wAsymmetric'; value: boolean[][] }
      | { field: 'xAsymmetric'; value: ArrayBuffer[][] }
      | { field: 'yAsymmetric'; value: string[][] }
      | { field: 'zAsymmetric'; value: Comprehensive.Types.LocalStructIn[][] }
      | { field: 'aaAsymmetric'; value: Degenerate.Types.EmptyStructIn[][] }
      | { field: 'aOptional'; fallback: BarIn }
      | { field: 'bOptional'; value: number; fallback: BarIn }
      | { field: 'cOptional'; value: bigint; fallback: BarIn }
      | { field: 'dOptional'; value: bigint; fallback: BarIn }
      | { field: 'eOptional'; value: boolean; fallback: BarIn }
      | { field: 'fOptional'; value: ArrayBuffer; fallback: BarIn }
      | { field: 'gOptional'; value: string; fallback: BarIn }
      | { field: 'hOptional'; value: Comprehensive.Types.LocalStructIn; fallback: BarIn }
      | { field: 'iOptional'; value: Degenerate.Types.EmptyStructIn; fallback: BarIn }
      | { field: 'jOptional'; value: undefined[]; fallback: BarIn }
      | { field: 'kOptional'; value: number[]; fallback: BarIn }
      | { field: 'lOptional'; value: bigint[]; fallback: BarIn }
      | { field: 'mOptional'; value: bigint[]; fallback: BarIn }
      | { field: 'nOptional'; value: boolean[]; fallback: BarIn }
      | { field: 'oOptional'; value: ArrayBuffer[]; fallback: BarIn }
      | { field: 'pOptional'; value: string[]; fallback: BarIn }
      | { field: 'qOptional'; value: Comprehensive.Types.LocalStructIn[]; fallback: BarIn }
      | { field: 'rOptional'; value: Degenerate.Types.EmptyStructIn[]; fallback: BarIn }
      | { field: 'sOptional'; value: undefined[][]; fallback: BarIn }
      | { field: 'tOptional'; value: number[][]; fallback: BarIn }
      | { field: 'uOptional'; value: bigint[][]; fallback: BarIn }
      | { field: 'vOptional'; value: bigint[][]; fallback: BarIn }
      | { field: 'wOptional'; value: boolean[][]; fallback: BarIn }
      | { field: 'xOptional'; value: ArrayBuffer[][]; fallback: BarIn }
      | { field: 'yOptional'; value: string[][]; fallback: BarIn }
      | { field: 'zOptional'; value: Comprehensive.Types.LocalStructIn[][]; fallback: BarIn }
      | { field: 'aaOptional'; value: Degenerate.Types.EmptyStructIn[][]; fallback: BarIn };

    export namespace Bar {
      export function size(value: BarOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'aRequired': {
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'bRequired': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize;
          }
          case 'cRequired': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(2n, payloadSize, true) + payloadSize;
          }
          case 'dRequired': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(3n, payloadSize, true) + payloadSize;
          }
          case 'eRequired': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(4n, payloadSize, true) + payloadSize;
          }
          case 'fRequired': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize;
          }
          case 'gRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize;
          }
          case 'hRequired': {
            const payload = value.value;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            return fieldHeaderSize(7n, payloadSize, false) + payloadSize;
          }
          case 'iRequired': {
            const payload = value.value;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize;
          }
          case 'jRequired': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(9n, payloadSize, false) + payloadSize;
          }
          case 'kRequired': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize;
          }
          case 'lRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(11n, payloadSize, false) + payloadSize;
          }
          case 'mRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(12n, payloadSize, false) + payloadSize;
          }
          case 'nRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(13n, payloadSize, false) + payloadSize;
          }
          case 'oRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(14n, payloadSize, false) + payloadSize;
          }
          case 'pRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(15n, payloadSize, false) + payloadSize;
          }
          case 'qRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(16n, payloadSize, false) + payloadSize;
          }
          case 'rRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(17n, payloadSize, false) + payloadSize;
          }
          case 'sRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(18n, payloadSize, false) + payloadSize;
          }
          case 'tRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(19n, payloadSize, false) + payloadSize;
          }
          case 'uRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(20n, payloadSize, false) + payloadSize;
          }
          case 'vRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(21n, payloadSize, false) + payloadSize;
          }
          case 'wRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(22n, payloadSize, false) + payloadSize;
          }
          case 'xRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(23n, payloadSize, false) + payloadSize;
          }
          case 'yRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(24n, payloadSize, false) + payloadSize;
          }
          case 'zRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(25n, payloadSize, false) + payloadSize;
          }
          case 'aaRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(26n, payloadSize, false) + payloadSize;
          }
          case 'aAsymmetric': {
            return fieldHeaderSize(28n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'bAsymmetric': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(29n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'cAsymmetric': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(30n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'dAsymmetric': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(31n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'eAsymmetric': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(32n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'fAsymmetric': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(33n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'gAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(34n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'hAsymmetric': {
            const payload = value.value;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            return fieldHeaderSize(35n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'iAsymmetric': {
            const payload = value.value;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            return fieldHeaderSize(36n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'jAsymmetric': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(37n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'kAsymmetric': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(38n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'lAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(39n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'mAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(40n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(41n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'oAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(42n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'pAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(43n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'qAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(44n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'rAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(45n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'sAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(46n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'tAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(47n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'uAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(48n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'vAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(49n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'wAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(50n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'xAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(51n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'yAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(52n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'zAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(53n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'aaAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(54n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'aOptional': {
            return fieldHeaderSize(56n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'bOptional': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(57n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'cOptional': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(58n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'dOptional': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(59n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'eOptional': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(60n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'fOptional': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(61n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'gOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(62n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'hOptional': {
            const payload = value.value;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            return fieldHeaderSize(63n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'iOptional': {
            const payload = value.value;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            return fieldHeaderSize(64n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'jOptional': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(65n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'kOptional': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(66n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'lOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(67n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'mOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(68n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(69n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'oOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(70n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'pOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(71n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'qOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(72n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'rOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(73n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'sOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(74n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'tOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(75n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'uOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(76n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'vOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(77n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'wOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(78n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'xOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(79n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'yOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(80n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'zOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(81n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'aaOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(82n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: BarOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'aRequired': {
            offset = serializeFieldHeader(dataView, offset, 0n, 0, false);
            return offset;
          }
          case 'bRequired': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
            return offset;
          }
          case 'cRequired': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'dRequired': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'eRequired': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'fRequired': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'gRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'hRequired': {
            const payload = value.value;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
            offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
            return offset;
          }
          case 'iRequired': {
            const payload = value.value;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
            return offset;
          }
          case 'jRequired': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'kRequired': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
            return offset;
          }
          case 'lRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'mRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'nRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'oRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            return offset;
          }
          case 'pRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 15n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            return offset;
          }
          case 'qRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 16n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
              }
            }
            return offset;
          }
          case 'rRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
              }
            }
            return offset;
          }
          case 'sRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const varint = BigInt(payload.length);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'tRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 19n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8 * payload.length;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = 8;
                    dataView.setFloat64(offset, payload, true);
                  }
                }
              }
            }
            return offset;
          }
          case 'uRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 20n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = varintSizeFromValue(payload);
                    {
                      const varint = payload;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            return offset;
          }
          case 'vRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 21n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    {
                      const varint = zigzagEncode(payload);
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            return offset;
          }
          case 'wRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 22n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = 1;
                    {
                      const varint = payload ? 1n : 0n;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            return offset;
          }
          case 'xRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 23n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = payload.byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = new Uint8Array(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
            return offset;
          }
          case 'yRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 24n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = textEncoder.encode(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
            return offset;
          }
          case 'zRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 25n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            return offset;
          }
          case 'aaRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 26n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            return offset;
          }
          case 'aAsymmetric': {
            offset = serializeFieldHeader(dataView, offset, 28n, 0, false);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'bAsymmetric': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 29n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'cAsymmetric': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 30n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'dAsymmetric': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 31n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'eAsymmetric': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 32n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'fAsymmetric': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 33n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'gAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 34n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'hAsymmetric': {
            const payload = value.value;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 35n, payloadSize, false);
            offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'iAsymmetric': {
            const payload = value.value;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 36n, payloadSize, false);
            offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'jAsymmetric': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 37n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'kAsymmetric': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 38n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'lAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 39n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'mAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 40n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 41n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'oAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 42n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'pAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 43n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'qAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 44n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'rAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 45n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'sAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 46n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const varint = BigInt(payload.length);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'tAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 47n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8 * payload.length;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = 8;
                    dataView.setFloat64(offset, payload, true);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'uAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 48n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = varintSizeFromValue(payload);
                    {
                      const varint = payload;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'vAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 49n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    {
                      const varint = zigzagEncode(payload);
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'wAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 50n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = 1;
                    {
                      const varint = payload ? 1n : 0n;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'xAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 51n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = payload.byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = new Uint8Array(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'yAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 52n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = textEncoder.encode(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'zAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 53n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'aaAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 54n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'aOptional': {
            offset = serializeFieldHeader(dataView, offset, 56n, 0, false);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'bOptional': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 57n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'cOptional': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 58n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'dOptional': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 59n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'eOptional': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 60n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'fOptional': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 61n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'gOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 62n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'hOptional': {
            const payload = value.value;
            payloadSize = Comprehensive.Types.LocalStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 63n, payloadSize, false);
            offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'iOptional': {
            const payload = value.value;
            payloadSize = Degenerate.Types.EmptyStruct.size(payload);
            offset = serializeFieldHeader(dataView, offset, 64n, payloadSize, false);
            offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'jOptional': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 65n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'kOptional': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 66n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'lOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 67n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'mOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 68n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 69n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'oOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 70n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'pOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 71n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'qOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 72n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'rOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 73n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'sOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 74n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  const oldPayload = payload;
                  {
                    const payload = BigInt(oldPayload.length);
                    payloadSize = varintSizeFromValue(payload);
                  }
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const varint = BigInt(payload.length);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'tOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 8 * payload.length;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 75n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8 * payload.length;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = 8;
                    dataView.setFloat64(offset, payload, true);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'uOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 76n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(payload);
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = varintSizeFromValue(payload);
                    {
                      const varint = payload;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'vOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 77n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = varintSizeFromValue(zigzagEncode(payload));
                    {
                      const varint = zigzagEncode(payload);
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'wOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 78n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = 1;
                    arraySize += payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = 1;
                    {
                      const varint = payload ? 1n : 0n;
                      offset = serializeVarint(dataView, offset, varint);
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'xOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 79n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = payload.byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = payload.byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = new Uint8Array(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'yOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 80n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = textEncoder.encode(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'zOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 81n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Comprehensive.Types.LocalStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Types.LocalStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'aaOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 82n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Degenerate.Types.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Degenerate.Types.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, BarIn] {
        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              return [
                offset,
                {
                  field: 'aRequired',
                },
              ];
            }
            case 1n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              return [
                offset,
                {
                  field: 'bRequired',
                  value: payload,
                },
              ];
            }
            case 2n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              return [
                offset,
                {
                  field: 'cRequired',
                  value: payload,
                },
              ];
            }
            case 3n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              return [
                offset,
                {
                  field: 'dRequired',
                  value: payload,
                },
              ];
            }
            case 4n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              return [
                offset,
                {
                  field: 'eRequired',
                  value: payload,
                },
              ];
            }
            case 5n: {
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + offset + payloadSize,
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'fRequired',
                  value: payload,
                },
              ];
            }
            case 6n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'gRequired',
                  value: payload,
                },
              ];
            }
            case 7n: {
              let payload;
              [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
              return [
                offset,
                {
                  field: 'hRequired',
                  value: payload,
                },
              ];
            }
            case 8n: {
              let payload;
              [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
              return [
                offset,
                {
                  field: 'iRequired',
                  value: payload,
                },
              ];
            }
            case 9n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              return [
                offset,
                {
                  field: 'jRequired',
                  value: payload,
                },
              ];
            }
            case 10n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'kRequired',
                  value: payload,
                },
              ];
            }
            case 11n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'lRequired',
                  value: payload,
                },
              ];
            }
            case 12n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'mRequired',
                  value: payload,
                },
              ];
            }
            case 13n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'nRequired',
                  value: payload,
                },
              ];
            }
            case 14n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + offset + payloadSize,
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'oRequired',
                  value: payload,
                },
              ];
            }
            case 15n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(
                      dataView.buffer.slice(
                        dataView.byteOffset + offset,
                        dataView.byteOffset + offset + payloadSize,
                      ),
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'pRequired',
                  value: payload,
                },
              ];
            }
            case 16n: {
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'qRequired',
                  value: payload,
                },
              ];
            }
            case 17n: {
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'rRequired',
                  value: payload,
                },
              ];
            }
            case 18n: {
              let payload: undefined[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(undefined);
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'sRequired',
                  value: payload,
                },
              ];
            }
            case 19n: {
              let payload: number[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: number[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload = dataView.getFloat64(offset, true);
                          offset += 8;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'tRequired',
                  value: payload,
                },
              ];
            }
            case 20n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'uRequired',
                  value: payload,
                },
              ];
            }
            case 21n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payload = zigzagDecode(payload);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'vRequired',
                  value: payload,
                },
              ];
            }
            case 22n: {
              let payload: boolean[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: boolean[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          {
                            let newPayload;
                            {
                              let payload;
                              [offset, payload] = deserializeVarint(dataView, offset);
                              newPayload = payload !== 0n;
                            }
                            payload = newPayload;
                          }
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'wRequired',
                  value: payload,
                },
              ];
            }
            case 23n: {
              let payload: ArrayBuffer[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: ArrayBuffer[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + offset + payloadSize,
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'xRequired',
                  value: payload,
                },
              ];
            }
            case 24n: {
              let payload: string[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: string[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = textDecoder.decode(
                            dataView.buffer.slice(
                              dataView.byteOffset + offset,
                              dataView.byteOffset + offset + payloadSize,
                            ),
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'yRequired',
                  value: payload,
                },
              ];
            }
            case 25n: {
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'zRequired',
                  value: payload,
                },
              ];
            }
            case 26n: {
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'aaRequired',
                  value: payload,
                },
              ];
            }
            case 28n: {
              return [
                offset,
                {
                  field: 'aAsymmetric',
                },
              ];
            }
            case 29n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              return [
                offset,
                {
                  field: 'bAsymmetric',
                  value: payload,
                },
              ];
            }
            case 30n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              return [
                offset,
                {
                  field: 'cAsymmetric',
                  value: payload,
                },
              ];
            }
            case 31n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              return [
                offset,
                {
                  field: 'dAsymmetric',
                  value: payload,
                },
              ];
            }
            case 32n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              return [
                offset,
                {
                  field: 'eAsymmetric',
                  value: payload,
                },
              ];
            }
            case 33n: {
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + offset + payloadSize,
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'fAsymmetric',
                  value: payload,
                },
              ];
            }
            case 34n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'gAsymmetric',
                  value: payload,
                },
              ];
            }
            case 35n: {
              let payload;
              [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
              return [
                offset,
                {
                  field: 'hAsymmetric',
                  value: payload,
                },
              ];
            }
            case 36n: {
              let payload;
              [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
              return [
                offset,
                {
                  field: 'iAsymmetric',
                  value: payload,
                },
              ];
            }
            case 37n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              return [
                offset,
                {
                  field: 'jAsymmetric',
                  value: payload,
                },
              ];
            }
            case 38n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'kAsymmetric',
                  value: payload,
                },
              ];
            }
            case 39n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'lAsymmetric',
                  value: payload,
                },
              ];
            }
            case 40n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'mAsymmetric',
                  value: payload,
                },
              ];
            }
            case 41n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'nAsymmetric',
                  value: payload,
                },
              ];
            }
            case 42n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + offset + payloadSize,
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'oAsymmetric',
                  value: payload,
                },
              ];
            }
            case 43n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(
                      dataView.buffer.slice(
                        dataView.byteOffset + offset,
                        dataView.byteOffset + offset + payloadSize,
                      ),
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'pAsymmetric',
                  value: payload,
                },
              ];
            }
            case 44n: {
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'qAsymmetric',
                  value: payload,
                },
              ];
            }
            case 45n: {
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'rAsymmetric',
                  value: payload,
                },
              ];
            }
            case 46n: {
              let payload: undefined[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(undefined);
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'sAsymmetric',
                  value: payload,
                },
              ];
            }
            case 47n: {
              let payload: number[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: number[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload = dataView.getFloat64(offset, true);
                          offset += 8;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'tAsymmetric',
                  value: payload,
                },
              ];
            }
            case 48n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'uAsymmetric',
                  value: payload,
                },
              ];
            }
            case 49n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payload = zigzagDecode(payload);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'vAsymmetric',
                  value: payload,
                },
              ];
            }
            case 50n: {
              let payload: boolean[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: boolean[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          {
                            let newPayload;
                            {
                              let payload;
                              [offset, payload] = deserializeVarint(dataView, offset);
                              newPayload = payload !== 0n;
                            }
                            payload = newPayload;
                          }
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'wAsymmetric',
                  value: payload,
                },
              ];
            }
            case 51n: {
              let payload: ArrayBuffer[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: ArrayBuffer[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + offset + payloadSize,
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'xAsymmetric',
                  value: payload,
                },
              ];
            }
            case 52n: {
              let payload: string[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: string[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = textDecoder.decode(
                            dataView.buffer.slice(
                              dataView.byteOffset + offset,
                              dataView.byteOffset + offset + payloadSize,
                            ),
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'yAsymmetric',
                  value: payload,
                },
              ];
            }
            case 53n: {
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'zAsymmetric',
                  value: payload,
                },
              ];
            }
            case 54n: {
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'aaAsymmetric',
                  value: payload,
                },
              ];
            }
            case 56n: {
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'aOptional',
                  fallback,
                },
              ];
            }
            case 57n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'bOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 58n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'cOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 59n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'dOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 60n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'eOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 61n: {
              let payload = dataView.buffer.slice(
                dataView.byteOffset + offset,
                dataView.byteOffset + offset + payloadSize,
              );
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'fOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 62n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'gOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 63n: {
              let payload;
              [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'hOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 64n: {
              let payload;
              [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'iOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 65n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'jOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 66n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'kOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 67n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'lOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 68n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'mOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 69n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'nOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 70n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(
                      dataView.byteOffset + offset,
                      dataView.byteOffset + offset + payloadSize,
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'oOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 71n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(
                      dataView.buffer.slice(
                        dataView.byteOffset + offset,
                        dataView.byteOffset + offset + payloadSize,
                      ),
                    );
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'pOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 72n: {
              let payload: Comprehensive.Types.LocalStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'qOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 73n: {
              let payload: Degenerate.Types.EmptyStructIn[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'rOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 74n: {
              let payload: undefined[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = Array(Number(payload)).fill(undefined);
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'sOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 75n: {
              let payload: number[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: number[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload = dataView.getFloat64(offset, true);
                          offset += 8;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'tOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 76n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'uOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 77n: {
              let payload: bigint[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: bigint[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          [offset, payload] = deserializeVarint(dataView, offset);
                          payload = zigzagDecode(payload);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'vOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 78n: {
              let payload: boolean[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: boolean[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payload;
                          {
                            let newPayload;
                            {
                              let payload;
                              [offset, payload] = deserializeVarint(dataView, offset);
                              newPayload = payload !== 0n;
                            }
                            payload = newPayload;
                          }
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'wOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 79n: {
              let payload: ArrayBuffer[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: ArrayBuffer[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = dataView.buffer.slice(
                            dataView.byteOffset + offset,
                            dataView.byteOffset + offset + payloadSize,
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'xOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 80n: {
              let payload: string[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: string[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload = textDecoder.decode(
                            dataView.buffer.slice(
                              dataView.byteOffset + offset,
                              dataView.byteOffset + offset + payloadSize,
                            ),
                          );
                          offset += payloadSize;
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'yOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 81n: {
              let payload: Comprehensive.Types.LocalStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Types.LocalStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Comprehensive.Types.LocalStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'zOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 82n: {
              let payload: Degenerate.Types.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Degenerate.Types.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = Degenerate.Types.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'aaOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: BarOut): BarIn {
        return value;
      }
    }
  }
}

export namespace Degenerate {
  export namespace Types {
    export type EmptyStructOut = {
    };

    export type EmptyStructIn = {
    };

    export namespace EmptyStruct {
      export function size(value: EmptyStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: EmptyStructOut,
      ): number {
        let payloadSize = 0;

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, EmptyStructIn] {
        return [
          offset,
          {
          }
        ];
      }

      export function outToIn(value: EmptyStructOut): EmptyStructIn {
        return value;
      }
    }

    export type EmptyChoiceOut = never;

    export type EmptyChoiceIn = never;

    export namespace EmptyChoice {
      export function size(value: EmptyChoiceOut): number {
        return 0;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: EmptyChoiceOut,
      ): number {
        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, EmptyChoiceIn] {
        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          offset = newOffset;
          switch (index) {
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: EmptyChoiceOut): EmptyChoiceIn {
        return value;
      }
    }
  }
}

export namespace SchemaEvolution {
  export namespace After {
    export type ExampleStructOut = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional?: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric: string;
      asymmetricToOptional?: string;
      optionalToRequired: string;
      optionalToAsymmetric: string;
      optionalToOptional?: string;
      nonexistentToAsymmetric: undefined;
      nonexistentToOptional?: undefined;
    };

    export type ExampleStructIn = {
      requiredToRequired: string;
      requiredToAsymmetric?: string;
      requiredToOptional?: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric?: string;
      asymmetricToOptional?: string;
      optionalToRequired: string;
      optionalToAsymmetric?: string;
      optionalToOptional?: string;
      nonexistentToAsymmetric?: undefined;
      nonexistentToOptional?: undefined;
    };

    export namespace ExampleStruct {
      export function size(value: ExampleStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(2n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(4n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(8n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nonexistentToAsymmetric;
          payloadSize = 0;
          valueSize += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nonexistentToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.optionalToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.optionalToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.nonexistentToAsymmetric;
          payloadSize = 0;
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
        }

        {
          const payload = value.nonexistentToOptional;
          if (payload !== undefined) {
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleStructIn] {
        let requiredToRequiredField, requiredToAsymmetricField, requiredToOptionalField, asymmetricToRequiredField, asymmetricToAsymmetricField, asymmetricToOptionalField, optionalToRequiredField, optionalToAsymmetricField, optionalToOptionalField, nonexistentToAsymmetricField, nonexistentToOptionalField;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              requiredToRequiredField = payload;
              break;
            }
            case 1n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              requiredToAsymmetricField = payload;
              break;
            }
            case 2n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              requiredToOptionalField = payload;
              break;
            }
            case 4n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              asymmetricToRequiredField = payload;
              break;
            }
            case 5n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              asymmetricToAsymmetricField = payload;
              break;
            }
            case 6n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              asymmetricToOptionalField = payload;
              break;
            }
            case 8n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              optionalToRequiredField = payload;
              break;
            }
            case 9n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              optionalToAsymmetricField = payload;
              break;
            }
            case 10n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              optionalToOptionalField = payload;
              break;
            }
            case 13n: {
              break;
            }
            case 14n: {
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if (requiredToRequiredField === undefined || asymmetricToRequiredField === undefined || optionalToRequiredField === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return [
          offset,
          {
            requiredToRequired: requiredToRequiredField,
            requiredToAsymmetric: requiredToAsymmetricField,
            requiredToOptional: requiredToOptionalField,
            asymmetricToRequired: asymmetricToRequiredField,
            asymmetricToAsymmetric: asymmetricToAsymmetricField,
            asymmetricToOptional: asymmetricToOptionalField,
            optionalToRequired: optionalToRequiredField,
            optionalToAsymmetric: optionalToAsymmetricField,
            optionalToOptional: optionalToOptionalField,
            nonexistentToAsymmetric: nonexistentToAsymmetricField,
            nonexistentToOptional: nonexistentToOptionalField,
          }
        ];
      }

      export function outToIn(value: ExampleStructOut): ExampleStructIn {
        return value;
      }
    }

    export type ExampleChoiceOut =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToRequired'; value: string }
      | { field: 'asymmetricToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToOptional'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToRequired'; value: string }
      | { field: 'optionalToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToOptional'; value: string; fallback: ExampleChoiceOut }
      | { field: 'nonexistentToRequired' }
      | { field: 'nonexistentToAsymmetric'; fallback: ExampleChoiceOut }
      | { field: 'nonexistentToOptional'; fallback: ExampleChoiceOut };

    export type ExampleChoiceIn =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string }
      | { field: 'asymmetricToRequired'; value: string }
      | { field: 'asymmetricToAsymmetric'; value: string }
      | { field: 'asymmetricToOptional'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToRequired'; value: string }
      | { field: 'optionalToAsymmetric'; value: string }
      | { field: 'optionalToOptional'; value: string; fallback: ExampleChoiceIn }
      | { field: 'nonexistentToRequired' }
      | { field: 'nonexistentToAsymmetric' }
      | { field: 'nonexistentToOptional'; fallback: ExampleChoiceIn };

    export namespace ExampleChoice {
      export function size(value: ExampleChoiceOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(4n, payloadSize, false) + payloadSize;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize;
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(9n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nonexistentToRequired': {
            return fieldHeaderSize(12n, payloadSize, false) + payloadSize;
          }
          case 'nonexistentToAsymmetric': {
            return fieldHeaderSize(13n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nonexistentToOptional': {
            return fieldHeaderSize(14n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nonexistentToRequired': {
            offset = serializeFieldHeader(dataView, offset, 12n, 0, false);
            return offset;
          }
          case 'nonexistentToAsymmetric': {
            offset = serializeFieldHeader(dataView, offset, 13n, 0, false);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nonexistentToOptional': {
            offset = serializeFieldHeader(dataView, offset, 14n, 0, false);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleChoiceIn] {
        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'requiredToRequired',
                  value: payload,
                },
              ];
            }
            case 1n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'requiredToAsymmetric',
                  value: payload,
                },
              ];
            }
            case 4n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToRequired',
                  value: payload,
                },
              ];
            }
            case 5n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToAsymmetric',
                  value: payload,
                },
              ];
            }
            case 6n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'asymmetricToOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 8n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'optionalToRequired',
                  value: payload,
                },
              ];
            }
            case 9n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'optionalToAsymmetric',
                  value: payload,
                },
              ];
            }
            case 10n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 12n: {
              return [
                offset,
                {
                  field: 'nonexistentToRequired',
                },
              ];
            }
            case 13n: {
              return [
                offset,
                {
                  field: 'nonexistentToAsymmetric',
                },
              ];
            }
            case 14n: {
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'nonexistentToOptional',
                  fallback,
                },
              ];
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: ExampleChoiceOut): ExampleChoiceIn {
        return value;
      }
    }
  }

  export namespace Before {
    export type ExampleStructOut = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional: string;
      requiredToNonexistent: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric: string;
      asymmetricToOptional: string;
      asymmetricToNonexistent: string;
      optionalToRequired?: string;
      optionalToAsymmetric?: string;
      optionalToOptional?: string;
      optionalToNonexistent?: string;
    };

    export type ExampleStructIn = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional: string;
      requiredToNonexistent: string;
      asymmetricToRequired?: string;
      asymmetricToAsymmetric?: string;
      asymmetricToOptional?: string;
      asymmetricToNonexistent?: string;
      optionalToRequired?: string;
      optionalToAsymmetric?: string;
      optionalToOptional?: string;
      optionalToNonexistent?: string;
    };

    export namespace ExampleStruct {
      export function size(value: ExampleStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(2n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(3n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(4n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(7n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalToRequired;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(8n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalToAsymmetric;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalToNonexistent;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(11n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.optionalToRequired;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalToAsymmetric;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalToNonexistent;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleStructIn] {
        let requiredToRequiredField, requiredToAsymmetricField, requiredToOptionalField, requiredToNonexistentField, asymmetricToRequiredField, asymmetricToAsymmetricField, asymmetricToOptionalField, asymmetricToNonexistentField, optionalToRequiredField, optionalToAsymmetricField, optionalToOptionalField, optionalToNonexistentField;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              requiredToRequiredField = payload;
              break;
            }
            case 1n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              requiredToAsymmetricField = payload;
              break;
            }
            case 2n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              requiredToOptionalField = payload;
              break;
            }
            case 3n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              requiredToNonexistentField = payload;
              break;
            }
            case 4n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              asymmetricToRequiredField = payload;
              break;
            }
            case 5n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              asymmetricToAsymmetricField = payload;
              break;
            }
            case 6n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              asymmetricToOptionalField = payload;
              break;
            }
            case 7n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              asymmetricToNonexistentField = payload;
              break;
            }
            case 8n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              optionalToRequiredField = payload;
              break;
            }
            case 9n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              optionalToAsymmetricField = payload;
              break;
            }
            case 10n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              optionalToOptionalField = payload;
              break;
            }
            case 11n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              optionalToNonexistentField = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if (requiredToRequiredField === undefined || requiredToAsymmetricField === undefined || requiredToOptionalField === undefined || requiredToNonexistentField === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return [
          offset,
          {
            requiredToRequired: requiredToRequiredField,
            requiredToAsymmetric: requiredToAsymmetricField,
            requiredToOptional: requiredToOptionalField,
            requiredToNonexistent: requiredToNonexistentField,
            asymmetricToRequired: asymmetricToRequiredField,
            asymmetricToAsymmetric: asymmetricToAsymmetricField,
            asymmetricToOptional: asymmetricToOptionalField,
            asymmetricToNonexistent: asymmetricToNonexistentField,
            optionalToRequired: optionalToRequiredField,
            optionalToAsymmetric: optionalToAsymmetricField,
            optionalToOptional: optionalToOptionalField,
            optionalToNonexistent: optionalToNonexistentField,
          }
        ];
      }

      export function outToIn(value: ExampleStructOut): ExampleStructIn {
        return value;
      }
    }

    export type ExampleChoiceOut =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string }
      | { field: 'asymmetricToRequired'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToOptional'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToNonexistent'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToRequired'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToOptional'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToNonexistent'; value: string; fallback: ExampleChoiceOut };

    export type ExampleChoiceIn =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string }
      | { field: 'asymmetricToRequired'; value: string }
      | { field: 'asymmetricToAsymmetric'; value: string }
      | { field: 'asymmetricToOptional'; value: string }
      | { field: 'asymmetricToNonexistent'; value: string }
      | { field: 'optionalToRequired'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToAsymmetric'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToOptional'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToNonexistent'; value: string; fallback: ExampleChoiceIn };

    export namespace ExampleChoice {
      export function size(value: ExampleChoiceOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize;
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(4n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(7n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(9n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(11n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleChoiceIn] {
        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'requiredToRequired',
                  value: payload,
                },
              ];
            }
            case 1n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'requiredToAsymmetric',
                  value: payload,
                },
              ];
            }
            case 4n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToRequired',
                  value: payload,
                },
              ];
            }
            case 5n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToAsymmetric',
                  value: payload,
                },
              ];
            }
            case 6n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToOptional',
                  value: payload,
                },
              ];
            }
            case 7n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToNonexistent',
                  value: payload,
                },
              ];
            }
            case 8n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToRequired',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 9n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToAsymmetric',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 10n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 11n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToNonexistent',
                  value: payload,
                  fallback,
                },
              ];
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: ExampleChoiceOut): ExampleChoiceIn {
        return value;
      }
    }
  }

  export namespace Types {
    export type SingletonStructOut = {
      x: string;
    };

    export type SingletonStructIn = {
      x: string;
    };

    export namespace SingletonStruct {
      export function size(value: SingletonStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: SingletonStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, SingletonStructIn] {
        let xField;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              xField = payload;
              break;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if (xField === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return [
          offset,
          {
            x: xField,
          }
        ];
      }

      export function outToIn(value: SingletonStructOut): SingletonStructIn {
        return value;
      }
    }

    export type SingletonChoiceOut =
      | { field: 'x'; value: string }
      | { field: never };

    export type SingletonChoiceIn =
      | { field: 'x'; value: string }
      | { field: never };

    export namespace SingletonChoice {
      export function size(value: SingletonChoiceOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'x': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: SingletonChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'x': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, SingletonChoiceIn] {
        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(
                dataView.buffer.slice(
                  dataView.byteOffset + offset,
                  dataView.byteOffset + offset + payloadSize,
                ),
              );
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'x',
                  value: payload,
                },
              ];
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: SingletonChoiceOut): SingletonChoiceIn {
        return value;
      }
    }
  }
}

export namespace Types {
}
