use crate::{
    identifier::Identifier,
    schema::{self, relativize_namespace},
};
use std::{
    collections::BTreeMap,
    fmt::{self, Write},
    path::PathBuf,
};

// The string to be used for each indentation level.
const INDENTATION: &str = "    ";

// The generated types will derive these traits.
const TRAITS_TO_DERIVE: &[&str] = &["Clone", "Debug"];

// This is the full list of Rust 2018 keywords, both in use and reserved.
const RUST_KEYWORDS: &[&str] = &[
    "Self", "abstract", "as", "async", "await", "become", "box", "break", "const", "continue",
    "crate", "do", "dyn", "else", "enum", "extern", "false", "final", "fn", "for", "if", "impl",
    "in", "let", "loop", "macro", "match", "mod", "move", "mut", "override", "priv", "pub", "ref",
    "return", "self", "static", "struct", "super", "trait", "true", "try", "type", "typeof",
    "unsafe", "unsized", "use", "virtual", "where", "while", "yield",
];

// This struct represents a tree of schemas organized in a module hierarchy.
#[derive(Clone, Debug)]
struct Module {
    children: BTreeMap<Identifier, Module>,
    schema: schema::Schema,
}

// This enum represents a case convention for the `write_identifier` function below.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum CaseConvention {
    Pascal,
    Snake,
}

use CaseConvention::{Pascal, Snake};

// This enum is used to distinguish between the flavors of a struct type.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum StructFlavor {
    In,
    Out,
}

use StructFlavor::{In, Out};

// This enum is used to distinguish between the flavors of a choice type.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum ChoiceFlavor {
    InOrOut(StructFlavor),
    OutStable,
}

use ChoiceFlavor::{InOrOut, OutStable};

// Generate Rust code from a schema and its transitive dependencies.
#[allow(clippy::too_many_lines)]
pub fn generate(
    typical_version: &str,
    schemas: BTreeMap<schema::Namespace, (schema::Schema, PathBuf, String)>,
) -> String {
    // Construct a tree of modules and schemas. We start with an empty tree.
    let mut tree = Module {
        children: BTreeMap::new(),
        schema: schema::Schema {
            imports: BTreeMap::new(),
            declarations: BTreeMap::new(),
        },
    };

    // Populate the tree with all the schemas.
    for (namespace, (schema, _, _)) in schemas {
        insert_schema(&mut tree, &namespace, schema);
    }

    // Write the code.
    let mut buffer = String::new();

    if !tree.children.is_empty() || !tree.schema.declarations.is_empty() {
        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        writeln!(
            &mut buffer,
            "\
// This file was automatically generated by Typical {}.
// Visit https://github.com/stepchowfun/typical for more information.

#![allow(clippy::all, clippy::pedantic, clippy::nursery, warnings)]

#[rustfmt::skip]
use std::io::{{self, BufRead, Error, ErrorKind, Write}};

#[rustfmt::skip]
pub trait Serialize {{
    const VARINT_ENCODED: bool;

    fn size(&self) -> u64;

    fn serialize(&self, writer: impl Write) -> io::Result<()>;
}}

#[rustfmt::skip]
pub trait Deserialize {{
    fn deserialize(reader: impl BufRead) -> io::Result<Self>
    where
        Self: Sized;
}}

#[rustfmt::skip]
impl Serialize for bool {{
    const VARINT_ENCODED: bool = true;

    fn size(&self) -> u64 {{
        1
    }}

    fn serialize(&self, writer: impl Write) -> io::Result<()> {{
        (*self as u64).serialize(writer)
    }}
}}

#[rustfmt::skip]
impl Deserialize for bool {{
    fn deserialize(reader: impl BufRead) -> io::Result<Self>
    where
        Self: Sized,
    {{
        match u64::deserialize(reader)? {{
            0 => Ok(false),
            1 => Ok(true),
            _ => Err(Error::new(
                ErrorKind::InvalidData,
                \"Error decoding Boolean.\",
            )),
        }}
    }}
}}

#[rustfmt::skip]
impl Serialize for u64 {{
    const VARINT_ENCODED: bool = true;

    fn size(&self) -> u64 {{
        let mut size = 1_u64;
        let mut upper_bound_exclusive = 0_u64;

        while size < 9_u64 {{
            upper_bound_exclusive += 1_u64 << (size * 7_u64);

            if *self < upper_bound_exclusive {{
                break;
            }}

            size += 1_u64;
        }}

        size
    }}

    fn serialize(&self, mut writer: impl Write) -> io::Result<()> {{
        let size = self.size();
        let size_minus_one = size - 1;

        let mut x = *self;
        for i in 1..size {{
            x -= 1_u64 << (i * 7);
        }}

        writer.write_all(&[((x << size) | (1_u64 << size_minus_one)) as u8])?;
        x >>= 8_u64.saturating_sub(size);

        for _ in 0..size_minus_one {{
            writer.write_all(&[x as u8])?;
            x >>= 8;
        }}

        Ok(())
    }}
}}

#[rustfmt::skip]
impl Deserialize for u64 {{
    fn deserialize(mut reader: impl BufRead) -> io::Result<Self>
    where
        Self: Sized,
    {{
        let mut buffer = [0; 9];
        reader.read_exact(&mut buffer[0..1])?;
        let first_byte = buffer[0];
        let size = u64_size(first_byte) as usize;

        reader.read_exact(&mut buffer[1..size])?;

        let mut x = u64::from(first_byte) >> size;
        let mut bits_read = 8_usize.saturating_sub(size);

        for byte in buffer.iter().skip(1) {{
            x |= u64::from(*byte) << bits_read;
            bits_read += 8;
        }}

        for i in 1..size {{
            x = x.checked_add(1_u64 << (i * 7)).ok_or_else(|| {{
                Error::new(ErrorKind::InvalidData, \"Error decoding 64-bit integer.\")
            }})?;
        }}

        Ok(x)
    }}
}}

#[rustfmt::skip]
impl Serialize for f64 {{
    const VARINT_ENCODED: bool = false;

    fn size(&self) -> u64 {{
        8
    }}

    fn serialize(&self, mut writer: impl Write) -> io::Result<()> {{
        writer.write_all(&self.to_le_bytes())
    }}
}}

#[rustfmt::skip]
impl Deserialize for f64 {{
    fn deserialize(mut reader: impl BufRead) -> io::Result<Self>
    where
        Self: Sized,
    {{
        let mut buffer = [0; 8];
        reader.read_exact(&mut buffer)?;
        Ok(f64::from_le_bytes(buffer))
    }}
}}

#[rustfmt::skip]
fn u64_size(first_byte: u8) -> u32 {{
    first_byte.trailing_zeros() + 1
}}

#[rustfmt::skip]
fn field_size<T: Serialize>(tag: u64, value: &T) -> u64 {{
    if T::VARINT_ENCODED {{
        ((tag << 2) | 0b00).size() + value.size()
    }} else {{
        (match value.size() {{
            0 => ((tag << 2) | 0b01).size(),
            8 => ((tag << 2) | 0b10).size(),
            size => ((tag << 2) | 0b11).size() + size.size(),
        }}) + value.size()
    }}
}}

#[rustfmt::skip]
fn skip(mut reader: impl BufRead, mut amount: usize) -> io::Result<()> {{
    while amount > 0 {{
        let buffer = ::std::io::BufRead::fill_buf(reader.by_ref())?;
        let num_bytes_to_consume = std::cmp::min(buffer.len(), amount);
        ::std::io::BufRead::consume(reader.by_ref(), num_bytes_to_consume);
        amount -= num_bytes_to_consume;
    }}

    Ok(())
}}

#[rustfmt::skip]
fn serialize_field<T: Serialize>(mut writer: impl Write, tag: u64, value: &T) -> io::Result<()> {{
    if T::VARINT_ENCODED {{
        ((tag << 2) | 0b00).serialize(writer.by_ref())?;
    }} else {{
        match value.size() {{
            0 => {{
                ((tag << 2) | 0b01).serialize(writer.by_ref())?;
            }}
            8 => {{
                ((tag << 2) | 0b10).serialize(writer.by_ref())?;
            }}
            size => {{
                ((tag << 2) | 0b11).serialize(writer.by_ref())?;
                size.serialize(writer.by_ref())?;
            }}
        }}
    }}

    value.serialize(writer)
}}",
            typical_version,
        )
        .unwrap();

        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        writeln!(&mut buffer).unwrap();

        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        write_module_contents(
            &mut buffer,
            0,
            &schema::Namespace { components: vec![] },
            &tree.children,
            &tree.schema,
        )
        .unwrap();
    }

    buffer
}

// Insert a schema into a module.
fn insert_schema(module: &mut Module, namespace: &schema::Namespace, schema: schema::Schema) {
    let mut iter = namespace.components.iter();

    if let Some(head) = iter.next() {
        if let Some(child) = module.children.get_mut(head) {
            insert_schema(
                child,
                &schema::Namespace {
                    components: iter.cloned().collect(),
                },
                schema,
            );
        } else {
            let mut child = Module {
                children: BTreeMap::new(),
                schema: schema::Schema {
                    imports: BTreeMap::new(),
                    declarations: BTreeMap::new(),
                },
            };

            insert_schema(
                &mut child,
                &schema::Namespace {
                    components: iter.cloned().collect(),
                },
                schema,
            );

            module.children.insert(head.clone(), child);
        }
    } else {
        module.schema = schema;
    }
}

// Write a module, including a trailing line break.
fn write_module<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    name: &Identifier,
    module: &Module,
) -> Result<(), fmt::Error> {
    if indentation == 0 {
        write_indentation(buffer, indentation)?;
        writeln!(buffer, "#[rustfmt::skip]")?;
    }

    write_indentation(buffer, indentation)?;
    write!(buffer, "pub mod ")?;
    write_identifier(buffer, name, Snake, None)?;
    writeln!(buffer, " {{")?;

    let mut new_namespace = namespace.clone();
    new_namespace.components.push(name.clone());

    write_module_contents(
        buffer,
        indentation + 1,
        &new_namespace,
        &module.children,
        &module.schema,
    )?;

    write_indentation(buffer, indentation)?;
    writeln!(buffer, "}}")?;

    Ok(())
}

// Write the contents of a module, including a trailing line break if there was anything to render.
fn write_module_contents<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    children: &BTreeMap<Identifier, Module>,
    schema: &schema::Schema,
) -> Result<(), fmt::Error> {
    let schema_empty = schema.declarations.is_empty();

    for (i, (child_name, child)) in children.iter().enumerate() {
        write_module(buffer, indentation, namespace, child_name, child)?;

        if i < children.len() - 1 || !schema_empty {
            writeln!(buffer)?;
        }
    }

    write_schema(buffer, indentation, namespace, schema)?;

    Ok(())
}

// Write a schema, including a trailing line break if there was anything to render.
#[allow(clippy::too_many_lines)]
fn write_schema<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    schema: &schema::Schema,
) -> Result<(), fmt::Error> {
    // Construct a map from import name to namespace.
    let mut imports = BTreeMap::new();
    for (name, import) in &schema.imports {
        // The unwrap is safe due to [ref:namespace_populated].
        imports.insert(name.clone(), import.namespace.clone().unwrap());
    }

    // Write the declarations.
    let mut iter = schema.declarations.iter().peekable();
    while let Some((name, declaration)) = iter.next() {
        match &declaration.variant {
            schema::DeclarationVariant::Struct(fields) => {
                write_struct(buffer, indentation, &imports, namespace, &name, fields, Out)?;

                writeln!(buffer)?;

                write_struct(buffer, indentation, &imports, namespace, &name, fields, In)?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl ")?;
                write_supers(buffer, indentation)?;
                write!(buffer, "Serialize for ")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(Out)))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const VARINT_ENCODED: bool = false;")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "fn size(&self) -> u64 {{")?;
                write_indentation(buffer, indentation + 2)?;
                if fields.is_empty() {
                    writeln!(buffer, "0")?;
                } else {
                    write_supers(buffer, indentation)?;
                    write!(buffer, "field_size({}, &self.", fields[0].index)?;
                    write_identifier(buffer, &fields[0].name, Snake, None)?;
                    writeln!(buffer, ")")?;

                    for field in fields.iter().skip(1) {
                        write_indentation(buffer, indentation + 3)?;
                        write!(buffer, "+ ")?;
                        write_supers(buffer, indentation)?;
                        write!(buffer, "field_size({}, &self.", field.index)?;
                        write_identifier(buffer, &field.name, Snake, None)?;
                        writeln!(buffer, ")")?;
                    }
                }
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(
                    buffer,
                    "fn serialize(&self, mut writer: impl ::std::io::Write) -> \
                       ::std::io::Result<()> {{",
                )?;
                for field in fields {
                    write_indentation(buffer, indentation + 2)?;
                    write_supers(buffer, indentation)?;
                    write!(
                        buffer,
                        "serialize_field(writer.by_ref(), {}, &self.",
                        field.index,
                    )?;
                    write_identifier(buffer, &field.name, Snake, None)?;
                    writeln!(buffer, ")?;")?;
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "Ok(())")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl ")?;
                write_supers(buffer, indentation)?;
                write!(buffer, "Deserialize for ")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(In)))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(
                    buffer,
                    "fn deserialize(mut reader: impl ::std::io::BufRead) -> \
                       ::std::io::Result<Self>",
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "where")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "Self: Sized,")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "{{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 2)?;
                    write!(buffer, "let mut ")?;
                    write_identifier(buffer, &field.name, Snake, None)?;
                    write!(buffer, ": Option<")?;
                    write_type(buffer, &imports, namespace, &field.r#type, InOrOut(In))?;
                    writeln!(buffer, "> = None;")?;
                }
                if !fields.is_empty() {
                    writeln!(buffer)?;
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "loop {{")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(
                    buffer,
                    "let header = match u64::deserialize(reader.by_ref()) {{",
                )?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "Ok(header) => header,")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "Err(err) => {{")?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(
                    buffer,
                    "if let std::io::ErrorKind::UnexpectedEof = err.kind() {{",
                )?;
                write_indentation(buffer, indentation + 6)?;
                writeln!(buffer, "break;")?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "return Err(err);")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}};")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "let index = header >> 2;")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "let size = match header & 0b11 {{")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "0b00 => {{")?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "let buffer = reader.fill_buf()?;")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "if buffer.is_empty() {{")?;
                write_indentation(buffer, indentation + 6)?;
                writeln!(buffer, "return Err(::std::io::Error::new(")?;
                write_indentation(buffer, indentation + 7)?;
                writeln!(buffer, "::std::io::ErrorKind::UnexpectedEof,")?;
                write_indentation(buffer, indentation + 7)?;
                writeln!(buffer, "\"Error decoding field.\",")?;
                write_indentation(buffer, indentation + 6)?;
                writeln!(buffer, "));")?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 5)?;
                write!(buffer, "u64::from(")?;
                write_supers(buffer, indentation)?;
                writeln!(buffer, "u64_size(buffer[0]))")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "0b01 => 0,")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "0b10 => 8,")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "0b11 => u64::deserialize(reader.by_ref())?,")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "_ => panic!(),")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}};")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(
                    buffer,
                    "let mut sub_reader = ::std::io::Read::take(reader.by_ref(), size);",
                )?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "match index {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "{} => {{", field.index)?;
                    write_indentation(buffer, indentation + 5)?;
                    write_identifier(buffer, &field.name, Snake, None)?;
                    write!(buffer, ".get_or_insert(")?;
                    write_type(buffer, &imports, namespace, &field.r#type, InOrOut(In))?;
                    writeln!(buffer, "::deserialize(sub_reader)?);")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "}}")?;
                }
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "_ => {{")?;
                write_indentation(buffer, indentation + 5)?;
                write_supers(buffer, indentation)?;
                writeln!(buffer, "skip(&mut sub_reader, size as usize)?;")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                if !fields.is_empty() {
                    write_indentation(buffer, indentation + 2)?;
                    write!(buffer, "if ")?;
                    write_identifier(buffer, &fields[0].name, Snake, None)?;
                    write!(buffer, ".is_none()")?;
                    for field in fields.iter().skip(1) {
                        if !field.unstable {
                            write!(buffer, " || ")?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            write!(buffer, ".is_none()")?;
                        }
                    }
                    writeln!(buffer, " {{")?;
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "return Err(::std::io::Error::new(")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "::std::io::ErrorKind::InvalidData,")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "\"Struct missing one or more field(s).\",")?;
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "));")?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                    writeln!(buffer)?;
                }
                write_indentation(buffer, indentation + 2)?;
                write!(buffer, "Ok(")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(In)))?;
                writeln!(buffer, " {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 3)?;
                    write_identifier(buffer, &field.name, Snake, None)?;
                    if !field.unstable {
                        write!(buffer, ": ")?;
                        write_identifier(buffer, &field.name, Snake, None)?;
                        write!(buffer, ".unwrap()")?;
                    }
                    writeln!(buffer, ",")?;
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}})")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl From<")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(Out)))?;
                write!(buffer, "> for ")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(In)))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "fn from(message: ")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(Out)))?;
                writeln!(buffer, ") -> Self {{")?;
                write_indentation(buffer, indentation + 2)?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(In)))?;
                writeln!(buffer, " {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 3)?;
                    write_identifier(buffer, &field.name, Snake, None)?;
                    write!(buffer, ": ")?;
                    if field.unstable {
                        write!(buffer, "Some(")?;
                    }
                    write!(buffer, "message.")?;
                    write_identifier(buffer, &field.name, Snake, None)?;
                    write!(buffer, ".into()")?;
                    if field.unstable {
                        write!(buffer, ")")?;
                    }
                    writeln!(buffer, ",")?;
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;
            }
            schema::DeclarationVariant::Choice(fields) => {
                write_choice(
                    buffer,
                    indentation,
                    &imports,
                    namespace,
                    &name,
                    fields,
                    InOrOut(Out),
                )?;

                writeln!(buffer)?;

                write_choice(
                    buffer,
                    indentation,
                    &imports,
                    namespace,
                    &name,
                    fields,
                    OutStable,
                )?;

                writeln!(buffer)?;

                write_choice(
                    buffer,
                    indentation,
                    &imports,
                    namespace,
                    &name,
                    fields,
                    InOrOut(In),
                )?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl ")?;
                write_supers(buffer, indentation)?;
                write!(buffer, "Serialize for ")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(Out)))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const VARINT_ENCODED: bool = false;")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "fn size(&self) -> u64 {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "match *self {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 3)?;
                    write_identifier(buffer, &name, Pascal, Some(InOrOut(Out)))?;
                    write!(buffer, "::")?;
                    write_identifier(buffer, &field.name, Pascal, None)?;
                    if field.unstable {
                        writeln!(
                            buffer,
                            "(ref payload, ref alternatives, ref fallback) => {{",
                        )?;
                        write_indentation(buffer, indentation + 4)?;
                        write_supers(buffer, indentation)?;
                        writeln!(buffer, "field_size({}, payload)", field.index)?;
                        write_indentation(buffer, indentation + 5)?;
                        writeln!(buffer, "+ alternatives")?;
                        write_indentation(buffer, indentation + 6)?;
                        writeln!(buffer, ".iter()")?;
                        write_indentation(buffer, indentation + 6)?;
                        writeln!(buffer, ".map(|alternative| alternative.size())")?;
                        write_indentation(buffer, indentation + 6)?;
                        writeln!(buffer, ".sum::<u64>()")?;
                        write_indentation(buffer, indentation + 5)?;
                        writeln!(buffer, "+ fallback.size()")?;
                        write_indentation(buffer, indentation + 3)?;
                        writeln!(buffer, "}}")?;
                    } else {
                        write!(buffer, "(ref payload) => ")?;
                        write_supers(buffer, indentation)?;
                        writeln!(buffer, "field_size({}, payload),", field.index)?;
                    }
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(
                    buffer,
                    "fn serialize(&self, mut writer: impl ::std::io::Write) -> \
                       ::std::io::Result<()> {{",
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "match *self {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 3)?;
                    write_identifier(buffer, &name, Pascal, Some(InOrOut(Out)))?;
                    write!(buffer, "::")?;
                    write_identifier(buffer, &field.name, Pascal, None)?;
                    if field.unstable {
                        writeln!(
                            buffer,
                            "(ref payload, ref alternatives, ref fallback) => {{",
                        )?;
                        write_indentation(buffer, indentation + 4)?;
                        write_supers(buffer, indentation)?;
                        writeln!(
                            buffer,
                            "serialize_field(writer.by_ref(), {}, payload)?;",
                            field.index,
                        )?;
                        writeln!(buffer)?;
                        write_indentation(buffer, indentation + 4)?;
                        writeln!(buffer, "for alternative in alternatives {{")?;
                        write_indentation(buffer, indentation + 5)?;
                        writeln!(buffer, "alternative.serialize(writer.by_ref())?;")?;
                        write_indentation(buffer, indentation + 4)?;
                        writeln!(buffer, "}}")?;
                        writeln!(buffer)?;
                        write_indentation(buffer, indentation + 4)?;
                        writeln!(buffer, "fallback.serialize(writer)")?;
                        write_indentation(buffer, indentation + 3)?;
                        writeln!(buffer, "}}")?;
                    } else {
                        write!(buffer, "(ref payload) => ")?;
                        write_supers(buffer, indentation)?;
                        writeln!(buffer, "serialize_field(writer, {}, payload),", field.index)?;
                    }
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl ")?;
                write_supers(buffer, indentation)?;
                write!(buffer, "Serialize for ")?;
                write_identifier(buffer, &name, Pascal, Some(OutStable))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const VARINT_ENCODED: bool = false;")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "fn size(&self) -> u64 {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "match *self {{")?;
                for field in fields {
                    if !field.unstable {
                        write_indentation(buffer, indentation + 3)?;
                        write_identifier(buffer, &name, Pascal, Some(OutStable))?;
                        write!(buffer, "::")?;
                        write_identifier(buffer, &field.name, Pascal, None)?;
                        write!(buffer, "(ref payload) => ")?;
                        write_supers(buffer, indentation)?;
                        writeln!(buffer, "field_size({}, payload),", field.index)?;
                    }
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(
                    buffer,
                    "fn serialize(&self, writer: impl ::std::io::Write) -> \
                       ::std::io::Result<()> {{",
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "match *self {{")?;
                for field in fields {
                    if !field.unstable {
                        write_indentation(buffer, indentation + 3)?;
                        write_identifier(buffer, &name, Pascal, Some(OutStable))?;
                        write!(buffer, "::")?;
                        write_identifier(buffer, &field.name, Pascal, None)?;
                        write!(buffer, "(ref payload) => ")?;
                        write_supers(buffer, indentation)?;
                        writeln!(buffer, "serialize_field(writer, {}, payload),", field.index)?;
                    }
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl ")?;
                write_supers(buffer, indentation)?;
                write!(buffer, "Deserialize for ")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(In)))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(
                    buffer,
                    "fn deserialize(mut reader: impl ::std::io::BufRead) -> \
                       ::std::io::Result<Self>",
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "where")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "Self: Sized,")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "loop {{")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "let header = u64::deserialize(reader.by_ref())?;")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "let index = header >> 2;")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "let size = match header & 0b11 {{")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "0b00 => {{")?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "let buffer = reader.fill_buf()?;")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "if buffer.is_empty() {{")?;
                write_indentation(buffer, indentation + 6)?;
                writeln!(buffer, "return Err(::std::io::Error::new(")?;
                write_indentation(buffer, indentation + 7)?;
                writeln!(buffer, "::std::io::ErrorKind::UnexpectedEof,")?;
                write_indentation(buffer, indentation + 7)?;
                writeln!(buffer, "\"Error decoding field.\",")?;
                write_indentation(buffer, indentation + 6)?;
                writeln!(buffer, "));")?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 5)?;
                write!(buffer, "u64::from(")?;
                write_supers(buffer, indentation)?;
                writeln!(buffer, "u64_size(buffer[0]))")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "0b01 => 0,")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "0b10 => 8,")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "0b11 => u64::deserialize(reader.by_ref())?,")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "_ => panic!(),")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}};")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(
                    buffer,
                    "let mut sub_reader = ::std::io::Read::take(reader.by_ref(), size);",
                )?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "match index {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "{} => {{", field.index)?;
                    write_indentation(buffer, indentation + 5)?;
                    write!(buffer, "return Ok(")?;
                    write_identifier(buffer, &name, Pascal, Some(InOrOut(In)))?;
                    write!(buffer, "::")?;
                    write_identifier(buffer, &field.name, Pascal, None)?;
                    write!(buffer, "(")?;
                    write_type(buffer, &imports, namespace, &field.r#type, InOrOut(In))?;
                    writeln!(buffer, "::deserialize(sub_reader)?));")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "}}")?;
                }
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "_ => {{")?;
                write_indentation(buffer, indentation + 5)?;
                write_supers(buffer, indentation)?;
                writeln!(buffer, "skip(&mut sub_reader, size as usize)?;")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl From<")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(Out)))?;
                write!(buffer, "> for ")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(In)))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "fn from(message: ")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(Out)))?;
                writeln!(buffer, ") -> Self {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "match message {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 3)?;
                    write_identifier(buffer, &name, Pascal, Some(InOrOut(Out)))?;
                    write!(buffer, "::")?;
                    write_identifier(buffer, &field.name, Pascal, None)?;
                    write!(buffer, "(payload")?;
                    if field.unstable {
                        write!(buffer, ", _, _")?;
                    }
                    write!(buffer, ") => ")?;
                    write_identifier(buffer, &name, Pascal, Some(InOrOut(In)))?;
                    write!(buffer, "::")?;
                    write_identifier(buffer, &field.name, Pascal, None)?;
                    writeln!(buffer, "(payload.into()),")?;
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;
            }
        }

        if iter.peek().is_some() {
            writeln!(buffer)?;
        }
    }

    Ok(())
}

// Write a struct, including a trailing line break.
fn write_struct<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    name: &Identifier,
    fields: &[schema::Field],
    flavor: StructFlavor,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    writeln!(buffer, "#[derive({})]", TRAITS_TO_DERIVE.join(", "))?;
    write_indentation(buffer, indentation)?;
    write!(buffer, "pub struct ")?;
    write_identifier(buffer, &name, Pascal, Some(InOrOut(flavor)))?;
    writeln!(buffer, " {{")?;

    for field in fields {
        write_indentation(buffer, indentation + 1)?;
        write!(buffer, "pub ")?;
        write_identifier(buffer, &field.name, Snake, None)?;
        write!(buffer, ": ")?;
        if field.unstable && flavor == In {
            write!(buffer, "Option<")?;
        }
        write_type(buffer, imports, namespace, &field.r#type, InOrOut(flavor))?;
        if field.unstable && flavor == In {
            write!(buffer, ">")?;
        }
        writeln!(buffer, ",")?;
    }

    write_indentation(buffer, indentation)?;
    writeln!(buffer, "}}")?;

    Ok(())
}

// Write a choice, including a trailing line break.
fn write_choice<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    name: &Identifier,
    fields: &[schema::Field],
    flavor: ChoiceFlavor,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    writeln!(buffer, "#[derive({})]", TRAITS_TO_DERIVE.join(", "))?;
    write_indentation(buffer, indentation)?;
    write!(buffer, "pub enum ")?;
    write_identifier(buffer, &name, Pascal, Some(flavor))?;
    writeln!(buffer, " {{")?;

    for field in fields {
        if !(flavor == OutStable && field.unstable) {
            let flavor = match flavor {
                ChoiceFlavor::InOrOut(flavor) => flavor,
                ChoiceFlavor::OutStable => Out,
            };
            write_indentation(buffer, indentation + 1)?;
            write_identifier(buffer, &field.name, Pascal, None)?;
            write!(buffer, "(")?;
            write_type(buffer, imports, namespace, &field.r#type, InOrOut(flavor))?;
            if flavor == Out && field.unstable {
                write!(buffer, ", Vec<")?;
                write_identifier(buffer, &name, Pascal, Some(InOrOut(Out)))?;
                write!(buffer, ">, ")?;
                write_identifier(buffer, &name, Pascal, Some(OutStable))?;
            }
            writeln!(buffer, "),")?;
        }
    }

    write_indentation(buffer, indentation)?;
    writeln!(buffer, "}}")?;

    Ok(())
}

// Write a type.
fn write_type<T: Write>(
    buffer: &mut T,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    r#type: &schema::Type,
    flavor: ChoiceFlavor,
) -> Result<(), fmt::Error> {
    match &r#type.variant {
        schema::TypeVariant::Boolean => {
            write!(buffer, "bool")?;
        }
        schema::TypeVariant::Float64 => {
            write!(buffer, "f64")?;
        }
        schema::TypeVariant::Unsigned64 => {
            write!(buffer, "u64")?;
        }
        schema::TypeVariant::Custom(import, name) => {
            let type_namespace = schema::Namespace {
                components: import.as_ref().map_or_else(
                    || namespace.components.clone(),
                    |import| imports[import].components.clone(),
                ),
            };

            let (relative_type_namespace, ancestors) =
                relativize_namespace(&type_namespace, namespace);

            write_supers(buffer, ancestors)?;

            for component in relative_type_namespace.components {
                write_identifier(buffer, &component, Snake, None)?;
                write!(buffer, "::")?;
            }

            write_identifier(buffer, &name, Pascal, Some(flavor))?;
        }
    }

    Ok(())
}

// Write an identifier with an optional flavor suffix in a way that Rust will be happy with.
fn write_identifier<T: Write>(
    buffer: &mut T,
    identifier: &Identifier,
    case: CaseConvention,
    suffix: Option<ChoiceFlavor>,
) -> Result<(), fmt::Error> {
    let identifier_with_suffix = suffix.map_or_else(
        || identifier.clone(),
        |suffix| {
            identifier.join(
                &match suffix {
                    ChoiceFlavor::InOrOut(StructFlavor::In) => "In",
                    ChoiceFlavor::InOrOut(StructFlavor::Out) => "Out",
                    ChoiceFlavor::OutStable => "OutStable",
                }
                .into(),
            )
        },
    );

    let converted_identifier = match case {
        CaseConvention::Pascal => identifier_with_suffix.pascal_case(),
        CaseConvention::Snake => identifier_with_suffix.snake_case(),
    };

    if !converted_identifier.starts_with("r#")
        && RUST_KEYWORDS
            .iter()
            .any(|keyword| converted_identifier == *keyword)
    {
        write!(buffer, "r#")?;
    }

    write!(buffer, "{}", converted_identifier)?;

    Ok(())
}

// Write the given level of indentation.
fn write_indentation<T: Write>(buffer: &mut T, indentation: usize) -> Result<(), fmt::Error> {
    for _ in 0..indentation {
        write!(buffer, "{}", INDENTATION)?;
    }

    Ok(())
}

// Write a series of `super::super::...`.
fn write_supers<T: Write>(buffer: &mut T, count: usize) -> Result<(), fmt::Error> {
    for _ in 0..count {
        write!(buffer, "super::")?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use crate::{
        generate_rust::generate, parser::parse, schema, tokenizer::tokenize, validator::validate,
    };
    use std::{collections::BTreeMap, fs::read_to_string, path::Path};

    #[allow(clippy::too_many_lines)]
    #[test]
    fn generate_example() {
        let unit_namespace = schema::Namespace {
            components: vec!["basic".into(), "unit".into()],
        };
        let unit_path = Path::new("integration-tests/types/basic/unit.t").to_owned();
        let unit_contents = read_to_string(&unit_path).unwrap();

        let void_namespace = schema::Namespace {
            components: vec!["basic".into(), "void".into()],
        };
        let void_path = Path::new("integration-tests/types/basic/void.t").to_owned();
        let void_contents = read_to_string(&void_path).unwrap();

        let main_namespace = schema::Namespace {
            components: vec!["main".into()],
        };
        let main_path = Path::new("integration-tests/types/main.t").to_owned();
        let main_contents = read_to_string(&main_path).unwrap();

        let unit_tokens = tokenize(&unit_path, &unit_contents).unwrap();
        let unit_schema = parse(&unit_path, &unit_contents, &unit_tokens).unwrap();

        let void_tokens = tokenize(&void_path, &void_contents).unwrap();
        let void_schema = parse(&void_path, &void_contents, &void_tokens).unwrap();

        let main_tokens = tokenize(&main_path, &main_contents).unwrap();
        let mut main_schema = parse(&main_path, &main_contents, &main_tokens).unwrap();
        main_schema
            .imports
            .get_mut(&"unit".into())
            .unwrap()
            .namespace = Some(unit_namespace.clone());
        main_schema
            .imports
            .get_mut(&"void".into())
            .unwrap()
            .namespace = Some(void_namespace.clone());

        let mut schemas = BTreeMap::new();
        schemas.insert(unit_namespace, (unit_schema, unit_path, unit_contents));
        schemas.insert(void_namespace, (void_schema, void_path, void_contents));
        schemas.insert(main_namespace, (main_schema, main_path, main_contents));
        validate(&schemas).unwrap();

        assert_eq!(
            generate("0.0.0", schemas),
            "\
// This file was automatically generated by Typical 0.0.0.
// Visit https://github.com/stepchowfun/typical for more information.

#![allow(clippy::all, clippy::pedantic, clippy::nursery, warnings)]

#[rustfmt::skip]
use std::io::{self, BufRead, Error, ErrorKind, Write};

#[rustfmt::skip]
pub trait Serialize {
    const VARINT_ENCODED: bool;

    fn size(&self) -> u64;

    fn serialize(&self, writer: impl Write) -> io::Result<()>;
}

#[rustfmt::skip]
pub trait Deserialize {
    fn deserialize(reader: impl BufRead) -> io::Result<Self>
    where
        Self: Sized;
}

#[rustfmt::skip]
impl Serialize for bool {
    const VARINT_ENCODED: bool = true;

    fn size(&self) -> u64 {
        1
    }

    fn serialize(&self, writer: impl Write) -> io::Result<()> {
        (*self as u64).serialize(writer)
    }
}

#[rustfmt::skip]
impl Deserialize for bool {
    fn deserialize(reader: impl BufRead) -> io::Result<Self>
    where
        Self: Sized,
    {
        match u64::deserialize(reader)? {
            0 => Ok(false),
            1 => Ok(true),
            _ => Err(Error::new(
                ErrorKind::InvalidData,
                \"Error decoding Boolean.\",
            )),
        }
    }
}

#[rustfmt::skip]
impl Serialize for u64 {
    const VARINT_ENCODED: bool = true;

    fn size(&self) -> u64 {
        let mut size = 1_u64;
        let mut upper_bound_exclusive = 0_u64;

        while size < 9_u64 {
            upper_bound_exclusive += 1_u64 << (size * 7_u64);

            if *self < upper_bound_exclusive {
                break;
            }

            size += 1_u64;
        }

        size
    }

    fn serialize(&self, mut writer: impl Write) -> io::Result<()> {
        let size = self.size();
        let size_minus_one = size - 1;

        let mut x = *self;
        for i in 1..size {
            x -= 1_u64 << (i * 7);
        }

        writer.write_all(&[((x << size) | (1_u64 << size_minus_one)) as u8])?;
        x >>= 8_u64.saturating_sub(size);

        for _ in 0..size_minus_one {
            writer.write_all(&[x as u8])?;
            x >>= 8;
        }

        Ok(())
    }
}

#[rustfmt::skip]
impl Deserialize for u64 {
    fn deserialize(mut reader: impl BufRead) -> io::Result<Self>
    where
        Self: Sized,
    {
        let mut buffer = [0; 9];
        reader.read_exact(&mut buffer[0..1])?;
        let first_byte = buffer[0];
        let size = u64_size(first_byte) as usize;

        reader.read_exact(&mut buffer[1..size])?;

        let mut x = u64::from(first_byte) >> size;
        let mut bits_read = 8_usize.saturating_sub(size);

        for byte in buffer.iter().skip(1) {
            x |= u64::from(*byte) << bits_read;
            bits_read += 8;
        }

        for i in 1..size {
            x = x.checked_add(1_u64 << (i * 7)).ok_or_else(|| {
                Error::new(ErrorKind::InvalidData, \"Error decoding 64-bit integer.\")
            })?;
        }

        Ok(x)
    }
}

#[rustfmt::skip]
impl Serialize for f64 {
    const VARINT_ENCODED: bool = false;

    fn size(&self) -> u64 {
        8
    }

    fn serialize(&self, mut writer: impl Write) -> io::Result<()> {
        writer.write_all(&self.to_le_bytes())
    }
}

#[rustfmt::skip]
impl Deserialize for f64 {
    fn deserialize(mut reader: impl BufRead) -> io::Result<Self>
    where
        Self: Sized,
    {
        let mut buffer = [0; 8];
        reader.read_exact(&mut buffer)?;
        Ok(f64::from_le_bytes(buffer))
    }
}

#[rustfmt::skip]
fn u64_size(first_byte: u8) -> u32 {
    first_byte.trailing_zeros() + 1
}

#[rustfmt::skip]
fn field_size<T: Serialize>(tag: u64, value: &T) -> u64 {
    if T::VARINT_ENCODED {
        ((tag << 2) | 0b00).size() + value.size()
    } else {
        (match value.size() {
            0 => ((tag << 2) | 0b01).size(),
            8 => ((tag << 2) | 0b10).size(),
            size => ((tag << 2) | 0b11).size() + size.size(),
        }) + value.size()
    }
}

#[rustfmt::skip]
fn skip(mut reader: impl BufRead, mut amount: usize) -> io::Result<()> {
    while amount > 0 {
        let buffer = ::std::io::BufRead::fill_buf(reader.by_ref())?;
        let num_bytes_to_consume = std::cmp::min(buffer.len(), amount);
        ::std::io::BufRead::consume(reader.by_ref(), num_bytes_to_consume);
        amount -= num_bytes_to_consume;
    }

    Ok(())
}

#[rustfmt::skip]
fn serialize_field<T: Serialize>(mut writer: impl Write, tag: u64, value: &T) -> io::Result<()> {
    if T::VARINT_ENCODED {
        ((tag << 2) | 0b00).serialize(writer.by_ref())?;
    } else {
        match value.size() {
            0 => {
                ((tag << 2) | 0b01).serialize(writer.by_ref())?;
            }
            8 => {
                ((tag << 2) | 0b10).serialize(writer.by_ref())?;
            }
            size => {
                ((tag << 2) | 0b11).serialize(writer.by_ref())?;
                size.serialize(writer.by_ref())?;
            }
        }
    }

    value.serialize(writer)
}

#[rustfmt::skip]
pub mod basic {
    pub mod unit {
        #[derive(Clone, Debug)]
        pub struct UnitOut {
        }

        #[derive(Clone, Debug)]
        pub struct UnitIn {
        }

        impl super::super::Serialize for UnitOut {
            const VARINT_ENCODED: bool = false;

            fn size(&self) -> u64 {
                0
            }

            fn serialize(&self, mut writer: impl ::std::io::Write) -> ::std::io::Result<()> {
                Ok(())
            }
        }

        impl super::super::Deserialize for UnitIn {
            fn deserialize(mut reader: impl ::std::io::BufRead) -> ::std::io::Result<Self>
            where
                Self: Sized,
            {
                loop {
                    let header = match u64::deserialize(reader.by_ref()) {
                        Ok(header) => header,
                        Err(err) => {
                            if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                                break;
                            }

                            return Err(err);
                        }
                    };

                    let index = header >> 2;

                    let size = match header & 0b11 {
                        0b00 => {
                            let buffer = reader.fill_buf()?;

                            if buffer.is_empty() {
                                return Err(::std::io::Error::new(
                                    ::std::io::ErrorKind::UnexpectedEof,
                                    \"Error decoding field.\",
                                ));
                            }

                            u64::from(super::super::u64_size(buffer[0]))
                        }
                        0b01 => 0,
                        0b10 => 8,
                        0b11 => u64::deserialize(reader.by_ref())?,
                        _ => panic!(),
                    };

                    let mut sub_reader = ::std::io::Read::take(reader.by_ref(), size);

                    match index {
                        _ => {
                            super::super::skip(&mut sub_reader, size as usize)?;
                        }
                    }
                }

                Ok(UnitIn {
                })
            }
        }

        impl From<UnitOut> for UnitIn {
            fn from(message: UnitOut) -> Self {
                UnitIn {
                }
            }
        }
    }

    pub mod void {
        #[derive(Clone, Debug)]
        pub enum VoidOut {
        }

        #[derive(Clone, Debug)]
        pub enum VoidOutStable {
        }

        #[derive(Clone, Debug)]
        pub enum VoidIn {
        }

        impl super::super::Serialize for VoidOut {
            const VARINT_ENCODED: bool = false;

            fn size(&self) -> u64 {
                match *self {
                }
            }

            fn serialize(&self, mut writer: impl ::std::io::Write) -> ::std::io::Result<()> {
                match *self {
                }
            }
        }

        impl super::super::Serialize for VoidOutStable {
            const VARINT_ENCODED: bool = false;

            fn size(&self) -> u64 {
                match *self {
                }
            }

            fn serialize(&self, writer: impl ::std::io::Write) -> ::std::io::Result<()> {
                match *self {
                }
            }
        }

        impl super::super::Deserialize for VoidIn {
            fn deserialize(mut reader: impl ::std::io::BufRead) -> ::std::io::Result<Self>
            where
                Self: Sized,
            {
                loop {
                    let header = u64::deserialize(reader.by_ref())?;

                    let index = header >> 2;

                    let size = match header & 0b11 {
                        0b00 => {
                            let buffer = reader.fill_buf()?;

                            if buffer.is_empty() {
                                return Err(::std::io::Error::new(
                                    ::std::io::ErrorKind::UnexpectedEof,
                                    \"Error decoding field.\",
                                ));
                            }

                            u64::from(super::super::u64_size(buffer[0]))
                        }
                        0b01 => 0,
                        0b10 => 8,
                        0b11 => u64::deserialize(reader.by_ref())?,
                        _ => panic!(),
                    };

                    let mut sub_reader = ::std::io::Read::take(reader.by_ref(), size);

                    match index {
                        _ => {
                            super::super::skip(&mut sub_reader, size as usize)?;
                        }
                    }
                }
            }
        }

        impl From<VoidOut> for VoidIn {
            fn from(message: VoidOut) -> Self {
                match message {
                }
            }
        }
    }
}

#[rustfmt::skip]
pub mod main {
    #[derive(Clone, Debug)]
    pub enum BarOut {
        X(bool),
        Y(f64, Vec<BarOut>, BarOutStable),
        Z(super::basic::void::VoidOut),
        W(super::basic::void::VoidOut, Vec<BarOut>, BarOutStable),
        S(super::basic::unit::UnitOut),
        T(super::basic::unit::UnitOut, Vec<BarOut>, BarOutStable),
    }

    #[derive(Clone, Debug)]
    pub enum BarOutStable {
        X(bool),
        Z(super::basic::void::VoidOut),
        S(super::basic::unit::UnitOut),
    }

    #[derive(Clone, Debug)]
    pub enum BarIn {
        X(bool),
        Y(f64),
        Z(super::basic::void::VoidIn),
        W(super::basic::void::VoidIn),
        S(super::basic::unit::UnitIn),
        T(super::basic::unit::UnitIn),
    }

    impl super::Serialize for BarOut {
        const VARINT_ENCODED: bool = false;

        fn size(&self) -> u64 {
            match *self {
                BarOut::X(ref payload) => super::field_size(0, payload),
                BarOut::Y(ref payload, ref alternatives, ref fallback) => {
                    super::field_size(1, payload)
                        + alternatives
                            .iter()
                            .map(|alternative| alternative.size())
                            .sum::<u64>()
                        + fallback.size()
                }
                BarOut::Z(ref payload) => super::field_size(2, payload),
                BarOut::W(ref payload, ref alternatives, ref fallback) => {
                    super::field_size(3, payload)
                        + alternatives
                            .iter()
                            .map(|alternative| alternative.size())
                            .sum::<u64>()
                        + fallback.size()
                }
                BarOut::S(ref payload) => super::field_size(4, payload),
                BarOut::T(ref payload, ref alternatives, ref fallback) => {
                    super::field_size(5, payload)
                        + alternatives
                            .iter()
                            .map(|alternative| alternative.size())
                            .sum::<u64>()
                        + fallback.size()
                }
            }
        }

        fn serialize(&self, mut writer: impl ::std::io::Write) -> ::std::io::Result<()> {
            match *self {
                BarOut::X(ref payload) => super::serialize_field(writer, 0, payload),
                BarOut::Y(ref payload, ref alternatives, ref fallback) => {
                    super::serialize_field(writer.by_ref(), 1, payload)?;

                    for alternative in alternatives {
                        alternative.serialize(writer.by_ref())?;
                    }

                    fallback.serialize(writer)
                }
                BarOut::Z(ref payload) => super::serialize_field(writer, 2, payload),
                BarOut::W(ref payload, ref alternatives, ref fallback) => {
                    super::serialize_field(writer.by_ref(), 3, payload)?;

                    for alternative in alternatives {
                        alternative.serialize(writer.by_ref())?;
                    }

                    fallback.serialize(writer)
                }
                BarOut::S(ref payload) => super::serialize_field(writer, 4, payload),
                BarOut::T(ref payload, ref alternatives, ref fallback) => {
                    super::serialize_field(writer.by_ref(), 5, payload)?;

                    for alternative in alternatives {
                        alternative.serialize(writer.by_ref())?;
                    }

                    fallback.serialize(writer)
                }
            }
        }
    }

    impl super::Serialize for BarOutStable {
        const VARINT_ENCODED: bool = false;

        fn size(&self) -> u64 {
            match *self {
                BarOutStable::X(ref payload) => super::field_size(0, payload),
                BarOutStable::Z(ref payload) => super::field_size(2, payload),
                BarOutStable::S(ref payload) => super::field_size(4, payload),
            }
        }

        fn serialize(&self, writer: impl ::std::io::Write) -> ::std::io::Result<()> {
            match *self {
                BarOutStable::X(ref payload) => super::serialize_field(writer, 0, payload),
                BarOutStable::Z(ref payload) => super::serialize_field(writer, 2, payload),
                BarOutStable::S(ref payload) => super::serialize_field(writer, 4, payload),
            }
        }
    }

    impl super::Deserialize for BarIn {
        fn deserialize(mut reader: impl ::std::io::BufRead) -> ::std::io::Result<Self>
        where
            Self: Sized,
        {
            loop {
                let header = u64::deserialize(reader.by_ref())?;

                let index = header >> 2;

                let size = match header & 0b11 {
                    0b00 => {
                        let buffer = reader.fill_buf()?;

                        if buffer.is_empty() {
                            return Err(::std::io::Error::new(
                                ::std::io::ErrorKind::UnexpectedEof,
                                \"Error decoding field.\",
                            ));
                        }

                        u64::from(super::u64_size(buffer[0]))
                    }
                    0b01 => 0,
                    0b10 => 8,
                    0b11 => u64::deserialize(reader.by_ref())?,
                    _ => panic!(),
                };

                let mut sub_reader = ::std::io::Read::take(reader.by_ref(), size);

                match index {
                    0 => {
                        return Ok(BarIn::X(bool::deserialize(sub_reader)?));
                    }
                    1 => {
                        return Ok(BarIn::Y(f64::deserialize(sub_reader)?));
                    }
                    2 => {
                        return Ok(BarIn::Z(super::basic::void::VoidIn::deserialize(sub_reader)?));
                    }
                    3 => {
                        return Ok(BarIn::W(super::basic::void::VoidIn::deserialize(sub_reader)?));
                    }
                    4 => {
                        return Ok(BarIn::S(super::basic::unit::UnitIn::deserialize(sub_reader)?));
                    }
                    5 => {
                        return Ok(BarIn::T(super::basic::unit::UnitIn::deserialize(sub_reader)?));
                    }
                    _ => {
                        super::skip(&mut sub_reader, size as usize)?;
                    }
                }
            }
        }
    }

    impl From<BarOut> for BarIn {
        fn from(message: BarOut) -> Self {
            match message {
                BarOut::X(payload) => BarIn::X(payload.into()),
                BarOut::Y(payload, _, _) => BarIn::Y(payload.into()),
                BarOut::Z(payload) => BarIn::Z(payload.into()),
                BarOut::W(payload, _, _) => BarIn::W(payload.into()),
                BarOut::S(payload) => BarIn::S(payload.into()),
                BarOut::T(payload, _, _) => BarIn::T(payload.into()),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct BazOut {
        pub x: bool,
        pub y: u64,
        pub z: f64,
    }

    #[derive(Clone, Debug)]
    pub struct BazIn {
        pub x: bool,
        pub y: Option<u64>,
        pub z: f64,
    }

    impl super::Serialize for BazOut {
        const VARINT_ENCODED: bool = false;

        fn size(&self) -> u64 {
            super::field_size(0, &self.x)
                + super::field_size(1, &self.y)
                + super::field_size(2, &self.z)
        }

        fn serialize(&self, mut writer: impl ::std::io::Write) -> ::std::io::Result<()> {
            super::serialize_field(writer.by_ref(), 0, &self.x)?;
            super::serialize_field(writer.by_ref(), 1, &self.y)?;
            super::serialize_field(writer.by_ref(), 2, &self.z)?;
            Ok(())
        }
    }

    impl super::Deserialize for BazIn {
        fn deserialize(mut reader: impl ::std::io::BufRead) -> ::std::io::Result<Self>
        where
            Self: Sized,
        {
            let mut x: Option<bool> = None;
            let mut y: Option<u64> = None;
            let mut z: Option<f64> = None;

            loop {
                let header = match u64::deserialize(reader.by_ref()) {
                    Ok(header) => header,
                    Err(err) => {
                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                            break;
                        }

                        return Err(err);
                    }
                };

                let index = header >> 2;

                let size = match header & 0b11 {
                    0b00 => {
                        let buffer = reader.fill_buf()?;

                        if buffer.is_empty() {
                            return Err(::std::io::Error::new(
                                ::std::io::ErrorKind::UnexpectedEof,
                                \"Error decoding field.\",
                            ));
                        }

                        u64::from(super::u64_size(buffer[0]))
                    }
                    0b01 => 0,
                    0b10 => 8,
                    0b11 => u64::deserialize(reader.by_ref())?,
                    _ => panic!(),
                };

                let mut sub_reader = ::std::io::Read::take(reader.by_ref(), size);

                match index {
                    0 => {
                        x.get_or_insert(bool::deserialize(sub_reader)?);
                    }
                    1 => {
                        y.get_or_insert(u64::deserialize(sub_reader)?);
                    }
                    2 => {
                        z.get_or_insert(f64::deserialize(sub_reader)?);
                    }
                    _ => {
                        super::skip(&mut sub_reader, size as usize)?;
                    }
                }
            }

            if x.is_none() || z.is_none() {
                return Err(::std::io::Error::new(
                    ::std::io::ErrorKind::InvalidData,
                    \"Struct missing one or more field(s).\",
                ));
            }

            Ok(BazIn {
                x: x.unwrap(),
                y,
                z: z.unwrap(),
            })
        }
    }

    impl From<BazOut> for BazIn {
        fn from(message: BazOut) -> Self {
            BazIn {
                x: message.x.into(),
                y: Some(message.y.into()),
                z: message.z.into(),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct FooOut {
        pub x: bool,
        pub y: bool,
        pub z: super::basic::void::VoidOut,
        pub w: super::basic::void::VoidOut,
        pub s: super::basic::unit::UnitOut,
        pub t: super::basic::unit::UnitOut,
    }

    #[derive(Clone, Debug)]
    pub struct FooIn {
        pub x: bool,
        pub y: Option<bool>,
        pub z: super::basic::void::VoidIn,
        pub w: Option<super::basic::void::VoidIn>,
        pub s: super::basic::unit::UnitIn,
        pub t: Option<super::basic::unit::UnitIn>,
    }

    impl super::Serialize for FooOut {
        const VARINT_ENCODED: bool = false;

        fn size(&self) -> u64 {
            super::field_size(0, &self.x)
                + super::field_size(1, &self.y)
                + super::field_size(2, &self.z)
                + super::field_size(3, &self.w)
                + super::field_size(4, &self.s)
                + super::field_size(5, &self.t)
        }

        fn serialize(&self, mut writer: impl ::std::io::Write) -> ::std::io::Result<()> {
            super::serialize_field(writer.by_ref(), 0, &self.x)?;
            super::serialize_field(writer.by_ref(), 1, &self.y)?;
            super::serialize_field(writer.by_ref(), 2, &self.z)?;
            super::serialize_field(writer.by_ref(), 3, &self.w)?;
            super::serialize_field(writer.by_ref(), 4, &self.s)?;
            super::serialize_field(writer.by_ref(), 5, &self.t)?;
            Ok(())
        }
    }

    impl super::Deserialize for FooIn {
        fn deserialize(mut reader: impl ::std::io::BufRead) -> ::std::io::Result<Self>
        where
            Self: Sized,
        {
            let mut x: Option<bool> = None;
            let mut y: Option<bool> = None;
            let mut z: Option<super::basic::void::VoidIn> = None;
            let mut w: Option<super::basic::void::VoidIn> = None;
            let mut s: Option<super::basic::unit::UnitIn> = None;
            let mut t: Option<super::basic::unit::UnitIn> = None;

            loop {
                let header = match u64::deserialize(reader.by_ref()) {
                    Ok(header) => header,
                    Err(err) => {
                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                            break;
                        }

                        return Err(err);
                    }
                };

                let index = header >> 2;

                let size = match header & 0b11 {
                    0b00 => {
                        let buffer = reader.fill_buf()?;

                        if buffer.is_empty() {
                            return Err(::std::io::Error::new(
                                ::std::io::ErrorKind::UnexpectedEof,
                                \"Error decoding field.\",
                            ));
                        }

                        u64::from(super::u64_size(buffer[0]))
                    }
                    0b01 => 0,
                    0b10 => 8,
                    0b11 => u64::deserialize(reader.by_ref())?,
                    _ => panic!(),
                };

                let mut sub_reader = ::std::io::Read::take(reader.by_ref(), size);

                match index {
                    0 => {
                        x.get_or_insert(bool::deserialize(sub_reader)?);
                    }
                    1 => {
                        y.get_or_insert(bool::deserialize(sub_reader)?);
                    }
                    2 => {
                        z.get_or_insert(super::basic::void::VoidIn::deserialize(sub_reader)?);
                    }
                    3 => {
                        w.get_or_insert(super::basic::void::VoidIn::deserialize(sub_reader)?);
                    }
                    4 => {
                        s.get_or_insert(super::basic::unit::UnitIn::deserialize(sub_reader)?);
                    }
                    5 => {
                        t.get_or_insert(super::basic::unit::UnitIn::deserialize(sub_reader)?);
                    }
                    _ => {
                        super::skip(&mut sub_reader, size as usize)?;
                    }
                }
            }

            if x.is_none() || z.is_none() || s.is_none() {
                return Err(::std::io::Error::new(
                    ::std::io::ErrorKind::InvalidData,
                    \"Struct missing one or more field(s).\",
                ));
            }

            Ok(FooIn {
                x: x.unwrap(),
                y,
                z: z.unwrap(),
                w,
                s: s.unwrap(),
                t,
            })
        }
    }

    impl From<FooOut> for FooIn {
        fn from(message: FooOut) -> Self {
            FooIn {
                x: message.x.into(),
                y: Some(message.y.into()),
                z: message.z.into(),
                w: Some(message.w.into()),
                s: message.s.into(),
                t: Some(message.t.into()),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub struct FooAndBarOut {
        pub foo: FooOut,
        pub bar: BarOut,
    }

    #[derive(Clone, Debug)]
    pub struct FooAndBarIn {
        pub foo: FooIn,
        pub bar: BarIn,
    }

    impl super::Serialize for FooAndBarOut {
        const VARINT_ENCODED: bool = false;

        fn size(&self) -> u64 {
            super::field_size(0, &self.foo)
                + super::field_size(1, &self.bar)
        }

        fn serialize(&self, mut writer: impl ::std::io::Write) -> ::std::io::Result<()> {
            super::serialize_field(writer.by_ref(), 0, &self.foo)?;
            super::serialize_field(writer.by_ref(), 1, &self.bar)?;
            Ok(())
        }
    }

    impl super::Deserialize for FooAndBarIn {
        fn deserialize(mut reader: impl ::std::io::BufRead) -> ::std::io::Result<Self>
        where
            Self: Sized,
        {
            let mut foo: Option<FooIn> = None;
            let mut bar: Option<BarIn> = None;

            loop {
                let header = match u64::deserialize(reader.by_ref()) {
                    Ok(header) => header,
                    Err(err) => {
                        if let std::io::ErrorKind::UnexpectedEof = err.kind() {
                            break;
                        }

                        return Err(err);
                    }
                };

                let index = header >> 2;

                let size = match header & 0b11 {
                    0b00 => {
                        let buffer = reader.fill_buf()?;

                        if buffer.is_empty() {
                            return Err(::std::io::Error::new(
                                ::std::io::ErrorKind::UnexpectedEof,
                                \"Error decoding field.\",
                            ));
                        }

                        u64::from(super::u64_size(buffer[0]))
                    }
                    0b01 => 0,
                    0b10 => 8,
                    0b11 => u64::deserialize(reader.by_ref())?,
                    _ => panic!(),
                };

                let mut sub_reader = ::std::io::Read::take(reader.by_ref(), size);

                match index {
                    0 => {
                        foo.get_or_insert(FooIn::deserialize(sub_reader)?);
                    }
                    1 => {
                        bar.get_or_insert(BarIn::deserialize(sub_reader)?);
                    }
                    _ => {
                        super::skip(&mut sub_reader, size as usize)?;
                    }
                }
            }

            if foo.is_none() || bar.is_none() {
                return Err(::std::io::Error::new(
                    ::std::io::ErrorKind::InvalidData,
                    \"Struct missing one or more field(s).\",
                ));
            }

            Ok(FooAndBarIn {
                foo: foo.unwrap(),
                bar: bar.unwrap(),
            })
        }
    }

    impl From<FooAndBarOut> for FooAndBarIn {
        fn from(message: FooAndBarOut) -> Self {
            FooAndBarIn {
                foo: message.foo.into(),
                bar: message.bar.into(),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub enum FooOrBarOut {
        Foo(FooOut),
        Bar(BarOut),
    }

    #[derive(Clone, Debug)]
    pub enum FooOrBarOutStable {
        Foo(FooOut),
        Bar(BarOut),
    }

    #[derive(Clone, Debug)]
    pub enum FooOrBarIn {
        Foo(FooIn),
        Bar(BarIn),
    }

    impl super::Serialize for FooOrBarOut {
        const VARINT_ENCODED: bool = false;

        fn size(&self) -> u64 {
            match *self {
                FooOrBarOut::Foo(ref payload) => super::field_size(0, payload),
                FooOrBarOut::Bar(ref payload) => super::field_size(1, payload),
            }
        }

        fn serialize(&self, mut writer: impl ::std::io::Write) -> ::std::io::Result<()> {
            match *self {
                FooOrBarOut::Foo(ref payload) => super::serialize_field(writer, 0, payload),
                FooOrBarOut::Bar(ref payload) => super::serialize_field(writer, 1, payload),
            }
        }
    }

    impl super::Serialize for FooOrBarOutStable {
        const VARINT_ENCODED: bool = false;

        fn size(&self) -> u64 {
            match *self {
                FooOrBarOutStable::Foo(ref payload) => super::field_size(0, payload),
                FooOrBarOutStable::Bar(ref payload) => super::field_size(1, payload),
            }
        }

        fn serialize(&self, writer: impl ::std::io::Write) -> ::std::io::Result<()> {
            match *self {
                FooOrBarOutStable::Foo(ref payload) => super::serialize_field(writer, 0, payload),
                FooOrBarOutStable::Bar(ref payload) => super::serialize_field(writer, 1, payload),
            }
        }
    }

    impl super::Deserialize for FooOrBarIn {
        fn deserialize(mut reader: impl ::std::io::BufRead) -> ::std::io::Result<Self>
        where
            Self: Sized,
        {
            loop {
                let header = u64::deserialize(reader.by_ref())?;

                let index = header >> 2;

                let size = match header & 0b11 {
                    0b00 => {
                        let buffer = reader.fill_buf()?;

                        if buffer.is_empty() {
                            return Err(::std::io::Error::new(
                                ::std::io::ErrorKind::UnexpectedEof,
                                \"Error decoding field.\",
                            ));
                        }

                        u64::from(super::u64_size(buffer[0]))
                    }
                    0b01 => 0,
                    0b10 => 8,
                    0b11 => u64::deserialize(reader.by_ref())?,
                    _ => panic!(),
                };

                let mut sub_reader = ::std::io::Read::take(reader.by_ref(), size);

                match index {
                    0 => {
                        return Ok(FooOrBarIn::Foo(FooIn::deserialize(sub_reader)?));
                    }
                    1 => {
                        return Ok(FooOrBarIn::Bar(BarIn::deserialize(sub_reader)?));
                    }
                    _ => {
                        super::skip(&mut sub_reader, size as usize)?;
                    }
                }
            }
        }
    }

    impl From<FooOrBarOut> for FooOrBarIn {
        fn from(message: FooOrBarOut) -> Self {
            match message {
                FooOrBarOut::Foo(payload) => FooOrBarIn::Foo(payload.into()),
                FooOrBarOut::Bar(payload) => FooOrBarIn::Bar(payload.into()),
            }
        }
    }

    #[derive(Clone, Debug)]
    pub enum QuxOut {
        X(bool),
        Y(f64),
    }

    #[derive(Clone, Debug)]
    pub enum QuxOutStable {
        X(bool),
        Y(f64),
    }

    #[derive(Clone, Debug)]
    pub enum QuxIn {
        X(bool),
        Y(f64),
    }

    impl super::Serialize for QuxOut {
        const VARINT_ENCODED: bool = false;

        fn size(&self) -> u64 {
            match *self {
                QuxOut::X(ref payload) => super::field_size(0, payload),
                QuxOut::Y(ref payload) => super::field_size(1, payload),
            }
        }

        fn serialize(&self, mut writer: impl ::std::io::Write) -> ::std::io::Result<()> {
            match *self {
                QuxOut::X(ref payload) => super::serialize_field(writer, 0, payload),
                QuxOut::Y(ref payload) => super::serialize_field(writer, 1, payload),
            }
        }
    }

    impl super::Serialize for QuxOutStable {
        const VARINT_ENCODED: bool = false;

        fn size(&self) -> u64 {
            match *self {
                QuxOutStable::X(ref payload) => super::field_size(0, payload),
                QuxOutStable::Y(ref payload) => super::field_size(1, payload),
            }
        }

        fn serialize(&self, writer: impl ::std::io::Write) -> ::std::io::Result<()> {
            match *self {
                QuxOutStable::X(ref payload) => super::serialize_field(writer, 0, payload),
                QuxOutStable::Y(ref payload) => super::serialize_field(writer, 1, payload),
            }
        }
    }

    impl super::Deserialize for QuxIn {
        fn deserialize(mut reader: impl ::std::io::BufRead) -> ::std::io::Result<Self>
        where
            Self: Sized,
        {
            loop {
                let header = u64::deserialize(reader.by_ref())?;

                let index = header >> 2;

                let size = match header & 0b11 {
                    0b00 => {
                        let buffer = reader.fill_buf()?;

                        if buffer.is_empty() {
                            return Err(::std::io::Error::new(
                                ::std::io::ErrorKind::UnexpectedEof,
                                \"Error decoding field.\",
                            ));
                        }

                        u64::from(super::u64_size(buffer[0]))
                    }
                    0b01 => 0,
                    0b10 => 8,
                    0b11 => u64::deserialize(reader.by_ref())?,
                    _ => panic!(),
                };

                let mut sub_reader = ::std::io::Read::take(reader.by_ref(), size);

                match index {
                    0 => {
                        return Ok(QuxIn::X(bool::deserialize(sub_reader)?));
                    }
                    1 => {
                        return Ok(QuxIn::Y(f64::deserialize(sub_reader)?));
                    }
                    _ => {
                        super::skip(&mut sub_reader, size as usize)?;
                    }
                }
            }
        }
    }

    impl From<QuxOut> for QuxIn {
        fn from(message: QuxOut) -> Self {
            match message {
                QuxOut::X(payload) => QuxIn::X(payload.into()),
                QuxOut::Y(payload) => QuxIn::Y(payload.into()),
            }
        }
    }
}
",
        );
    }
}
