use {
    crate::{
        identifier::Identifier,
        schema::{self, relativize_namespace},
    },
    std::{
        collections::BTreeMap,
        fmt::{self, Write},
        path::PathBuf,
    },
};

// The string to be used for each indentation level.
const INDENTATION: &str = "    ";

// This struct represents a tree of schemas organized in a module hierarchy.
#[derive(Clone, Debug)]
struct Module {
    children: BTreeMap<Identifier, Module>,
    schema: schema::Schema,
}

// This enum represents a case convention for the `write_identifier` function below.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum CaseConvention {
    Pascal,
    Snake,
}

use CaseConvention::{Pascal, Snake};

// This enum is used to distinguish between the ingress and egress versions of a type.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum Direction {
    Out,
    In,
}

use Direction::{In, Out};

// Generate TypeScript code from a schema and its transitive dependencies.
#[allow(clippy::too_many_lines)]
pub fn generate(
    typical_version: &str,
    schemas: &BTreeMap<schema::Namespace, (schema::Schema, PathBuf, String)>,
) -> String {
    // Construct a tree of modules and schemas. We start with an empty tree.
    let mut tree = Module {
        children: BTreeMap::new(),
        schema: schema::Schema {
            imports: BTreeMap::new(),
            declarations: BTreeMap::new(),
        },
    };

    // Populate the tree with all the schemas.
    for (namespace, (schema, _, _)) in schemas {
        insert_schema(&mut tree, namespace, schema);
    }

    // Write the code.
    let mut buffer = String::new();

    if !tree.children.is_empty() || !tree.schema.declarations.is_empty() {
        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        // For functions that take abstract parameters which implement `std::io::Read` or
        // `std::io::Write`, it's idiomatic to consume the reader or writer rather than borrowing
        // them (https://rust-lang.github.io/api-guidelines/interoperability.html
        // #generic-readerwriter-functions-take-r-read-and-w-write-by-value-c-rw-value). However,
        // we borrow them anyway since that allows us to pass the reference (after reborrowing)
        // to recursive calls, rather than building up and following chains of references.
        writeln!(
            &mut buffer,
            "\
// This file was automatically generated by Typical {}.
// Visit https://github.com/stepchowfun/typical for more information.

// eslint-disable",
            typical_version,
        )
        .unwrap();

        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        writeln!(&mut buffer).unwrap();

        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        write_module_contents(
            &mut buffer,
            0,
            &schema::Namespace { components: vec![] },
            &tree.children,
            &tree.schema,
        )
        .unwrap();
    }

    buffer
}

// Insert a schema into a module.
fn insert_schema(module: &mut Module, namespace: &schema::Namespace, schema: &schema::Schema) {
    let mut iter = namespace.components.iter();

    if let Some(head) = iter.next() {
        if let Some(child) = module.children.get_mut(head) {
            insert_schema(
                child,
                &schema::Namespace {
                    components: iter.cloned().collect(),
                },
                schema,
            );
        } else {
            let mut child = Module {
                children: BTreeMap::new(),
                schema: schema::Schema {
                    imports: BTreeMap::new(),
                    declarations: BTreeMap::new(),
                },
            };

            insert_schema(
                &mut child,
                &schema::Namespace {
                    components: iter.cloned().collect(),
                },
                schema,
            );

            module.children.insert(head.clone(), child);
        }
    } else {
        module.schema = schema.clone();
    }
}

// Write a module, including a trailing line break.
fn write_module<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    name: &Identifier,
    module: &Module,
) -> Result<(), fmt::Error> {
    if indentation == 0 {
        write_indentation(buffer, indentation)?;
        writeln!(buffer, "#[rustfmt::skip]")?;
    }

    write_indentation(buffer, indentation)?;
    write!(buffer, "pub mod ")?;
    write_identifier(buffer, name, Snake, None)?;
    writeln!(buffer, " {{")?;

    let mut new_namespace = namespace.clone();
    new_namespace.components.push(name.clone());

    write_module_contents(
        buffer,
        indentation + 1,
        &new_namespace,
        &module.children,
        &module.schema,
    )?;

    write_indentation(buffer, indentation)?;
    writeln!(buffer, "}}")?;

    Ok(())
}

// Write the contents of a module, including a trailing line break if there was anything to render.
fn write_module_contents<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    children: &BTreeMap<Identifier, Module>,
    schema: &schema::Schema,
) -> Result<(), fmt::Error> {
    let schema_empty = schema.declarations.is_empty();

    for (i, (child_name, child)) in children.iter().enumerate() {
        write_module(buffer, indentation, namespace, child_name, child)?;

        if i < children.len() - 1 || !schema_empty {
            writeln!(buffer)?;
        }
    }

    write_schema(buffer, indentation, namespace, schema)?;

    Ok(())
}

// Write a schema, including a trailing line break if there was anything to render.
#[allow(clippy::too_many_lines)]
fn write_schema<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    schema: &schema::Schema,
) -> Result<(), fmt::Error> {
    // Construct a map from import name to namespace.
    let mut imports = BTreeMap::new();
    for (name, import) in &schema.imports {
        // The unwrap is safe due to [ref:namespace_populated].
        imports.insert(name.clone(), import.namespace.clone().unwrap());
    }

    // Write the declarations.
    let mut iter = schema.declarations.iter().peekable();
    while let Some((name, declaration)) = iter.next() {
        match &declaration.variant {
            schema::DeclarationVariant::Struct(fields) => {
                write_struct(buffer, indentation, &imports, namespace, name, fields, Out)?;

                writeln!(buffer)?;

                write_struct(buffer, indentation, &imports, namespace, name, fields, In)?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl ")?;
                write_supers(buffer, indentation)?;
                write!(buffer, "Serialize for ")?;
                write_identifier(buffer, name, Pascal, Some(Out))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "fn size(&self) -> u64 {{")?;
                if fields.is_empty() {
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "0")?;
                }
                for (i, field) in fields.iter().enumerate() {
                    let is_first = i == 0;
                    let is_last = i == fields.len() - 1;
                    if is_first {
                        write_indentation(buffer, indentation + 2)?;
                    }
                    match field.rule {
                        schema::Rule::Optional => {
                            write!(buffer, "self.")?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            writeln!(buffer, ".as_ref().map_or(0, |payload| {{")?;
                        }
                        schema::Rule::Required | schema::Rule::Asymmetric => {
                            writeln!(buffer, "({{")?;
                            write_indentation(buffer, indentation + 3)?;
                            write!(buffer, "let payload = &self.")?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            writeln!(buffer, ";")?;
                        }
                    }
                    write_indentation(buffer, indentation + 3)?;
                    write!(buffer, "let payload_size = ")?;
                    write_size_calculation_invocation(buffer, indentation, &field.r#type)?;
                    writeln!(buffer, ";")?;
                    write_indentation(buffer, indentation + 3)?;
                    write_supers(buffer, indentation)?;
                    if varint_encoded(&field.r#type) {
                        writeln!(
                            buffer,
                            "varint_field_header_size({}) + payload_size",
                            field.index,
                        )?;
                    } else {
                        writeln!(
                            buffer,
                            "non_varint_field_header_size({}, payload_size) + payload_size",
                            field.index,
                        )?;
                    }
                    write_indentation(buffer, indentation + 2)?;
                    write!(buffer, "}})")?;
                    if is_last {
                        writeln!(buffer)?;
                    } else {
                        write!(buffer, " + ")?;
                    }
                }
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(
                    buffer,
                    "fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> \
                        ::std::io::Result<()> {{",
                )?;
                for field in fields {
                    match field.rule {
                        schema::Rule::Optional => {
                            write_indentation(buffer, indentation + 2)?;
                            write!(buffer, "if let Some(payload) = &self.")?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            writeln!(buffer, " {{")?;
                        }
                        schema::Rule::Required | schema::Rule::Asymmetric => {
                            write_indentation(buffer, indentation + 2)?;
                            writeln!(buffer, "{{")?;
                            write_indentation(buffer, indentation + 3)?;
                            write!(buffer, "let payload = &self.")?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            writeln!(buffer, ";")?;
                        }
                    }
                    write_indentation(buffer, indentation + 3)?;
                    write!(buffer, "let payload_size = ")?;
                    write_size_calculation_invocation(buffer, indentation, &field.r#type)?;
                    writeln!(buffer, ";")?;
                    write_indentation(buffer, indentation + 3)?;
                    write_supers(buffer, indentation)?;
                    if varint_encoded(&field.r#type) {
                        write!(buffer, "serialize_varint_field_header")?;
                        writeln!(buffer, "(writer, {})?;", field.index)?;
                    } else {
                        write!(buffer, "serialize_non_varint_field_header")?;
                        writeln!(buffer, "(writer, {}, payload_size)?;", field.index)?;
                    }
                    write_serialization_invocation(
                        buffer,
                        indentation + 3,
                        indentation,
                        &field.r#type,
                    )?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                    writeln!(buffer)?;
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "Ok(())")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl ")?;
                write_supers(buffer, indentation)?;
                write!(buffer, "Deserialize for ")?;
                write_identifier(buffer, name, Pascal, Some(In))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(
                    buffer,
                    "fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>",
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "where")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "Self: Sized,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "T: ::std::io::BufRead,")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "{{")?;
                if !fields.is_empty() {
                    for field in fields {
                        write_indentation(buffer, indentation + 2)?;
                        write!(buffer, "let mut ")?;
                        write_identifier(buffer, &field.name, Snake, None)?;
                        write!(buffer, ": Option<")?;
                        write_type(buffer, &imports, namespace, &field.r#type, In)?;
                        writeln!(buffer, "> = None;")?;
                    }
                    writeln!(buffer)?;
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "loop {{")?;
                write_indentation(buffer, indentation + 3)?;
                write!(buffer, "let (index, size) = match ")?;
                write_supers(buffer, indentation)?;
                writeln!(buffer, "deserialize_field_header(&mut *reader) {{")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "Ok(header) => header,")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "Err(err) => {{")?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(
                    buffer,
                    "if let std::io::ErrorKind::UnexpectedEof = err.kind() {{",
                )?;
                write_indentation(buffer, indentation + 6)?;
                writeln!(buffer, "break;")?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "return Err(err);")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}};")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(
                    buffer,
                    "let mut sub_reader = ::std::io::Read::take(&mut *reader, size);",
                )?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "match index {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "{} => {{", field.index)?;
                    write_deserialization_invocation(
                        buffer,
                        indentation + 5,
                        indentation,
                        &imports,
                        namespace,
                        &field.r#type,
                    )?;
                    writeln!(buffer)?;
                    write_indentation(buffer, indentation + 5)?;
                    write_identifier(buffer, &field.name, Snake, None)?;
                    writeln!(buffer, ".get_or_insert(payload);")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "}}")?;
                }
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "_ => {{")?;
                write_indentation(buffer, indentation + 5)?;
                write_supers(buffer, indentation)?;
                writeln!(buffer, "skip(&mut sub_reader, size as usize)?;")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                if fields.iter().any(|field| match field.rule {
                    schema::Rule::Optional | schema::Rule::Asymmetric => false,
                    schema::Rule::Required => true,
                }) {
                    write_indentation(buffer, indentation + 2)?;
                    write!(buffer, "if ")?;
                    let mut first = true;
                    for field in fields {
                        match field.rule {
                            schema::Rule::Optional | schema::Rule::Asymmetric => {}
                            schema::Rule::Required => {
                                if first {
                                    first = false;
                                } else {
                                    write!(buffer, " || ")?;
                                }
                                write_identifier(buffer, &field.name, Snake, None)?;
                                write!(buffer, ".is_none()")?;
                            }
                        }
                    }
                    writeln!(buffer, " {{")?;
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "return Err(::std::io::Error::new(")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "::std::io::ErrorKind::InvalidData,")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "\"Struct missing one or more field(s).\",")?;
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "));")?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                    writeln!(buffer)?;
                }
                write_indentation(buffer, indentation + 2)?;
                write!(buffer, "Ok(")?;
                write_identifier(buffer, name, Pascal, Some(In))?;
                writeln!(buffer, " {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 3)?;
                    write_identifier(buffer, &field.name, Snake, None)?;
                    match field.rule {
                        schema::Rule::Optional | schema::Rule::Asymmetric => {}
                        schema::Rule::Required => {
                            write!(buffer, ": ")?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            write!(buffer, ".unwrap()")?;
                        }
                    }
                    writeln!(buffer, ",")?;
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}})")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl From<")?;
                write_identifier(buffer, name, Pascal, Some(Out))?;
                write!(buffer, "> for ")?;
                write_identifier(buffer, name, Pascal, Some(In))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "fn from(message: ")?;
                write_identifier(buffer, name, Pascal, Some(Out))?;
                writeln!(buffer, ") -> Self {{")?;
                write_indentation(buffer, indentation + 2)?;
                write_identifier(buffer, name, Pascal, Some(In))?;
                writeln!(buffer, " {{")?;
                for field in fields {
                    match field.rule {
                        schema::Rule::Optional => {
                            write_indentation(buffer, indentation + 3)?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            write!(buffer, ": message.")?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            writeln!(buffer, ".map(|payload| payload.into()),")?;
                        }
                        schema::Rule::Required => {
                            write_indentation(buffer, indentation + 3)?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            write!(buffer, ": message.")?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            writeln!(buffer, ".into(),")?;
                        }
                        schema::Rule::Asymmetric => {
                            write_indentation(buffer, indentation + 3)?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            write!(buffer, ": Some(message.")?;
                            write_identifier(buffer, &field.name, Snake, None)?;
                            writeln!(buffer, ".into()),")?;
                        }
                    }
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;
            }
            schema::DeclarationVariant::Choice(fields) => {
                write_choice(buffer, indentation, &imports, namespace, name, fields, Out)?;

                writeln!(buffer)?;

                write_choice(buffer, indentation, &imports, namespace, name, fields, In)?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl ")?;
                write_supers(buffer, indentation)?;
                write!(buffer, "Serialize for ")?;
                write_identifier(buffer, name, Pascal, Some(Out))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "fn size(&self) -> u64 {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "match *self {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 3)?;
                    write_identifier(buffer, name, Pascal, Some(Out))?;
                    write!(buffer, "::")?;
                    write_identifier(buffer, &field.name, Pascal, None)?;
                    match field.rule {
                        schema::Rule::Optional | schema::Rule::Asymmetric => {
                            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                                writeln!(buffer, "(ref fallback) => {{")?;
                            } else {
                                writeln!(buffer, "(ref payload, ref fallback) => {{")?;
                            }
                        }
                        schema::Rule::Required => {
                            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                                writeln!(buffer, " => {{")?;
                            } else {
                                writeln!(buffer, "(ref payload) => {{")?;
                            }
                        }
                    }
                    write_indentation(buffer, indentation + 4)?;
                    write!(buffer, "let payload_size = ")?;
                    write_size_calculation_invocation(buffer, indentation, &field.r#type)?;
                    writeln!(buffer, ";")?;
                    write_indentation(buffer, indentation + 4)?;
                    write_supers(buffer, indentation)?;
                    if varint_encoded(&field.r#type) {
                        writeln!(buffer, "varint_field_header_size({}) +", field.index)?;
                    } else {
                        writeln!(
                            buffer,
                            "non_varint_field_header_size({}, payload_size) +",
                            field.index,
                        )?;
                    }
                    write_indentation(buffer, indentation + 5)?;
                    write!(buffer, "payload_size")?;
                    match field.rule {
                        schema::Rule::Optional | schema::Rule::Asymmetric => {
                            writeln!(buffer, " +")?;
                            write_indentation(buffer, indentation + 5)?;
                            writeln!(buffer, "fallback.size()")?;
                        }
                        schema::Rule::Required => {
                            writeln!(buffer)?;
                        }
                    }
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "}}")?;
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(
                    buffer,
                    "fn serialize<T: ::std::io::Write>(&self, writer: &mut T) -> \
                        ::std::io::Result<()> {{",
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "match *self {{")?; // [ref:empty_enum_ref_match]
                for field in fields {
                    write_indentation(buffer, indentation + 3)?;
                    write_identifier(buffer, name, Pascal, Some(Out))?;
                    write!(buffer, "::")?;
                    write_identifier(buffer, &field.name, Pascal, None)?;
                    match field.rule {
                        schema::Rule::Optional | schema::Rule::Asymmetric => {
                            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                                writeln!(buffer, "(ref fallback) => {{")?;
                            } else {
                                writeln!(buffer, "(ref payload, ref fallback) => {{")?;
                            }
                        }
                        schema::Rule::Required => {
                            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                                writeln!(buffer, " => {{")?;
                            } else {
                                writeln!(buffer, "(ref payload) => {{")?;
                            }
                        }
                    }
                    write_indentation(buffer, indentation + 4)?;
                    write_supers(buffer, indentation)?;
                    if varint_encoded(&field.r#type) {
                        writeln!(
                            buffer,
                            "serialize_varint_field_header(writer, {})?;",
                            field.index,
                        )?;
                    } else {
                        write!(
                            buffer,
                            "serialize_non_varint_field_header(writer, {}, ",
                            field.index,
                        )?;
                        write_size_calculation_invocation(buffer, indentation, &field.r#type)?;
                        writeln!(buffer, ")?;")?;
                    }
                    write_serialization_invocation(
                        buffer,
                        indentation + 4,
                        indentation,
                        &field.r#type,
                    )?;
                    match field.rule {
                        schema::Rule::Optional | schema::Rule::Asymmetric => {
                            write_indentation(buffer, indentation + 4)?;
                            writeln!(buffer, "fallback.serialize(writer)")?;
                        }
                        schema::Rule::Required => {
                            write_indentation(buffer, indentation + 4)?;
                            writeln!(buffer, "Ok(())")?;
                        }
                    }
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "}}")?;
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl ")?;
                write_supers(buffer, indentation)?;
                write!(buffer, "Deserialize for ")?;
                write_identifier(buffer, name, Pascal, Some(In))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(
                    buffer,
                    "fn deserialize<T>(reader: &mut T) -> ::std::io::Result<Self>",
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "where")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "Self: Sized,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "T: ::std::io::BufRead,")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "loop {{")?;
                write_indentation(buffer, indentation + 3)?;
                write!(buffer, "let (index, size) = ")?;
                write_supers(buffer, indentation)?;
                writeln!(buffer, "deserialize_field_header(&mut *reader)?;")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(
                    buffer,
                    "let mut sub_reader = ::std::io::Read::take(&mut *reader, size);",
                )?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "match index {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "{} => {{", field.index)?;
                    write_deserialization_invocation(
                        buffer,
                        indentation + 5,
                        indentation,
                        &imports,
                        namespace,
                        &field.r#type,
                    )?;
                    match field.rule {
                        schema::Rule::Optional => {
                            write_indentation(buffer, indentation + 5)?;
                            write!(buffer, "let fallback = Box::new(<")?;
                            write_identifier(buffer, name, Pascal, Some(In))?;
                            write!(buffer, " as ")?;
                            write_supers(buffer, indentation)?;
                            writeln!(buffer, "Deserialize>::deserialize(&mut *reader)?);")?;
                            write_indentation(buffer, indentation + 5)?;
                            write!(buffer, "return Ok(")?;
                            write_identifier(buffer, name, Pascal, Some(In))?;
                            write!(buffer, "::")?;
                            write_identifier(buffer, &field.name, Pascal, None)?;
                            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                                writeln!(buffer, "(fallback));")?;
                            } else {
                                writeln!(buffer, "(payload, fallback));")?;
                            }
                        }
                        schema::Rule::Required | schema::Rule::Asymmetric => {
                            write_indentation(buffer, indentation + 5)?;
                            write!(buffer, "return Ok(")?;
                            write_identifier(buffer, name, Pascal, Some(In))?;
                            write!(buffer, "::")?;
                            write_identifier(buffer, &field.name, Pascal, None)?;
                            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                                writeln!(buffer, ");")?;
                            } else {
                                writeln!(buffer, "(payload));")?;
                            }
                        }
                    }
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "}}")?;
                }
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "_ => {{")?;
                write_indentation(buffer, indentation + 5)?;
                write_supers(buffer, indentation)?;
                writeln!(buffer, "skip(&mut sub_reader, size as usize)?;")?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "impl From<")?;
                write_identifier(buffer, name, Pascal, Some(Out))?;
                write!(buffer, "> for ")?;
                write_identifier(buffer, name, Pascal, Some(In))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "fn from(message: ")?;
                write_identifier(buffer, name, Pascal, Some(Out))?;
                writeln!(buffer, ") -> Self {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "match message {{")?;
                for field in fields {
                    write_indentation(buffer, indentation + 3)?;
                    write_identifier(buffer, name, Pascal, Some(Out))?;
                    write!(buffer, "::")?;
                    write_identifier(buffer, &field.name, Pascal, None)?;
                    match field.rule {
                        schema::Rule::Optional | schema::Rule::Asymmetric => {
                            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                                write!(buffer, "(fallback) => ")?;
                            } else {
                                write!(buffer, "(payload, fallback) => ")?;
                            }
                        }
                        schema::Rule::Required => {
                            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                                write!(buffer, " => ")?;
                            } else {
                                write!(buffer, "(payload) => ")?;
                            }
                        }
                    }
                    write_identifier(buffer, name, Pascal, Some(In))?;
                    write!(buffer, "::")?;
                    write_identifier(buffer, &field.name, Pascal, None)?;
                    match field.rule {
                        schema::Rule::Optional => {
                            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                                writeln!(buffer, "(Box::new((*fallback).into())),")?;
                            } else {
                                writeln!(
                                    buffer,
                                    "(payload.into(), Box::new((*fallback).into())),",
                                )?;
                            }
                        }
                        schema::Rule::Required | schema::Rule::Asymmetric => {
                            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                                writeln!(buffer, ",")?;
                            } else {
                                writeln!(buffer, "(payload.into()),")?;
                            }
                        }
                    }
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;
            }
        }

        if iter.peek().is_some() {
            writeln!(buffer)?;
        }
    }

    Ok(())
}

// Write a struct, including a trailing line break.
fn write_struct<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    name: &Identifier,
    fields: &[schema::Field],
    direction: Direction,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    write!(buffer, "pub struct ")?;
    write_identifier(buffer, name, Pascal, Some(direction))?;
    writeln!(buffer, " {{")?;

    for field in fields {
        write_indentation(buffer, indentation + 1)?;
        write!(buffer, "pub ")?;
        write_identifier(buffer, &field.name, Snake, None)?;
        write!(buffer, ": ")?;
        match field.rule {
            schema::Rule::Optional => {
                write!(buffer, "Option<")?;
            }
            schema::Rule::Required => {}
            schema::Rule::Asymmetric => match direction {
                Direction::Out => {}
                Direction::In => {
                    write!(buffer, "Option<")?;
                }
            },
        }
        write_type(buffer, imports, namespace, &field.r#type, direction)?;
        match field.rule {
            schema::Rule::Optional => {
                write!(buffer, ">")?;
            }
            schema::Rule::Required => {}
            schema::Rule::Asymmetric => match direction {
                Direction::Out => {}
                Direction::In => {
                    write!(buffer, ">")?;
                }
            },
        }
        writeln!(buffer, ",")?;
    }

    write_indentation(buffer, indentation)?;
    writeln!(buffer, "}}")?;

    Ok(())
}

// Write a choice, including a trailing line break.
fn write_choice<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    name: &Identifier,
    fields: &[schema::Field],
    direction: Direction,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    write!(buffer, "pub enum ")?;
    write_identifier(buffer, name, Pascal, Some(direction))?;
    writeln!(buffer, " {{")?;

    for field in fields {
        write_indentation(buffer, indentation + 1)?;
        write_identifier(buffer, &field.name, Pascal, None)?;
        let fallback = match field.rule {
            schema::Rule::Optional => true,
            schema::Rule::Required => false,
            schema::Rule::Asymmetric => match direction {
                Direction::Out => true,
                Direction::In => false,
            },
        };
        if fallback {
            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                write!(buffer, "(Box<")?;
            } else {
                write!(buffer, "(")?;
                write_type(buffer, imports, namespace, &field.r#type, direction)?;
                write!(buffer, ", Box<")?;
            }
            write_identifier(buffer, name, Pascal, Some(direction))?;
            writeln!(buffer, ">),")?;
        } else if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
            writeln!(buffer, ",")?;
        } else {
            write!(buffer, "(")?;
            write_type(buffer, imports, namespace, &field.r#type, direction)?;
            writeln!(buffer, "),")?;
        }
    }

    write_indentation(buffer, indentation)?;
    writeln!(buffer, "}}")?;

    Ok(())
}

// Write a type.
fn write_type<T: Write>(
    buffer: &mut T,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    r#type: &schema::Type,
    direction: Direction,
) -> Result<(), fmt::Error> {
    match &r#type.variant {
        schema::TypeVariant::Array(inner_type) => {
            write!(buffer, "Vec<")?;
            write_type(buffer, imports, namespace, inner_type, direction)?;
            write!(buffer, ">")?;
        }
        schema::TypeVariant::Bool => {
            write!(buffer, "bool")?;
        }
        schema::TypeVariant::Bytes => {
            write!(buffer, "Vec<u8>")?;
        }
        schema::TypeVariant::Custom(import, name) => {
            let type_namespace = schema::Namespace {
                components: import.as_ref().map_or_else(
                    || namespace.components.clone(),
                    |import| imports[import].components.clone(),
                ),
            };

            let (relative_type_namespace, ancestors) =
                relativize_namespace(&type_namespace, namespace);

            write_supers(buffer, ancestors)?;

            for component in relative_type_namespace.components {
                write_identifier(buffer, &component, Snake, None)?;
                write!(buffer, "::")?;
            }

            write_identifier(buffer, name, Pascal, Some(direction))?;
        }
        schema::TypeVariant::F64 => {
            write!(buffer, "f64")?;
        }
        schema::TypeVariant::S64 => {
            write!(buffer, "i64")?;
        }
        schema::TypeVariant::String => {
            write!(buffer, "String")?;
        }
        schema::TypeVariant::U64 => {
            write!(buffer, "u64")?;
        }
        schema::TypeVariant::Unit => {
            write!(buffer, "()")?;
        }
    }

    Ok(())
}

// Write an identifier with an optional direction suffix in a way that Rust will be happy with.
fn write_identifier<T: Write>(
    buffer: &mut T,
    identifier: &Identifier,
    case: CaseConvention,
    suffix: Option<Direction>,
) -> Result<(), fmt::Error> {
    let identifier_with_suffix = suffix.map_or_else(
        || identifier.clone(),
        |suffix| {
            identifier.join(
                &match suffix {
                    Direction::In => "In",
                    Direction::Out => "Out",
                }
                .into(),
            )
        },
    );

    write!(
        buffer,
        "{}",
        match case {
            CaseConvention::Pascal => identifier_with_suffix.pascal_case(),
            CaseConvention::Snake => identifier_with_suffix.snake_case(),
        },
    )?;

    Ok(())
}

// Write the given level of indentation.
fn write_indentation<T: Write>(buffer: &mut T, indentation: usize) -> Result<(), fmt::Error> {
    for _ in 0..indentation {
        write!(buffer, "{}", INDENTATION)?;
    }

    Ok(())
}

// Write a series of `super::super::...`.
fn write_supers<T: Write>(buffer: &mut T, count: usize) -> Result<(), fmt::Error> {
    for _ in 0..count {
        write!(buffer, "super::")?;
    }

    Ok(())
}

// Write the logic to invoke the size calculation logic for a value.
fn write_size_calculation_invocation<T: Write>(
    buffer: &mut T,
    supers: usize,
    r#type: &schema::Type,
) -> Result<(), fmt::Error> {
    match &r#type.variant {
        schema::TypeVariant::Array(inner_type) => match &inner_type.variant {
            schema::TypeVariant::Array(_)
            | schema::TypeVariant::Bytes
            | schema::TypeVariant::Custom(_, _)
            | schema::TypeVariant::String => {
                write!(
                    buffer,
                    "payload.iter().fold(0_u64, |x, payload| {{ let payload_size = ",
                )?;
                write_size_calculation_invocation(buffer, supers, inner_type)?;
                write!(buffer, "; x + ")?;
                write_supers(buffer, supers)?;
                write!(
                    buffer,
                    "varint_size_from_value(payload_size) + payload_size }})",
                )
            }
            schema::TypeVariant::Bool | schema::TypeVariant::S64 | schema::TypeVariant::U64 => {
                write!(buffer, "payload.iter().fold(0_u64, |x, payload| x + ")?;
                write_size_calculation_invocation(buffer, supers, inner_type)?;
                write!(buffer, ")")
            }
            schema::TypeVariant::F64 => write!(buffer, "8_u64 * (payload.len() as u64)"),
            schema::TypeVariant::Unit => {
                write_supers(buffer, supers)?;
                write!(buffer, "varint_size_from_value(payload.len() as u64)")
            }
        },
        schema::TypeVariant::Bool => write!(buffer, "1_u64"),
        schema::TypeVariant::Bytes | schema::TypeVariant::String => {
            write!(buffer, "payload.len() as u64")
        }
        schema::TypeVariant::Custom(_, _) => write!(buffer, "payload.size()"),
        schema::TypeVariant::F64 => write!(buffer, "8_u64"),
        schema::TypeVariant::S64 => {
            write_supers(buffer, supers)?;
            write!(buffer, "varint_size_from_value(")?;
            write_supers(buffer, supers)?;
            write!(buffer, "zigzag_encode(*payload))")
        }
        schema::TypeVariant::U64 => {
            write_supers(buffer, supers)?;
            write!(buffer, "varint_size_from_value(*payload)")
        }
        schema::TypeVariant::Unit => write!(buffer, "0_u64"),
    }
}

// Write the logic to invoke the serialization logic for a value, including a trailing line break.
fn write_serialization_invocation<T: Write>(
    buffer: &mut T,
    indentation: usize,
    supers: usize,
    r#type: &schema::Type,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;

    match &r#type.variant {
        schema::TypeVariant::Array(inner_type) => match &inner_type.variant {
            schema::TypeVariant::Array(_)
            | schema::TypeVariant::Bytes
            | schema::TypeVariant::Custom(_, _)
            | schema::TypeVariant::String => {
                writeln!(buffer, "for payload in payload {{")?;
                write_indentation(buffer, indentation + 1)?;
                write_supers(buffer, supers)?;
                write!(buffer, "serialize_varint(")?;
                write_size_calculation_invocation(buffer, supers, inner_type)?;
                writeln!(buffer, ", writer)?;")?;
                write_serialization_invocation(buffer, indentation + 1, supers, inner_type)?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Bool
            | schema::TypeVariant::S64
            | schema::TypeVariant::U64
            | schema::TypeVariant::F64 => {
                writeln!(buffer, "for payload in payload {{")?;
                write_serialization_invocation(buffer, indentation + 1, supers, inner_type)?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Unit => {
                write_supers(buffer, supers)?;
                writeln!(buffer, "serialize_varint(payload.len() as u64, writer)?;")
            }
        },
        schema::TypeVariant::Bool => {
            write_supers(buffer, supers)?;
            writeln!(buffer, "serialize_varint(*payload as u64, writer)?;")
        }
        schema::TypeVariant::Bytes => writeln!(buffer, "writer.write_all(payload)?;"),
        schema::TypeVariant::Custom(_, _) => writeln!(buffer, "payload.serialize(writer)?;"),
        schema::TypeVariant::F64 => writeln!(buffer, "writer.write_all(&payload.to_le_bytes())?;"),
        schema::TypeVariant::S64 => {
            write_supers(buffer, supers)?;
            write!(buffer, "serialize_varint(")?;
            write_supers(buffer, supers)?;
            writeln!(buffer, "zigzag_encode(*payload), writer)?;")
        }
        schema::TypeVariant::String => writeln!(buffer, "writer.write_all(payload.as_bytes())?;"),
        schema::TypeVariant::U64 => {
            write_supers(buffer, supers)?;
            writeln!(buffer, "serialize_varint(*payload, writer)?;")
        }
        schema::TypeVariant::Unit => writeln!(buffer, "();"),
    }
}

// Write the logic to invoke the deserialization logic for a value, including a trailing line break.
#[allow(clippy::too_many_lines)]
fn write_deserialization_invocation<T: Write>(
    buffer: &mut T,
    indentation: usize,
    supers: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    r#type: &schema::Type,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;

    match &r#type.variant {
        schema::TypeVariant::Array(inner_type) => match &inner_type.variant {
            schema::TypeVariant::Array(_)
            | schema::TypeVariant::Bytes
            | schema::TypeVariant::Custom(_, _)
            | schema::TypeVariant::String => {
                writeln!(buffer, "let mut payload = Vec::new();")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "loop {{")?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "let element_size = match ")?;
                write_supers(buffer, supers)?;
                writeln!(buffer, "deserialize_varint(&mut sub_reader) {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "Ok(element_size) => element_size,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "Err(err) => {{")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(
                    buffer,
                    "if let std::io::ErrorKind::UnexpectedEof = err.kind() {{",
                )?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "break;")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "return Err(err);")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}};")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(
                    buffer,
                    "let mut sub_reader = ::std::io::Read::take(\
                            &mut sub_reader, element_size);",
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payload.push({{")?;
                write_deserialization_invocation(
                    buffer,
                    indentation + 2,
                    supers,
                    imports,
                    namespace,
                    inner_type,
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "payload")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}});")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Bool
            | schema::TypeVariant::S64
            | schema::TypeVariant::U64
            | schema::TypeVariant::F64 => {
                write!(
                    buffer,
                    "fn deserialize_element<T: ::std::io::BufRead>(mut sub_reader: &mut T) -> \
                            ::std::io::Result<",
                )?;
                write_type(buffer, imports, namespace, inner_type, In)?;
                writeln!(buffer, "> {{")?;
                write_deserialization_invocation(
                    buffer,
                    indentation + 1,
                    supers,
                    imports,
                    namespace,
                    inner_type,
                )?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "Ok(payload)")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "let mut payload = Vec::new();")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "loop {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(
                    buffer,
                    "payload.push(match deserialize_element(&mut sub_reader) {{",
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "Ok(element) => element,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "Err(err) => {{")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(
                    buffer,
                    "if let std::io::ErrorKind::UnexpectedEof = err.kind() {{",
                )?;
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "break;")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "return Err(err);")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}});")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Unit => {
                write!(buffer, "let payload = vec![(); ")?;
                write_supers(buffer, supers)?;
                writeln!(buffer, "deserialize_varint(&mut sub_reader)? as usize];")
            }
        },
        schema::TypeVariant::Bool => {
            writeln!(buffer, "let mut buffer = [0_u8];")?;
            write_indentation(buffer, indentation)?;
            writeln!(
                buffer,
                "::std::io::Read::read_exact(&mut sub_reader, &mut buffer[..])?;",
            )?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "let payload = buffer[0] != 0b0000_0001;")
        }
        schema::TypeVariant::Bytes => {
            writeln!(buffer, "let mut payload = vec![];")?;
            write_indentation(buffer, indentation)?;
            writeln!(
                buffer,
                "::std::io::Read::read_to_end(&mut sub_reader, &mut payload)?;",
            )
        }
        schema::TypeVariant::Custom(_, _) => {
            write!(buffer, "let payload = <")?;
            write_type(buffer, imports, namespace, r#type, In)?;
            write!(buffer, " as ")?;
            write_supers(buffer, supers)?;
            writeln!(buffer, "Deserialize>::deserialize(&mut sub_reader)?;")
        }
        schema::TypeVariant::F64 => {
            writeln!(buffer, "let mut buffer = [0; 8];")?;
            write_indentation(buffer, indentation)?;
            writeln!(
                buffer,
                "::std::io::Read::read_exact(&mut sub_reader, &mut buffer)?;",
            )?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "let payload = f64::from_le_bytes(buffer);")
        }
        schema::TypeVariant::S64 => {
            write!(buffer, "let payload = ")?;
            write_supers(buffer, supers)?;
            write!(buffer, "zigzag_decode(")?;
            write_supers(buffer, supers)?;
            writeln!(buffer, "deserialize_varint(&mut sub_reader)?);")
        }
        schema::TypeVariant::String => {
            writeln!(buffer, "let mut buffer = vec![];")?;
            write_indentation(buffer, indentation)?;
            writeln!(
                buffer,
                "::std::io::Read::read_to_end(&mut sub_reader, &mut buffer)?;",
            )?;
            write_indentation(buffer, indentation)?;
            writeln!(
                buffer,
                "let payload = std::str::from_utf8(&buffer).map_or_else(",
            )?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(
                buffer,
                "|err| Err(::std::io::Error::new(::std::io::ErrorKind::Other, err)),",
            )?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "|result| Ok(result.to_owned()),")?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, ")?;")
        }
        schema::TypeVariant::U64 => {
            write!(buffer, "let payload = ")?;
            write_supers(buffer, supers)?;
            writeln!(buffer, "deserialize_varint(&mut sub_reader)?;")
        }
        schema::TypeVariant::Unit => writeln!(buffer, "let payload = ();"),
    }
}

// Determine whether a type is encoded as a varint.
fn varint_encoded(r#type: &schema::Type) -> bool {
    match &r#type.variant {
        schema::TypeVariant::Bool | schema::TypeVariant::S64 | schema::TypeVariant::U64 => true,
        schema::TypeVariant::Array(_)
        | schema::TypeVariant::Bytes
        | schema::TypeVariant::Custom(_, _)
        | schema::TypeVariant::F64
        | schema::TypeVariant::String
        | schema::TypeVariant::Unit => false,
    }
}

#[cfg(test)]
mod tests {
    use {
        crate::{generate_typescript::generate, schema_loader::load_schemas, validator::validate},
        std::path::Path,
    };

    // This test doesn't work on Windows, for some reason.
    #[allow(clippy::too_many_lines)]
    #[test]
    #[cfg_attr(target_os = "windows", ignore)]
    fn generate_example() {
        let schemas = load_schemas(Path::new("integration_tests/types/main.t")).unwrap();
        validate(&schemas).unwrap();

        assert_eq!(
            generate("0.0.0", &schemas),
            "",
        );
    }
}
