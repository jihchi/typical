use {
    crate::{identifier::Identifier, schema},
    std::{
        collections::BTreeMap,
        fmt::{self, Write},
        path::PathBuf,
    },
};

// The string to be used for each indentation level.
const INDENTATION: &str = "  ";

// This is the full list of TypeScript keywords, derived from:
//   https://github.com/microsoft/TypeScript/blob/2161e1852f4f627bbc7571c6b7284f419ec524c9
//   /src/compiler/types.ts#L113-L194
const TYPESCRIPT_KEYWORDS: &[&str] = &[
    "abstract",
    "any",
    "as",
    "assert",
    "asserts",
    "async",
    "await",
    "bigint",
    "boolean",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "constructor",
    "continue",
    "debugger",
    "declare",
    "default",
    "delete",
    "do",
    "else",
    "enum",
    "export",
    "extends",
    "false",
    "finally",
    "for",
    "from",
    "function",
    "get",
    "global",
    "if",
    "implements",
    "import",
    "in",
    "infer",
    "instanceof",
    "interface",
    "intrinsic",
    "is",
    "keyof",
    "let",
    "module",
    "namespace",
    "never",
    "new",
    "null",
    "number",
    "object",
    "of",
    "override",
    "package",
    "private",
    "protected",
    "public",
    "readonly",
    "require",
    "return",
    "set",
    "static",
    "string",
    "super",
    "switch",
    "symbol",
    "this",
    "throw",
    "true",
    "try",
    "type",
    "typeof",
    "undefined",
    "unique",
    "unknown",
    "var",
    "void",
    "while",
    "with",
    "yield",
];

// This struct represents a tree of schemas organized in a module hierarchy.
#[derive(Clone, Debug)]
struct Module {
    children: BTreeMap<Identifier, Module>,
    schema: schema::Schema,
}

// This enum represents a case convention for the `write_identifier` function below.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum CaseConvention {
    Camel,
    Pascal,
}

use CaseConvention::{Camel, Pascal};

// This enum is used to distinguish between the ingress and egress versions of a type.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum Direction {
    Out,
    In,
}

use Direction::{In, Out};

// Generate TypeScript code from a schema and its transitive dependencies.
#[allow(clippy::too_many_lines)]
pub fn generate(
    typical_version: &str,
    schemas: &BTreeMap<schema::Namespace, (schema::Schema, PathBuf, String)>,
) -> String {
    // Construct a tree of modules and schemas. We start with an empty tree.
    let mut tree = Module {
        children: BTreeMap::new(),
        schema: schema::Schema {
            comment: vec![],
            imports: BTreeMap::new(),
            declarations: vec![],
        },
    };

    // Populate the tree with all the schemas.
    for (namespace, (schema, _, _)) in schemas {
        insert_schema(&mut tree, namespace, schema);
    }

    // Write the code.
    let mut buffer = String::new();

    if !tree.children.is_empty() || !tree.schema.declarations.is_empty() {
        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        writeln!(
            &mut buffer,
            "\
// This file was automatically generated by Typical {}.
// Visit https://github.com/stepchowfun/typical for more information.

/* eslint-disable */

export function unreachable(x: never): never {{
  return x;
}}

function zigzagEncode(value: bigint): bigint {{
  const twice = value << 1n;
  return value < 0n ? -1n - twice : twice;
}}

function zigzagDecode(value: bigint): bigint {{
  const half = (value + 1n) >> 1n;
  return (value & 1n) === 0n ? half : -half;
}}

function varintSizeFromValue(value: bigint): number {{
  if (value < 128n) {{
    return 1;
  }} else if (value < 16_512n) {{
    return 2;
  }} else if (value < 2_113_664n) {{
    return 3;
  }} else if (value < 270_549_120n) {{
    return 4;
  }} else if (value < 34_630_287_488n) {{
    return 5;
  }} else if (value < 4_432_676_798_592n) {{
    return 6;
  }} else if (value < 567_382_630_219_904n) {{
    return 7;
  }} else if (value < 72_624_976_668_147_840n) {{
    return 8;
  }} else {{
    return 9;
  }}
}}

function varintSizeFromFirstByte(firstByte: number): number {{
  let trailingZeros = 0;

  while (trailingZeros < 8 && (firstByte & 1) !== 1) {{
    ++trailingZeros;
    firstByte >>= 1;
  }}

  return trailingZeros + 1;
}}

const dataView64 = new DataView(new ArrayBuffer(8));

function serializeVarint(
  dataView: DataView,
  offset: number,
  value: bigint,
): number {{
  if (value < 128n) {{
    dataView.setUint8(offset, Number(value << 1n) | 0b0000_0001);
    return offset + 1;
  }} else if (value < 16_512n) {{
    value -= 128n;
    dataView.setUint8(offset, Number((value << 2n) % 256n) | 0b0000_0010);
    dataView.setUint8(offset + 1, Number(value >> 6n));
    return offset + 2;
  }} else if (value < 2_113_664n) {{
    value -= 16_512n;
    dataView.setUint8(offset, Number((value << 3n) % 256n) | 0b0000_0100);
    dataView.setUint16(offset + 1, Number((value >> 5n) % 65_536n), true);
    return offset + 3;
  }} else if (value < 270_549_120n) {{
    value -= 2_113_664n;
    dataView.setUint8(offset, Number((value << 4n) % 256n) | 0b0000_1000);
    dataView.setUint8(offset + 1, Number((value >> 4n) % 256n));
    dataView.setUint16(offset + 2, Number((value >> 12n) % 65_536n), true);
    return offset + 4;
  }} else if (value < 34_630_287_488n) {{
    value -= 270_549_120n;
    dataView.setUint8(offset, Number((value << 5n) % 256n) | 0b0001_0000);
    dataView.setUint32(
      offset + 1,
      Number((value >> 3n) % 4_294_967_296n),
      true,
    );
    return offset + 5;
  }} else if (value < 4_432_676_798_592n) {{
    value -= 34_630_287_488n;
    dataView.setUint8(offset, Number((value << 6n) % 256n) | 0b0010_0000);
    dataView.setUint8(offset + 1, Number((value >> 2n) % 256n));
    dataView.setUint32(
      offset + 2,
      Number((value >> 10n) % 4_294_967_296n),
      true,
    );
    return offset + 6;
  }} else if (value < 567_382_630_219_904n) {{
    value -= 4_432_676_798_592n;
    dataView.setUint8(offset, Number((value << 7n) % 256n) | 0b0100_0000);
    dataView.setUint16(offset + 1, Number((value >> 1n) % 65_536n), true);
    dataView.setUint32(
      offset + 3,
      Number((value >> 17n) % 4_294_967_296n),
      true,
    );
    return offset + 7;
  }} else if (value < 72_624_976_668_147_840n) {{
    value -= 567_382_630_219_904n;
    dataView.setUint8(offset, 0b1000_0000);
    dataView.setUint8(offset + 1, Number(value % 256n));
    dataView.setUint16(offset + 2, Number((value >> 8n) % 65_536n), true);
    dataView.setUint32(
      offset + 4,
      Number((value >> 24n) % 4_294_967_296n),
      true,
    );
    return offset + 8;
  }} else {{
    value -= 72_624_976_668_147_840n;
    dataView.setUint8(offset, 0b0000_0000);
    dataView.setBigUint64(offset + 1, value, true);
    return offset + 9;
  }}
}}

function deserializeVarint(
  dataView: DataView,
  offset: number,
): [number, bigint] {{
  const firstByte = dataView.getUint8(offset);
  const sizeMinusOne = varintSizeFromFirstByte(firstByte) - 1;
  const offsetPlusOne = offset + 1;
  dataView64.setBigUint64(offset, 0n, true);
  for (let i = 0; i < sizeMinusOne; ++i) {{
    dataView64.setUint8(i, dataView.getUint8(offsetPlusOne + i));
  }}
  const remainingBytesValue = dataView64.getBigUint64(0, true);
  switch (sizeMinusOne) {{
    case 0:
      return [offset + 1, BigInt(firstByte >> 1)];
    case 1:
      return [
        offset + 2,
        128n + BigInt(firstByte >> 2) + (remainingBytesValue << 6n),
      ];
    case 2:
      return [
        offset + 3,
        16_512n + BigInt(firstByte >> 3) + (remainingBytesValue << 5n),
      ];
    case 3:
      return [
        offset + 4,
        2_113_664n + BigInt(firstByte >> 4) + (remainingBytesValue << 4n),
      ];
    case 4:
      return [
        offset + 5,
        270_549_120n + BigInt(firstByte >> 5) + (remainingBytesValue << 3n),
      ];
    case 5:
      return [
        offset + 6,
        34_630_287_488n + BigInt(firstByte >> 6) + (remainingBytesValue << 2n),
      ];
    case 6:
      return [
        offset + 7,
        4_432_676_798_592n +
          BigInt(firstByte >> 7) +
          (remainingBytesValue << 1n),
      ];
    case 7:
      return [offset + 8, 567_382_630_219_904n + remainingBytesValue];
    default:
      return [
        offset + 9,
        (72_624_976_668_147_840n + remainingBytesValue) %
          18_446_744_073_709_551_616n,
      ];
  }}
}}

function fieldHeaderSize(
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {{
  switch (payloadSize) {{
    case 0:
      return varintSizeFromValue((index << 2n) | BigInt(0b00));
    case 8:
      return varintSizeFromValue((index << 2n) | BigInt(0b01));
    default:
      if (integerEncoded) {{
        return varintSizeFromValue((index << 2n) | BigInt(0b11));
      }} else {{
        return (
          varintSizeFromValue((index << 2n) | BigInt(0b10)) +
          varintSizeFromValue(BigInt(payloadSize))
        );
      }}
  }}
}}

function serializeFieldHeader(
  dataView: DataView,
  offset: number,
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {{
  switch (payloadSize) {{
    case 0:
      return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b00));
    case 1:
      return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b01));
    default:
      if (integerEncoded) {{
        return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b11));
      }} else {{
        offset = serializeVarint(
          dataView,
          offset,
          (index << 2n) | BigInt(0b10),
        );
        return serializeVarint(dataView, offset, BigInt(payloadSize));
      }}
  }}
}}

function deserializeFieldHeader(
  dataView: DataView,
  offset: number,
): [number, bigint, number] {{
  const [newOffset, tag] = deserializeVarint(dataView, offset);
  offset = newOffset;

  const index = tag >> 2n;

  let size;
  switch (tag & 3n) {{
    case 0n:
      size = 0;
      break;
    case 1n:
      size = 8;
      break;
    case 2n:
      const [newNewOffset, sizeValue] = deserializeVarint(dataView, offset);
      offset = newNewOffset;
      size = Number(sizeValue);
      break;
    default:
      size = varintSizeFromFirstByte(dataView.getUint8(offset));
      break;
  }}

  return [offset, index, size];
}}

const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();",
            typical_version,
        )
        .unwrap();

        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        writeln!(&mut buffer).unwrap();

        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        write_module_contents(
            &mut buffer,
            0,
            &schema::Namespace { components: vec![] },
            &tree.children,
            &tree.schema,
        )
        .unwrap();
    }

    buffer
}

// Insert a schema into a module.
fn insert_schema(module: &mut Module, namespace: &schema::Namespace, schema: &schema::Schema) {
    let mut iter = namespace.components.iter();

    if let Some(head) = iter.next() {
        if let Some(child) = module.children.get_mut(head) {
            insert_schema(
                child,
                &schema::Namespace {
                    components: iter.cloned().collect(),
                },
                schema,
            );
        } else {
            let mut child = Module {
                children: BTreeMap::new(),
                schema: schema::Schema {
                    comment: vec![],
                    imports: BTreeMap::new(),
                    declarations: vec![],
                },
            };

            insert_schema(
                &mut child,
                &schema::Namespace {
                    components: iter.cloned().collect(),
                },
                schema,
            );

            module.children.insert(head.clone(), child);
        }
    } else {
        module.schema = schema.clone();
    }
}

// Write a module, including a trailing line break.
fn write_module<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    name: &Identifier,
    module: &Module,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    write!(buffer, "export namespace ")?;
    write_identifier(buffer, name, Pascal, None)?;
    writeln!(buffer, " {{")?;

    let mut new_namespace = namespace.clone();
    new_namespace.components.push(name.clone());

    write_module_contents(
        buffer,
        indentation + 1,
        &new_namespace,
        &module.children,
        &module.schema,
    )?;

    write_indentation(buffer, indentation)?;
    writeln!(buffer, "}}")?;

    Ok(())
}

// Write the contents of a module, including a trailing line break if there was anything to render.
fn write_module_contents<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    children: &BTreeMap<Identifier, Module>,
    schema: &schema::Schema,
) -> Result<(), fmt::Error> {
    let schema_empty = schema.declarations.is_empty();

    for (i, (child_name, child)) in children.iter().enumerate() {
        write_module(buffer, indentation, namespace, child_name, child)?;

        if i < children.len() - 1 || !schema_empty {
            writeln!(buffer)?;
        }
    }

    write_schema(buffer, indentation, namespace, schema)?;

    Ok(())
}

// Write a schema, including a trailing line break if there was anything to render.
#[allow(clippy::too_many_lines)]
fn write_schema<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    schema: &schema::Schema,
) -> Result<(), fmt::Error> {
    // Construct a map from import name to namespace.
    let mut imports = BTreeMap::new();
    for (name, import) in &schema.imports {
        // The unwrap is safe due to [ref:namespace_populated].
        imports.insert(name.clone(), import.namespace.clone().unwrap());
    }

    // Write the declarations.
    let mut iter = schema.declarations.iter().peekable();
    while let Some(declaration) = iter.next() {
        match &declaration.variant {
            schema::DeclarationVariant::Struct => {
                write_struct(
                    buffer,
                    indentation,
                    &imports,
                    namespace,
                    &declaration.name,
                    &declaration.fields,
                    Out,
                )?;

                writeln!(buffer)?;

                write_struct(
                    buffer,
                    indentation,
                    &imports,
                    namespace,
                    &declaration.name,
                    &declaration.fields,
                    In,
                )?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "export namespace ")?;
                write_identifier(buffer, &declaration.name, Pascal, None)?;
                writeln!(buffer, " {{")?;

                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "export function size(value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                writeln!(buffer, "): number {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "let valueSize = 0;")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "let payloadSize = 0;")?;
                for field in &declaration.fields {
                    writeln!(buffer)?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "{{")?;
                    write_indentation(buffer, indentation + 3)?;
                    write!(buffer, "const payload = value.")?;
                    write_identifier(buffer, &field.name, Camel, None)?;
                    writeln!(buffer, ";")?;
                    match field.rule {
                        schema::Rule::Asymmetric | schema::Rule::Required => {
                            write_size_calculation(
                                buffer,
                                indentation + 3,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                        }
                        schema::Rule::Optional => {
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(buffer, "if (payload === undefined) {{")?;
                            write_indentation(buffer, indentation + 4)?;
                            writeln!(buffer, "payloadSize = 0;")?;
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(buffer, "}} else {{")?;
                            write_size_calculation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(buffer, "}}")?;
                        }
                    }
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(
                        buffer,
                        "valueSize += fieldHeaderSize({}n, payloadSize, {}) + payloadSize;",
                        field.index,
                        integer_encoded(&field.r#type),
                    )?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                }
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "return valueSize;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "export function serialize(")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "dataView: DataView,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "offset: number,")?;
                write_indentation(buffer, indentation + 2)?;
                write!(buffer, "value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                writeln!(buffer, ",")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "): number {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "let payloadSize = 0;")?;
                for field in &declaration.fields {
                    writeln!(buffer)?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "{{")?;
                    write_indentation(buffer, indentation + 3)?;
                    write!(buffer, "const payload = value.")?;
                    write_identifier(buffer, &field.name, Camel, None)?;
                    writeln!(buffer, ";")?;
                    match field.rule {
                        schema::Rule::Asymmetric | schema::Rule::Required => {
                            write_size_calculation(
                                buffer,
                                indentation + 3,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(
                                buffer,
                                "offset = serializeFieldHeader(dataView, offset, {}n, \
                                    payloadSize, {});",
                                field.index,
                                integer_encoded(&field.r#type),
                            )?;
                            write_serialization_invocation(
                                buffer,
                                indentation + 3,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                        }
                        schema::Rule::Optional => {
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(buffer, "if (payload !== undefined) {{")?;
                            write_size_calculation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                            write_indentation(buffer, indentation + 4)?;
                            writeln!(
                                buffer,
                                "offset = serializeFieldHeader(dataView, offset, {}n, \
                                    payloadSize, {});",
                                field.index,
                                integer_encoded(&field.r#type),
                            )?;
                            write_serialization_invocation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(buffer, "}}")?;
                        }
                    }
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                }
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "return offset;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "export function deserialize(")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "dataView: DataView,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "offset: number,")?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "): [number, ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(In))?;
                writeln!(buffer, "] {{")?;
                if !declaration.fields.is_empty() {
                    write_indentation(buffer, indentation + 2)?;
                    write!(buffer, "let ")?;
                    let mut first = true;
                    for field in &declaration.fields {
                        if first {
                            first = false;
                        } else {
                            write!(buffer, ", ")?;
                        }
                        write_identifier(buffer, &field.name, Camel, None)?;
                        write!(buffer, "Field")?;
                    }
                    writeln!(buffer, ";")?;
                    writeln!(buffer)?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "while (true) {{")?;
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "let index, payloadSize;")?;
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "try {{")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(
                        buffer,
                        "[offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);",
                    )?;
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "}} catch (e) {{")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "if (e instanceof RangeError) {{")?;
                    write_indentation(buffer, indentation + 5)?;
                    writeln!(buffer, "break;")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "}} else {{")?;
                    write_indentation(buffer, indentation + 5)?;
                    writeln!(buffer, "throw e;")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "}}")?;
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "}}")?;
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "switch (index) {{")?;
                    for field in &declaration.fields {
                        write_indentation(buffer, indentation + 4)?;
                        writeln!(buffer, "case {}n: {{", field.index)?;
                        if !matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                            write_deserialization_invocation(
                                buffer,
                                indentation + 5,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                            write_indentation(buffer, indentation + 5)?;
                            write_identifier(buffer, &field.name, Camel, None)?;
                            writeln!(buffer, "Field = payload;")?;
                        }
                        write_indentation(buffer, indentation + 4)?;
                        writeln!(buffer, "}}")?;
                    }
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "default:")?;
                    write_indentation(buffer, indentation + 5)?;
                    writeln!(buffer, "offset += payloadSize;")?;
                    write_indentation(buffer, indentation + 5)?;
                    writeln!(buffer, "break;")?;
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "}}")?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                    writeln!(buffer)?;
                    if declaration.fields.iter().any(|field| match field.rule {
                        schema::Rule::Asymmetric | schema::Rule::Optional => false,
                        schema::Rule::Required => {
                            !matches!(field.r#type.variant, schema::TypeVariant::Unit)
                        }
                    }) {
                        write_indentation(buffer, indentation + 2)?;
                        write!(buffer, "if (")?;
                        first = true;
                        for field in &declaration.fields {
                            match field.rule {
                                schema::Rule::Asymmetric | schema::Rule::Optional => {}
                                schema::Rule::Required => {
                                    if !matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                                        if first {
                                            first = false;
                                        } else {
                                            write!(buffer, " || ")?;
                                        }
                                        write_identifier(buffer, &field.name, Camel, None)?;
                                        write!(buffer, "Field === undefined")?;
                                    }
                                }
                            }
                        }
                        writeln!(buffer, ") {{")?;
                        write_indentation(buffer, indentation + 3)?;
                        writeln!(
                            buffer,
                            "throw new Error('Struct missing one or more field(s).');",
                        )?;
                        write_indentation(buffer, indentation + 2)?;
                        writeln!(buffer, "}}")?;
                        writeln!(buffer)?;
                    }
                }
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "return [")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "offset,")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "{{")?;
                for field in &declaration.fields {
                    write_indentation(buffer, indentation + 4)?;
                    write_identifier(buffer, &field.name, Camel, None)?;
                    write!(buffer, ": ")?;
                    write_identifier(buffer, &field.name, Camel, None)?;
                    writeln!(buffer, "Field,")?;
                }
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "];")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "export function outToIn(value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                write!(buffer, "): ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(In))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "return value;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;

                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;
            }
            schema::DeclarationVariant::Choice => {
                write_choice(
                    buffer,
                    indentation,
                    &imports,
                    namespace,
                    &declaration.name,
                    &declaration.fields,
                    Out,
                )?;

                writeln!(buffer)?;

                write_choice(
                    buffer,
                    indentation,
                    &imports,
                    namespace,
                    &declaration.name,
                    &declaration.fields,
                    In,
                )?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "export namespace ")?;
                write_identifier(buffer, &declaration.name, Pascal, None)?;
                writeln!(buffer, " {{")?;

                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "export function size(value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                writeln!(buffer, "): number {{")?;
                write_indentation(buffer, indentation + 2)?;
                if declaration.fields.is_empty() {
                    writeln!(buffer, "return 0;")?;
                } else {
                    writeln!(buffer, "let payloadSize = 0;")?;
                    writeln!(buffer)?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "switch (value.field) {{")?;
                    for field in &declaration.fields {
                        write_indentation(buffer, indentation + 3)?;
                        write!(buffer, "case '")?;
                        write_identifier(buffer, &field.name, Camel, None)?;
                        writeln!(buffer, "': {{")?;
                        if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                        } else {
                            write_indentation(buffer, indentation + 4)?;
                            writeln!(buffer, "const payload = value.value;")?;
                            write_size_calculation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                        }
                        write_indentation(buffer, indentation + 4)?;
                        write!(
                            buffer,
                            "return fieldHeaderSize({}n, payloadSize, {}) + payloadSize",
                            field.index,
                            integer_encoded(&field.r#type),
                        )?;
                        match field.rule {
                            schema::Rule::Asymmetric | schema::Rule::Optional => {
                                writeln!(buffer, " + size(value.fallback);")?;
                            }
                            schema::Rule::Required => {
                                writeln!(buffer, ";")?;
                            }
                        }
                        write_indentation(buffer, indentation + 3)?;
                        writeln!(buffer, "}}")?;
                    }
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "default:")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "return unreachable(value);")?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                }
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "export function serialize(")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "dataView: DataView,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "offset: number,")?;
                write_indentation(buffer, indentation + 2)?;
                write!(buffer, "value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                writeln!(buffer, ",")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "): number {{")?;
                write_indentation(buffer, indentation + 2)?;
                if declaration.fields.is_empty() {
                    writeln!(buffer, "return offset;")?;
                } else {
                    writeln!(buffer, "let payloadSize = 0;")?;
                    writeln!(buffer)?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "switch (value.field) {{")?;
                    for field in &declaration.fields {
                        write_indentation(buffer, indentation + 3)?;
                        write!(buffer, "case '")?;
                        write_identifier(buffer, &field.name, Camel, None)?;
                        writeln!(buffer, "': {{")?;
                        write_indentation(buffer, indentation + 4)?;
                        if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                            writeln!(
                                buffer,
                                "offset = serializeFieldHeader(dataView, offset, {}n, 0, {});",
                                field.index,
                                integer_encoded(&field.r#type),
                            )?;
                        } else {
                            writeln!(buffer, "const payload = value.value;")?;
                            write_size_calculation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                            write_indentation(buffer, indentation + 4)?;
                            writeln!(
                                buffer,
                                "offset = serializeFieldHeader(dataView, offset, {}n, \
                                    payloadSize, {});",
                                field.index,
                                integer_encoded(&field.r#type),
                            )?;
                            write_serialization_invocation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                        }
                        match field.rule {
                            schema::Rule::Asymmetric | schema::Rule::Optional => {
                                write_indentation(buffer, indentation + 4)?;
                                writeln!(
                                    buffer,
                                    "offset = serialize(dataView, offset, value.fallback);",
                                )?;
                            }
                            schema::Rule::Required => {}
                        }
                        write_indentation(buffer, indentation + 4)?;
                        writeln!(buffer, "return offset;")?;
                        write_indentation(buffer, indentation + 3)?;
                        writeln!(buffer, "}}")?;
                    }
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(buffer, "default:")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "return unreachable(value);")?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                }
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "export function deserialize(")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "dataView: DataView,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "offset: number,")?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "): [number, ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(In))?;
                writeln!(buffer, "] {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "while (true) {{")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(
                    buffer,
                    "const [newOffset, index, payloadSize] = \
                        deserializeFieldHeader(dataView, offset);",
                )?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "offset = newOffset;")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "switch (index) {{")?;
                for field in &declaration.fields {
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "case {}n: {{", field.index)?;
                    if !matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                        write_deserialization_invocation(
                            buffer,
                            indentation + 5,
                            &imports,
                            namespace,
                            &field.r#type.variant,
                            true,
                        )?;
                    }
                    match field.rule {
                        schema::Rule::Asymmetric | schema::Rule::Required => {}
                        schema::Rule::Optional => {
                            write_indentation(buffer, indentation + 5)?;
                            writeln!(
                                buffer,
                                "const [newNewOffset, fallback] = deserialize(dataView, offset);",
                            )?;
                            write_indentation(buffer, indentation + 5)?;
                            writeln!(buffer, "offset = newNewOffset;")?;
                        }
                    }
                    write_indentation(buffer, indentation + 5)?;
                    writeln!(buffer, "return [")?;
                    write_indentation(buffer, indentation + 6)?;
                    writeln!(buffer, "offset,")?;
                    write_indentation(buffer, indentation + 6)?;
                    writeln!(buffer, "{{")?;
                    write_indentation(buffer, indentation + 7)?;
                    write!(buffer, "field: '")?;
                    write_identifier(buffer, &field.name, Camel, None)?;
                    writeln!(buffer, "',")?;
                    if !matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                        write_indentation(buffer, indentation + 7)?;
                        writeln!(buffer, "value: payload,")?;
                    }
                    match field.rule {
                        schema::Rule::Asymmetric | schema::Rule::Required => {}
                        schema::Rule::Optional => {
                            write_indentation(buffer, indentation + 7)?;
                            writeln!(buffer, "fallback,")?;
                        }
                    }
                    write_indentation(buffer, indentation + 6)?;
                    writeln!(buffer, "}},")?;
                    write_indentation(buffer, indentation + 5)?;
                    writeln!(buffer, "];")?;
                    write_indentation(buffer, indentation + 4)?;
                    writeln!(buffer, "}}")?;
                }
                write_indentation(buffer, indentation + 4)?;
                writeln!(buffer, "default:")?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "offset += payloadSize;")?;
                write_indentation(buffer, indentation + 5)?;
                writeln!(buffer, "break;")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "export function outToIn(value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                write!(buffer, "): ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(In))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "return value;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;
            }
        }

        if iter.peek().is_some() {
            writeln!(buffer)?;
        }
    }

    Ok(())
}

// Write a struct, including a trailing line break.
fn write_struct<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    name: &Identifier,
    fields: &[schema::Field],
    direction: Direction,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    write!(buffer, "export type ")?;
    write_identifier(buffer, name, Pascal, Some(direction))?;
    writeln!(buffer, " = {{")?;

    for field in fields {
        write_indentation(buffer, indentation + 1)?;
        write_identifier(buffer, &field.name, Camel, None)?;
        match field.rule {
            schema::Rule::Asymmetric => match direction {
                Direction::Out => {}
                Direction::In => {
                    write!(buffer, "?")?;
                }
            },
            schema::Rule::Optional => {
                write!(buffer, "?")?;
            }
            schema::Rule::Required => {}
        }
        write!(buffer, ": ")?;
        write_type(buffer, imports, namespace, &field.r#type.variant, direction)?;
        writeln!(buffer, ";")?;
    }

    write_indentation(buffer, indentation)?;
    writeln!(buffer, "}};")?;

    Ok(())
}

// Write a choice, including a trailing line break.
fn write_choice<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    name: &Identifier,
    fields: &[schema::Field],
    direction: Direction,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    write!(buffer, "export type ")?;
    write_identifier(buffer, name, Pascal, Some(direction))?;
    write!(buffer, " =")?;

    for field in fields {
        writeln!(buffer)?;
        write_indentation(buffer, indentation + 1)?;
        write!(buffer, "| {{ field: '")?;
        write_identifier(buffer, &field.name, Camel, None)?;
        write!(buffer, "'")?;
        let fallback = match field.rule {
            schema::Rule::Asymmetric => match direction {
                Direction::Out => true,
                Direction::In => false,
            },
            schema::Rule::Optional => true,
            schema::Rule::Required => false,
        };
        if fallback {
            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
            } else {
                write!(buffer, "; value: ")?;
                write_type(buffer, imports, namespace, &field.r#type.variant, direction)?;
            }
            write!(buffer, "; fallback: ")?;
            write_identifier(buffer, name, Pascal, Some(direction))?;
        } else if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
        } else {
            write!(buffer, "; value: ")?;
            write_type(buffer, imports, namespace, &field.r#type.variant, direction)?;
        }
        write!(buffer, " }}")?;
    }

    // See https://github.com/microsoft/TypeScript/issues/46978#issuecomment-984093435 for an
    // explanation of this extra case.
    if fields.len() == 1 {
        writeln!(buffer)?;
        write_indentation(buffer, indentation + 1)?;
        write!(buffer, "| {{ field: never }}")?;
    }

    if fields.is_empty() {
        write!(buffer, " never")?;
    }

    writeln!(buffer, ";")?;

    Ok(())
}

// Write a type.
fn write_type<T: Write>(
    buffer: &mut T,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    type_variant: &schema::TypeVariant,
    direction: Direction,
) -> Result<(), fmt::Error> {
    match type_variant {
        schema::TypeVariant::Array(inner_type) => {
            write_type(buffer, imports, namespace, &inner_type.variant, direction)?;
            write!(buffer, "[]")?;
        }
        schema::TypeVariant::Bool => {
            write!(buffer, "boolean")?;
        }
        schema::TypeVariant::Bytes => {
            write!(buffer, "ArrayBuffer")?;
        }
        schema::TypeVariant::Custom(import, name) => {
            write_custom_type(buffer, imports, namespace, import, name, Some(direction))?;
        }
        schema::TypeVariant::F64 => {
            write!(buffer, "number")?;
        }
        schema::TypeVariant::S64 | schema::TypeVariant::U64 => {
            write!(buffer, "bigint")?;
        }
        schema::TypeVariant::String => {
            write!(buffer, "string")?;
        }
        schema::TypeVariant::Unit => {
            write!(buffer, "undefined")?;
        }
    }

    Ok(())
}

// Write the fully qualified name of a type.
fn write_custom_type<T: Write>(
    buffer: &mut T,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    import: &Option<Identifier>,
    name: &Identifier,
    direction: Option<Direction>,
) -> Result<(), fmt::Error> {
    let type_namespace = schema::Namespace {
        components: import.as_ref().map_or_else(
            || namespace.components.clone(),
            |import| imports[import].components.clone(),
        ),
    };

    for component in type_namespace.components {
        write_identifier(buffer, &component, Pascal, None)?;
        write!(buffer, ".")?;
    }

    write_identifier(buffer, name, Pascal, direction)
}

// Write an identifier with an optional direction suffix in a way that Rust will be happy with.
fn write_identifier<T: Write>(
    buffer: &mut T,
    identifier: &Identifier,
    case: CaseConvention,
    suffix: Option<Direction>,
) -> Result<(), fmt::Error> {
    let identifier_with_suffix = suffix.map_or_else(
        || identifier.clone(),
        |suffix| {
            identifier.join(
                &match suffix {
                    Direction::In => "In",
                    Direction::Out => "Out",
                }
                .into(),
            )
        },
    );

    let converted_identifier = match case {
        CaseConvention::Camel => identifier_with_suffix.camel_case(),
        CaseConvention::Pascal => identifier_with_suffix.pascal_case(),
    };

    if TYPESCRIPT_KEYWORDS
        .iter()
        .any(|keyword| converted_identifier == *keyword)
    {
        write!(buffer, "_")?;
    }

    write!(buffer, "{}", converted_identifier)?;

    Ok(())
}

// Write the given level of indentation.
fn write_indentation<T: Write>(buffer: &mut T, indentation: usize) -> Result<(), fmt::Error> {
    for _ in 0..indentation {
        write!(buffer, "{}", INDENTATION)?;
    }

    Ok(())
}

// Write the logic to invoke the size calculation logic for a value.
//
// Context variables:
// - `payloadSize`
// - `payload`
#[allow(clippy::too_many_lines)]
fn write_size_calculation<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    type_variant: &schema::TypeVariant,
    is_field: bool,
) -> Result<(), fmt::Error> {
    match type_variant {
        schema::TypeVariant::Array(inner_type) => match &inner_type.variant {
            schema::TypeVariant::Array(_)
            | schema::TypeVariant::Bytes
            | schema::TypeVariant::Custom(_, _)
            | schema::TypeVariant::String => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "let arraySize = 0;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const oldPayload = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "for (let i = 0; i < oldPayload.length; ++i) {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "const payload = oldPayload[i];")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "let payloadSize = 0;")?;
                write_size_calculation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(
                    buffer,
                    "arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;",
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = arraySize;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Bool | schema::TypeVariant::S64 | schema::TypeVariant::U64 => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "let arraySize = 0;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const oldPayload = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "for (let i = 0; i < oldPayload.length; ++i) {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "const payload = oldPayload[i];")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "let payloadSize = 0;")?;
                write_size_calculation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "arraySize += payloadSize;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = arraySize;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::F64 => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "payloadSize = 8 * payload.length;")
            }
            schema::TypeVariant::Unit => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const oldPayload = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "const payload = BigInt(oldPayload.length);")?;
                write_size_calculation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &schema::TypeVariant::U64,
                    is_field,
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
        },
        schema::TypeVariant::Bool => {
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "if (payload) {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 1;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}} else {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 0;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(buffer, "payloadSize = 1;")
            }
        }
        schema::TypeVariant::Bytes => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "payloadSize = payload.byteLength;")
        }
        schema::TypeVariant::String => {
            write_indentation(buffer, indentation)?;
            writeln!(
                buffer,
                "payloadSize = textEncoder.encode(payload).byteLength;",
            )
        }
        schema::TypeVariant::Custom(import, name) => {
            write_indentation(buffer, indentation)?;
            write!(buffer, "payloadSize = ")?;
            write_custom_type(buffer, imports, namespace, import, name, None)?;
            writeln!(buffer, ".size(payload);")
        }
        schema::TypeVariant::F64 => {
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "dataView64.setFloat64(0, payload, true);")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "if (dataView64.getBigUint64(0, true) === 0n) {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 0;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}} else {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 8;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(buffer, "payloadSize = 8;")
            }
        }
        schema::TypeVariant::S64 => {
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const zigzag = zigzagEncode(payload);")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "if (zigzag === 0n) {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "payloadSize = 0;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}} else if (zigzag < 567_382_630_219_904n) {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "payloadSize = varintSizeFromValue(zigzag);")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}} else {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "payloadSize = 8;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(
                    buffer,
                    "payloadSize = varintSizeFromValue(zigzagEncode(payload));",
                )
            }
        }
        schema::TypeVariant::U64 => {
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "if (payload === 0n) {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 0;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}} else if (payload < 567_382_630_219_904n) {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = varintSizeFromValue(payload);")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}} else {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 8;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(buffer, "payloadSize = varintSizeFromValue(payload);")
            }
        }
        schema::TypeVariant::Unit => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "payloadSize = 0;")
        }
    }
}

// Write the logic to invoke the serialization logic for a value, including a trailing line break.
//
// Context variables:
// - `dataView`
// - `offset`
// - `payloadSize`
// - `payload`
#[allow(clippy::too_many_lines)]
fn write_serialization_invocation<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    type_variant: &schema::TypeVariant,
    is_field: bool,
) -> Result<(), fmt::Error> {
    match type_variant {
        schema::TypeVariant::Array(inner_type) => match &inner_type.variant {
            schema::TypeVariant::Array(_)
            | schema::TypeVariant::Bytes
            | schema::TypeVariant::Custom(_, _)
            | schema::TypeVariant::String => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const oldPayload = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "for (const payload of oldPayload) {{")?;
                write_size_calculation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(
                    buffer,
                    "offset = serializeVarint(dataView, offset, BigInt(payloadSize));",
                )?;
                write_serialization_invocation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Bool
            | schema::TypeVariant::S64
            | schema::TypeVariant::U64
            | schema::TypeVariant::F64 => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const oldPayload = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "for (const payload of oldPayload) {{")?;
                write_size_calculation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_serialization_invocation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Unit => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const varint = BigInt(payload.length);")?;
                write_u64_serialization_invocation(buffer, indentation + 1, is_field)?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
        },
        schema::TypeVariant::Bool => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "{{")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "const varint = payload ? 1n : 0n;")?;
            write_u64_serialization_invocation(buffer, indentation + 1, is_field)?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "}}")
        }
        schema::TypeVariant::Bytes => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "{{")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "const buffer = new Uint8Array(payload);")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "for (let i = 0; i < buffer.byteLength; ++i) {{")?;
            write_indentation(buffer, indentation + 2)?;
            writeln!(buffer, "dataView.setUint8(offset + i, buffer[i]);")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "}}")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "offset += buffer.byteLength;")?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "}}")
        }
        schema::TypeVariant::Custom(import, name) => {
            write_indentation(buffer, indentation)?;
            write!(buffer, "offset = ")?;
            write_custom_type(buffer, imports, namespace, import, name, None)?;
            writeln!(buffer, ".serialize(dataView, offset, payload);")
        }
        schema::TypeVariant::F64 => {
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "if (payloadSize !== 0) {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "dataView.setFloat64(offset, payload, true);")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(buffer, "dataView.setFloat64(offset, payload, true);")
            }
        }
        schema::TypeVariant::S64 => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "{{")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "const varint = zigzagEncode(payload);")?;
            write_u64_serialization_invocation(buffer, indentation + 1, is_field)?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "}}")
        }
        schema::TypeVariant::String => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "{{")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "const buffer = textEncoder.encode(payload);")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "for (let i = 0; i < buffer.byteLength; ++i) {{")?;
            write_indentation(buffer, indentation + 2)?;
            writeln!(buffer, "dataView.setUint8(offset + i, buffer[i]);")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "}}")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "offset += buffer.byteLength;")?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "}}")
        }
        schema::TypeVariant::U64 => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "{{")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "const varint = payload;")?;
            write_u64_serialization_invocation(buffer, indentation + 1, is_field)?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "}}")
        }
        schema::TypeVariant::Unit => Ok(()),
    }
}

// Write the logic to invoke the serialization logic for a varint, including a trailing line break.
//
// Context variables:
// - `dataView`
// - `offset`
// - `varint`
fn write_u64_serialization_invocation<T: Write>(
    buffer: &mut T,
    indentation: usize,
    is_field: bool,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    if is_field {
        writeln!(buffer, "if (varint > 567_382_630_219_903n) {{")?;
        write_indentation(buffer, indentation + 1)?;
        writeln!(buffer, "dataView.setBigUint64(offset, varint, true);")?;
        write_indentation(buffer, indentation + 1)?;
        writeln!(buffer, "offset += 8;")?;
        write_indentation(buffer, indentation)?;
        writeln!(buffer, "}} else if (varint !== 0n) {{")?;
        write_indentation(buffer, indentation + 1)?;
        writeln!(
            buffer,
            "offset = serializeVarint(dataView, offset, varint);",
        )?;
        write_indentation(buffer, indentation)?;
        writeln!(buffer, "}}")
    } else {
        writeln!(
            buffer,
            "offset = serializeVarint(dataView, offset, varint);",
        )
    }
}

// Write the logic to invoke the deserialization logic for a value, including a trailing line break.
//
// Context variables:
// - `dataView`
// - `offset`
// - `payloadSize`
// - `payload` (introduced)
//
// This function introduces the `payload` variable with `let` rather than `const`, since it relies
// on being able to mutate the `payload` from a recursive call.
#[allow(clippy::too_many_lines)]
fn write_deserialization_invocation<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    type_variant: &schema::TypeVariant,
    is_field: bool,
) -> Result<(), fmt::Error> {
    match type_variant {
        schema::TypeVariant::Array(inner_type) => match &inner_type.variant {
            schema::TypeVariant::Array(_)
            | schema::TypeVariant::Bytes
            | schema::TypeVariant::Custom(_, _)
            | schema::TypeVariant::String => {
                write_indentation(buffer, indentation)?;
                write!(buffer, "let payload: ")?;
                write_type(buffer, imports, namespace, &inner_type.variant, In)?;
                writeln!(buffer, "[] = [];")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "let payloadAlias = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "while (true) {{")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "let payloadSizeBig;")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(
                    buffer,
                    "[offset, payloadSizeBig] = deserializeVarint(dataView, offset);",
                )?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "const payloadSize = Number(payloadSizeBig);")?;
                write_deserialization_invocation(
                    buffer,
                    indentation + 3,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "payloadAlias.push(payload);")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Bool
            | schema::TypeVariant::S64
            | schema::TypeVariant::U64
            | schema::TypeVariant::F64 => {
                write_indentation(buffer, indentation)?;
                write!(buffer, "let payload: ")?;
                write_type(buffer, imports, namespace, &inner_type.variant, In)?;
                writeln!(buffer, "[] = [];")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "let payloadAlias = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "while (true) {{")?;
                write_deserialization_invocation(
                    buffer,
                    indentation + 3,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "payloadAlias.push(payload);")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Unit => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "let payload;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "let newPayload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const payloadSize: number = 0;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "{{")?;
                write_deserialization_invocation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &schema::TypeVariant::U64,
                    is_field,
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(
                    buffer,
                    "newPayload = Array(Number(payload)).fill(undefined);",
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payload = newPayload;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
        },
        schema::TypeVariant::Bool => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "let payload;")?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "{{")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "let newPayload;")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "{{")?;
            write_deserialization_invocation(
                buffer,
                indentation + 2,
                imports,
                namespace,
                &schema::TypeVariant::U64,
                is_field,
            )?;
            write_indentation(buffer, indentation + 2)?;
            writeln!(buffer, "newPayload = payload !== 0n;")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "}}")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "payload = newPayload;")?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "}}")
        }
        schema::TypeVariant::Bytes => {
            write_indentation(buffer, indentation)?;
            writeln!(
                buffer,
                "let payload = dataView.buffer.slice(offset, offset + payloadSize);",
            )?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "offset += payloadSize;")
        }
        schema::TypeVariant::Custom(import, name) => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "let payload;")?;
            write_indentation(buffer, indentation)?;
            write!(buffer, "[offset, payload] = ")?;
            write_custom_type(buffer, imports, namespace, import, name, None)?;
            writeln!(buffer, ".deserialize(dataView, offset);")
        }
        schema::TypeVariant::F64 => {
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "let payload;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "switch (payloadSize) {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "case 0:")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "payload = 0;")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "break;")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "default:")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "payload = dataView.getFloat64(offset, true);")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "offset += 8;")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "break;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(buffer, "let payload = dataView.getFloat64(offset, true);")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "offset += 8;")
            }
        }
        schema::TypeVariant::S64 => {
            write_deserialization_invocation(
                buffer,
                indentation,
                imports,
                namespace,
                &schema::TypeVariant::U64,
                is_field,
            )?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "payload = zigzagDecode(payload);")
        }
        schema::TypeVariant::String => {
            write_indentation(buffer, indentation)?;
            writeln!(
                buffer,
                "let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                    payloadSize));",
            )?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "offset += payloadSize;")
        }
        schema::TypeVariant::U64 => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "let payload;")?;
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "switch (payloadSize) {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "case 0:")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "payload = 0n;")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "break;")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "case 8:")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "payload = dataView.getBigUint64(offset, true);")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "offset += 8;")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "break;")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "default:")?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(
                    buffer,
                    "[offset, payload] = deserializeVarint(dataView, offset);",
                )?;
                write_indentation(buffer, indentation + 3)?;
                writeln!(buffer, "break;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(
                    buffer,
                    "[offset, payload] = deserializeVarint(dataView, offset);",
                )
            }
        }
        schema::TypeVariant::Unit => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "let payload = undefined;")
        }
    }
}

// Determine whether a type is encoded as a varint.
fn integer_encoded(r#type: &schema::Type) -> bool {
    match &r#type.variant {
        schema::TypeVariant::Bool | schema::TypeVariant::S64 | schema::TypeVariant::U64 => true,
        schema::TypeVariant::Array(_)
        | schema::TypeVariant::Bytes
        | schema::TypeVariant::Custom(_, _)
        | schema::TypeVariant::F64
        | schema::TypeVariant::String
        | schema::TypeVariant::Unit => false,
    }
}

#[cfg(test)]
mod tests {
    use {
        crate::{generate_typescript::generate, schema_loader::load_schemas, validator::validate},
        std::path::Path,
    };

    #[allow(clippy::too_many_lines)]
    #[test]
    fn generate_example() {
        let schemas = load_schemas(Path::new("integration_tests/types/main.t")).unwrap();
        validate(&schemas).unwrap();

        assert_eq!(
            generate("0.0.0", &schemas),
            "\
// This file was automatically generated by Typical 0.0.0.
// Visit https://github.com/stepchowfun/typical for more information.

/* eslint-disable */

export function unreachable(x: never): never {
  return x;
}

function zigzagEncode(value: bigint): bigint {
  const twice = value << 1n;
  return value < 0n ? -1n - twice : twice;
}

function zigzagDecode(value: bigint): bigint {
  const half = (value + 1n) >> 1n;
  return (value & 1n) === 0n ? half : -half;
}

function varintSizeFromValue(value: bigint): number {
  if (value < 128n) {
    return 1;
  } else if (value < 16_512n) {
    return 2;
  } else if (value < 2_113_664n) {
    return 3;
  } else if (value < 270_549_120n) {
    return 4;
  } else if (value < 34_630_287_488n) {
    return 5;
  } else if (value < 4_432_676_798_592n) {
    return 6;
  } else if (value < 567_382_630_219_904n) {
    return 7;
  } else if (value < 72_624_976_668_147_840n) {
    return 8;
  } else {
    return 9;
  }
}

function varintSizeFromFirstByte(firstByte: number): number {
  let trailingZeros = 0;

  while (trailingZeros < 8 && (firstByte & 1) !== 1) {
    ++trailingZeros;
    firstByte >>= 1;
  }

  return trailingZeros + 1;
}

const dataView64 = new DataView(new ArrayBuffer(8));

function serializeVarint(
  dataView: DataView,
  offset: number,
  value: bigint,
): number {
  if (value < 128n) {
    dataView.setUint8(offset, Number(value << 1n) | 0b0000_0001);
    return offset + 1;
  } else if (value < 16_512n) {
    value -= 128n;
    dataView.setUint8(offset, Number((value << 2n) % 256n) | 0b0000_0010);
    dataView.setUint8(offset + 1, Number(value >> 6n));
    return offset + 2;
  } else if (value < 2_113_664n) {
    value -= 16_512n;
    dataView.setUint8(offset, Number((value << 3n) % 256n) | 0b0000_0100);
    dataView.setUint16(offset + 1, Number((value >> 5n) % 65_536n), true);
    return offset + 3;
  } else if (value < 270_549_120n) {
    value -= 2_113_664n;
    dataView.setUint8(offset, Number((value << 4n) % 256n) | 0b0000_1000);
    dataView.setUint8(offset + 1, Number((value >> 4n) % 256n));
    dataView.setUint16(offset + 2, Number((value >> 12n) % 65_536n), true);
    return offset + 4;
  } else if (value < 34_630_287_488n) {
    value -= 270_549_120n;
    dataView.setUint8(offset, Number((value << 5n) % 256n) | 0b0001_0000);
    dataView.setUint32(
      offset + 1,
      Number((value >> 3n) % 4_294_967_296n),
      true,
    );
    return offset + 5;
  } else if (value < 4_432_676_798_592n) {
    value -= 34_630_287_488n;
    dataView.setUint8(offset, Number((value << 6n) % 256n) | 0b0010_0000);
    dataView.setUint8(offset + 1, Number((value >> 2n) % 256n));
    dataView.setUint32(
      offset + 2,
      Number((value >> 10n) % 4_294_967_296n),
      true,
    );
    return offset + 6;
  } else if (value < 567_382_630_219_904n) {
    value -= 4_432_676_798_592n;
    dataView.setUint8(offset, Number((value << 7n) % 256n) | 0b0100_0000);
    dataView.setUint16(offset + 1, Number((value >> 1n) % 65_536n), true);
    dataView.setUint32(
      offset + 3,
      Number((value >> 17n) % 4_294_967_296n),
      true,
    );
    return offset + 7;
  } else if (value < 72_624_976_668_147_840n) {
    value -= 567_382_630_219_904n;
    dataView.setUint8(offset, 0b1000_0000);
    dataView.setUint8(offset + 1, Number(value % 256n));
    dataView.setUint16(offset + 2, Number((value >> 8n) % 65_536n), true);
    dataView.setUint32(
      offset + 4,
      Number((value >> 24n) % 4_294_967_296n),
      true,
    );
    return offset + 8;
  } else {
    value -= 72_624_976_668_147_840n;
    dataView.setUint8(offset, 0b0000_0000);
    dataView.setBigUint64(offset + 1, value, true);
    return offset + 9;
  }
}

function deserializeVarint(
  dataView: DataView,
  offset: number,
): [number, bigint] {
  const firstByte = dataView.getUint8(offset);
  const sizeMinusOne = varintSizeFromFirstByte(firstByte) - 1;
  const offsetPlusOne = offset + 1;
  dataView64.setBigUint64(offset, 0n, true);
  for (let i = 0; i < sizeMinusOne; ++i) {
    dataView64.setUint8(i, dataView.getUint8(offsetPlusOne + i));
  }
  const remainingBytesValue = dataView64.getBigUint64(0, true);
  switch (sizeMinusOne) {
    case 0:
      return [offset + 1, BigInt(firstByte >> 1)];
    case 1:
      return [
        offset + 2,
        128n + BigInt(firstByte >> 2) + (remainingBytesValue << 6n),
      ];
    case 2:
      return [
        offset + 3,
        16_512n + BigInt(firstByte >> 3) + (remainingBytesValue << 5n),
      ];
    case 3:
      return [
        offset + 4,
        2_113_664n + BigInt(firstByte >> 4) + (remainingBytesValue << 4n),
      ];
    case 4:
      return [
        offset + 5,
        270_549_120n + BigInt(firstByte >> 5) + (remainingBytesValue << 3n),
      ];
    case 5:
      return [
        offset + 6,
        34_630_287_488n + BigInt(firstByte >> 6) + (remainingBytesValue << 2n),
      ];
    case 6:
      return [
        offset + 7,
        4_432_676_798_592n +
          BigInt(firstByte >> 7) +
          (remainingBytesValue << 1n),
      ];
    case 7:
      return [offset + 8, 567_382_630_219_904n + remainingBytesValue];
    default:
      return [
        offset + 9,
        (72_624_976_668_147_840n + remainingBytesValue) %
          18_446_744_073_709_551_616n,
      ];
  }
}

function fieldHeaderSize(
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {
  switch (payloadSize) {
    case 0:
      return varintSizeFromValue((index << 2n) | BigInt(0b00));
    case 8:
      return varintSizeFromValue((index << 2n) | BigInt(0b01));
    default:
      if (integerEncoded) {
        return varintSizeFromValue((index << 2n) | BigInt(0b11));
      } else {
        return (
          varintSizeFromValue((index << 2n) | BigInt(0b10)) +
          varintSizeFromValue(BigInt(payloadSize))
        );
      }
  }
}

function serializeFieldHeader(
  dataView: DataView,
  offset: number,
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {
  switch (payloadSize) {
    case 0:
      return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b00));
    case 1:
      return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b01));
    default:
      if (integerEncoded) {
        return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b11));
      } else {
        offset = serializeVarint(
          dataView,
          offset,
          (index << 2n) | BigInt(0b10),
        );
        return serializeVarint(dataView, offset, BigInt(payloadSize));
      }
  }
}

function deserializeFieldHeader(
  dataView: DataView,
  offset: number,
): [number, bigint, number] {
  const [newOffset, tag] = deserializeVarint(dataView, offset);
  offset = newOffset;

  const index = tag >> 2n;

  let size;
  switch (tag & 3n) {
    case 0n:
      size = 0;
      break;
    case 1n:
      size = 8;
      break;
    case 2n:
      const [newNewOffset, sizeValue] = deserializeVarint(dataView, offset);
      offset = newNewOffset;
      size = Number(sizeValue);
      break;
    default:
      size = varintSizeFromFirstByte(dataView.getUint8(offset));
      break;
  }

  return [offset, index, size];
}

const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

export namespace CircularDependency {
  export namespace Dependency {
    export namespace Main {
      export type StructFromBelowOut = {
        x: CircularDependency.Main.StructFromAboveOut;
      };

      export type StructFromBelowIn = {
        x: CircularDependency.Main.StructFromAboveIn;
      };

      export namespace StructFromBelow {
        export function size(value: StructFromBelowOut): number {
          let valueSize = 0;
          let payloadSize = 0;

          {
            const payload = value.x;
            payloadSize = CircularDependency.Main.StructFromAbove.size(payload);
            valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }

          return valueSize;
        }

        export function serialize(
          dataView: DataView,
          offset: number,
          value: StructFromBelowOut,
        ): number {
          let payloadSize = 0;

          {
            const payload = value.x;
            payloadSize = CircularDependency.Main.StructFromAbove.size(payload);
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            offset = CircularDependency.Main.StructFromAbove.serialize(dataView, offset, payload);
          }

          return offset;
        }

        export function deserialize(
          dataView: DataView,
          offset: number,
        ): [number, StructFromBelowIn] {
          let xField;

          while (true) {
            let index, payloadSize;
            try {
              [offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
            } catch (e) {
              if (e instanceof RangeError) {
                break;
              } else {
                throw e;
              }
            }
            switch (index) {
              case 0n: {
                let payload;
                [offset, payload] = CircularDependency.Main.StructFromAbove.deserialize(dataView, \
                    offset);
                xField = payload;
              }
              default:
                offset += payloadSize;
                break;
            }
          }

          if (xField === undefined) {
            throw new Error('Struct missing one or more field(s).');
          }

          return [
            offset,
            {
              x: xField,
            }
          ];
        }

        export function outToIn(value: StructFromBelowOut): StructFromBelowIn {
          return value;
        }
      }
    }
  }

  export namespace Main {
    export type StructFromAboveOut = {
    };

    export type StructFromAboveIn = {
    };

    export namespace StructFromAbove {
      export function size(value: StructFromAboveOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: StructFromAboveOut,
      ): number {
        let payloadSize = 0;

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, StructFromAboveIn] {
        return [
          offset,
          {
          }
        ];
      }

      export function outToIn(value: StructFromAboveOut): StructFromAboveIn {
        return value;
      }
    }
  }
}

export namespace Comprehensive {
  export namespace Bar {
    export type BarOut =
      | { field: 'aRequired' }
      | { field: 'bRequired'; value: number }
      | { field: 'cRequired'; value: bigint }
      | { field: 'dRequired'; value: bigint }
      | { field: 'eRequired'; value: boolean }
      | { field: 'fRequired'; value: ArrayBuffer }
      | { field: 'gRequired'; value: string }
      | { field: 'hRequired'; value: undefined[] }
      | { field: 'iRequired'; value: number[] }
      | { field: 'jRequired'; value: bigint[] }
      | { field: 'kRequired'; value: bigint[] }
      | { field: 'lRequired'; value: boolean[] }
      | { field: 'mRequired'; value: ArrayBuffer[] }
      | { field: 'nRequired'; value: string[] }
      | { field: 'oRequired'; value: Comprehensive.Main.EmptyStructOut[][] }
      | { field: 'aAsymmetric'; fallback: BarOut }
      | { field: 'bAsymmetric'; value: number; fallback: BarOut }
      | { field: 'cAsymmetric'; value: bigint; fallback: BarOut }
      | { field: 'dAsymmetric'; value: bigint; fallback: BarOut }
      | { field: 'eAsymmetric'; value: boolean; fallback: BarOut }
      | { field: 'fAsymmetric'; value: ArrayBuffer; fallback: BarOut }
      | { field: 'gAsymmetric'; value: string; fallback: BarOut }
      | { field: 'hAsymmetric'; value: undefined[]; fallback: BarOut }
      | { field: 'iAsymmetric'; value: number[]; fallback: BarOut }
      | { field: 'jAsymmetric'; value: bigint[]; fallback: BarOut }
      | { field: 'kAsymmetric'; value: bigint[]; fallback: BarOut }
      | { field: 'lAsymmetric'; value: boolean[]; fallback: BarOut }
      | { field: 'mAsymmetric'; value: ArrayBuffer[]; fallback: BarOut }
      | { field: 'nAsymmetric'; value: string[]; fallback: BarOut }
      | { field: 'oAsymmetric'; value: Comprehensive.Main.EmptyStructOut[][]; fallback: BarOut }
      | { field: 'aOptional'; fallback: BarOut }
      | { field: 'bOptional'; value: number; fallback: BarOut }
      | { field: 'cOptional'; value: bigint; fallback: BarOut }
      | { field: 'dOptional'; value: bigint; fallback: BarOut }
      | { field: 'eOptional'; value: boolean; fallback: BarOut }
      | { field: 'fOptional'; value: ArrayBuffer; fallback: BarOut }
      | { field: 'gOptional'; value: string; fallback: BarOut }
      | { field: 'hOptional'; value: undefined[]; fallback: BarOut }
      | { field: 'iOptional'; value: number[]; fallback: BarOut }
      | { field: 'jOptional'; value: bigint[]; fallback: BarOut }
      | { field: 'kOptional'; value: bigint[]; fallback: BarOut }
      | { field: 'lOptional'; value: boolean[]; fallback: BarOut }
      | { field: 'mOptional'; value: ArrayBuffer[]; fallback: BarOut }
      | { field: 'nOptional'; value: string[]; fallback: BarOut }
      | { field: 'oOptional'; value: Comprehensive.Main.EmptyStructOut[][]; fallback: BarOut };

    export type BarIn =
      | { field: 'aRequired' }
      | { field: 'bRequired'; value: number }
      | { field: 'cRequired'; value: bigint }
      | { field: 'dRequired'; value: bigint }
      | { field: 'eRequired'; value: boolean }
      | { field: 'fRequired'; value: ArrayBuffer }
      | { field: 'gRequired'; value: string }
      | { field: 'hRequired'; value: undefined[] }
      | { field: 'iRequired'; value: number[] }
      | { field: 'jRequired'; value: bigint[] }
      | { field: 'kRequired'; value: bigint[] }
      | { field: 'lRequired'; value: boolean[] }
      | { field: 'mRequired'; value: ArrayBuffer[] }
      | { field: 'nRequired'; value: string[] }
      | { field: 'oRequired'; value: Comprehensive.Main.EmptyStructIn[][] }
      | { field: 'aAsymmetric' }
      | { field: 'bAsymmetric'; value: number }
      | { field: 'cAsymmetric'; value: bigint }
      | { field: 'dAsymmetric'; value: bigint }
      | { field: 'eAsymmetric'; value: boolean }
      | { field: 'fAsymmetric'; value: ArrayBuffer }
      | { field: 'gAsymmetric'; value: string }
      | { field: 'hAsymmetric'; value: undefined[] }
      | { field: 'iAsymmetric'; value: number[] }
      | { field: 'jAsymmetric'; value: bigint[] }
      | { field: 'kAsymmetric'; value: bigint[] }
      | { field: 'lAsymmetric'; value: boolean[] }
      | { field: 'mAsymmetric'; value: ArrayBuffer[] }
      | { field: 'nAsymmetric'; value: string[] }
      | { field: 'oAsymmetric'; value: Comprehensive.Main.EmptyStructIn[][] }
      | { field: 'aOptional'; fallback: BarIn }
      | { field: 'bOptional'; value: number; fallback: BarIn }
      | { field: 'cOptional'; value: bigint; fallback: BarIn }
      | { field: 'dOptional'; value: bigint; fallback: BarIn }
      | { field: 'eOptional'; value: boolean; fallback: BarIn }
      | { field: 'fOptional'; value: ArrayBuffer; fallback: BarIn }
      | { field: 'gOptional'; value: string; fallback: BarIn }
      | { field: 'hOptional'; value: undefined[]; fallback: BarIn }
      | { field: 'iOptional'; value: number[]; fallback: BarIn }
      | { field: 'jOptional'; value: bigint[]; fallback: BarIn }
      | { field: 'kOptional'; value: bigint[]; fallback: BarIn }
      | { field: 'lOptional'; value: boolean[]; fallback: BarIn }
      | { field: 'mOptional'; value: ArrayBuffer[]; fallback: BarIn }
      | { field: 'nOptional'; value: string[]; fallback: BarIn }
      | { field: 'oOptional'; value: Comprehensive.Main.EmptyStructIn[][]; fallback: BarIn };

    export namespace Bar {
      export function size(value: BarOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'aRequired': {
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'bRequired': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize;
          }
          case 'cRequired': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(2n, payloadSize, true) + payloadSize;
          }
          case 'dRequired': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(3n, payloadSize, true) + payloadSize;
          }
          case 'eRequired': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(4n, payloadSize, true) + payloadSize;
          }
          case 'fRequired': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize;
          }
          case 'gRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize;
          }
          case 'hRequired': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(7n, payloadSize, false) + payloadSize;
          }
          case 'iRequired': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize;
          }
          case 'jRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(9n, payloadSize, false) + payloadSize;
          }
          case 'kRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize;
          }
          case 'lRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(11n, payloadSize, false) + payloadSize;
          }
          case 'mRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(12n, payloadSize, false) + payloadSize;
          }
          case 'nRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(13n, payloadSize, false) + payloadSize;
          }
          case 'oRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(14n, payloadSize, false) + payloadSize;
          }
          case 'aAsymmetric': {
            return fieldHeaderSize(16n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'bAsymmetric': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(17n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'cAsymmetric': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(18n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'dAsymmetric': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(19n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'eAsymmetric': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(20n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'fAsymmetric': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(21n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'gAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(22n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'hAsymmetric': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(23n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'iAsymmetric': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(24n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'jAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(25n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'kAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(26n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'lAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(27n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'mAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(28n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(29n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'oAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(30n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'aOptional': {
            return fieldHeaderSize(32n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'bOptional': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(33n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'cOptional': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(34n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'dOptional': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(35n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'eOptional': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(36n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'fOptional': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(37n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'gOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(38n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'hOptional': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(39n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'iOptional': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(40n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'jOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(41n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'kOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(42n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'lOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(43n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'mOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(44n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(45n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'oOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(46n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: BarOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'aRequired': {
            offset = serializeFieldHeader(dataView, offset, 0n, 0, false);
            return offset;
          }
          case 'bRequired': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
            return offset;
          }
          case 'cRequired': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'dRequired': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'eRequired': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'fRequired': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'gRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'hRequired': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'iRequired': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
            return offset;
          }
          case 'jRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'kRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'lRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'mRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            return offset;
          }
          case 'nRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            return offset;
          }
          case 'oRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Main.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            return offset;
          }
          case 'aAsymmetric': {
            offset = serializeFieldHeader(dataView, offset, 16n, 0, false);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'bAsymmetric': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'cAsymmetric': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'dAsymmetric': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 19n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'eAsymmetric': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 20n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'fAsymmetric': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 21n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'gAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 22n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'hAsymmetric': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 23n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'iAsymmetric': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 24n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'jAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 25n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'kAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 26n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'lAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 27n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'mAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 28n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 29n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'oAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 30n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Main.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'aOptional': {
            offset = serializeFieldHeader(dataView, offset, 32n, 0, false);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'bOptional': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 33n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'cOptional': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 34n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'dOptional': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 35n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'eOptional': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 36n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'fOptional': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 37n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'gOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 38n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'hOptional': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 39n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'iOptional': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 40n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'jOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 41n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'kOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 42n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'lOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 43n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'mOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 44n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 45n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'oOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 46n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Main.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, BarIn] {
        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              return [
                offset,
                {
                  field: 'aRequired',
                },
              ];
            }
            case 1n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              return [
                offset,
                {
                  field: 'bRequired',
                  value: payload,
                },
              ];
            }
            case 2n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              return [
                offset,
                {
                  field: 'cRequired',
                  value: payload,
                },
              ];
            }
            case 3n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              return [
                offset,
                {
                  field: 'dRequired',
                  value: payload,
                },
              ];
            }
            case 4n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              return [
                offset,
                {
                  field: 'eRequired',
                  value: payload,
                },
              ];
            }
            case 5n: {
              let payload = dataView.buffer.slice(offset, offset + payloadSize);
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'fRequired',
                  value: payload,
                },
              ];
            }
            case 6n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'gRequired',
                  value: payload,
                },
              ];
            }
            case 7n: {
              let payload;
              {
                let newPayload;
                const payloadSize: number = 0;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              return [
                offset,
                {
                  field: 'hRequired',
                  value: payload,
                },
              ];
            }
            case 8n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'iRequired',
                  value: payload,
                },
              ];
            }
            case 9n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'jRequired',
                  value: payload,
                },
              ];
            }
            case 10n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'kRequired',
                  value: payload,
                },
              ];
            }
            case 11n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'lRequired',
                  value: payload,
                },
              ];
            }
            case 12n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(offset, offset + payloadSize);
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'mRequired',
                  value: payload,
                },
              ];
            }
            case 13n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                        payloadSize));
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'nRequired',
                  value: payload,
                },
              ];
            }
            case 14n: {
              let payload: Comprehensive.Main.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Main.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = \
                              Comprehensive.Main.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'oRequired',
                  value: payload,
                },
              ];
            }
            case 16n: {
              return [
                offset,
                {
                  field: 'aAsymmetric',
                },
              ];
            }
            case 17n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              return [
                offset,
                {
                  field: 'bAsymmetric',
                  value: payload,
                },
              ];
            }
            case 18n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              return [
                offset,
                {
                  field: 'cAsymmetric',
                  value: payload,
                },
              ];
            }
            case 19n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              return [
                offset,
                {
                  field: 'dAsymmetric',
                  value: payload,
                },
              ];
            }
            case 20n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              return [
                offset,
                {
                  field: 'eAsymmetric',
                  value: payload,
                },
              ];
            }
            case 21n: {
              let payload = dataView.buffer.slice(offset, offset + payloadSize);
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'fAsymmetric',
                  value: payload,
                },
              ];
            }
            case 22n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'gAsymmetric',
                  value: payload,
                },
              ];
            }
            case 23n: {
              let payload;
              {
                let newPayload;
                const payloadSize: number = 0;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              return [
                offset,
                {
                  field: 'hAsymmetric',
                  value: payload,
                },
              ];
            }
            case 24n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'iAsymmetric',
                  value: payload,
                },
              ];
            }
            case 25n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'jAsymmetric',
                  value: payload,
                },
              ];
            }
            case 26n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'kAsymmetric',
                  value: payload,
                },
              ];
            }
            case 27n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'lAsymmetric',
                  value: payload,
                },
              ];
            }
            case 28n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(offset, offset + payloadSize);
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'mAsymmetric',
                  value: payload,
                },
              ];
            }
            case 29n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                        payloadSize));
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'nAsymmetric',
                  value: payload,
                },
              ];
            }
            case 30n: {
              let payload: Comprehensive.Main.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Main.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = \
                              Comprehensive.Main.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              return [
                offset,
                {
                  field: 'oAsymmetric',
                  value: payload,
                },
              ];
            }
            case 32n: {
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'aOptional',
                  fallback,
                },
              ];
            }
            case 33n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'bOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 34n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'cOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 35n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'dOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 36n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'eOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 37n: {
              let payload = dataView.buffer.slice(offset, offset + payloadSize);
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'fOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 38n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'gOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 39n: {
              let payload;
              {
                let newPayload;
                const payloadSize: number = 0;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'hOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 40n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'iOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 41n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'jOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 42n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'kOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 43n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'lOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 44n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(offset, offset + payloadSize);
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'mOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 45n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                        payloadSize));
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'nOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 46n: {
              let payload: Comprehensive.Main.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Main.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = \
                              Comprehensive.Main.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'oOptional',
                  value: payload,
                  fallback,
                },
              ];
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: BarOut): BarIn {
        return value;
      }
    }
  }

  export namespace Foo {
    export type FooOut = {
      aRequired: undefined;
      bRequired: number;
      cRequired: bigint;
      dRequired: bigint;
      eRequired: boolean;
      fRequired: ArrayBuffer;
      gRequired: string;
      hRequired: undefined[];
      iRequired: number[];
      jRequired: bigint[];
      kRequired: bigint[];
      lRequired: boolean[];
      mRequired: ArrayBuffer[];
      nRequired: string[];
      oRequired: Comprehensive.Main.EmptyStructOut[][];
      aAsymmetric: undefined;
      bAsymmetric: number;
      cAsymmetric: bigint;
      dAsymmetric: bigint;
      eAsymmetric: boolean;
      fAsymmetric: ArrayBuffer;
      gAsymmetric: string;
      hAsymmetric: undefined[];
      iAsymmetric: number[];
      jAsymmetric: bigint[];
      kAsymmetric: bigint[];
      lAsymmetric: boolean[];
      mAsymmetric: ArrayBuffer[];
      nAsymmetric: string[];
      oAsymmetric: Comprehensive.Main.EmptyStructOut[][];
      aOptional?: undefined;
      bOptional?: number;
      cOptional?: bigint;
      dOptional?: bigint;
      eOptional?: boolean;
      fOptional?: ArrayBuffer;
      gOptional?: string;
      hOptional?: undefined[];
      iOptional?: number[];
      jOptional?: bigint[];
      kOptional?: bigint[];
      lOptional?: boolean[];
      mOptional?: ArrayBuffer[];
      nOptional?: string[];
      oOptional?: Comprehensive.Main.EmptyStructOut[][];
    };

    export type FooIn = {
      aRequired: undefined;
      bRequired: number;
      cRequired: bigint;
      dRequired: bigint;
      eRequired: boolean;
      fRequired: ArrayBuffer;
      gRequired: string;
      hRequired: undefined[];
      iRequired: number[];
      jRequired: bigint[];
      kRequired: bigint[];
      lRequired: boolean[];
      mRequired: ArrayBuffer[];
      nRequired: string[];
      oRequired: Comprehensive.Main.EmptyStructIn[][];
      aAsymmetric?: undefined;
      bAsymmetric?: number;
      cAsymmetric?: bigint;
      dAsymmetric?: bigint;
      eAsymmetric?: boolean;
      fAsymmetric?: ArrayBuffer;
      gAsymmetric?: string;
      hAsymmetric?: undefined[];
      iAsymmetric?: number[];
      jAsymmetric?: bigint[];
      kAsymmetric?: bigint[];
      lAsymmetric?: boolean[];
      mAsymmetric?: ArrayBuffer[];
      nAsymmetric?: string[];
      oAsymmetric?: Comprehensive.Main.EmptyStructIn[][];
      aOptional?: undefined;
      bOptional?: number;
      cOptional?: bigint;
      dOptional?: bigint;
      eOptional?: boolean;
      fOptional?: ArrayBuffer;
      gOptional?: string;
      hOptional?: undefined[];
      iOptional?: number[];
      jOptional?: bigint[];
      kOptional?: bigint[];
      lOptional?: boolean[];
      mOptional?: ArrayBuffer[];
      nOptional?: string[];
      oOptional?: Comprehensive.Main.EmptyStructIn[][];
    };

    export namespace Foo {
      export function size(value: FooOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.aRequired;
          payloadSize = 0;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.bRequired;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.cRequired;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(2n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.dRequired;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(3n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.eRequired;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(4n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.fRequired;
          payloadSize = payload.byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.gRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.hRequired;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          valueSize += fieldHeaderSize(7n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.iRequired;
          payloadSize = 8 * payload.length;
          valueSize += fieldHeaderSize(8n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.jRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.kRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.lRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(11n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.mRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(12n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.oRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aAsymmetric;
          payloadSize = 0;
          valueSize += fieldHeaderSize(16n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.bAsymmetric;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(17n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.cAsymmetric;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(18n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.dAsymmetric;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(19n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.eAsymmetric;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(20n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.fAsymmetric;
          payloadSize = payload.byteLength;
          valueSize += fieldHeaderSize(21n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.gAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(22n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.hAsymmetric;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          valueSize += fieldHeaderSize(23n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.iAsymmetric;
          payloadSize = 8 * payload.length;
          valueSize += fieldHeaderSize(24n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.jAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(25n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.kAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(26n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.lAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(27n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.mAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(28n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(29n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.oAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(30n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(32n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.bOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(33n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.cOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(34n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.dOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
          }
          valueSize += fieldHeaderSize(35n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.eOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
          }
          valueSize += fieldHeaderSize(36n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.fOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = payload.byteLength;
          }
          valueSize += fieldHeaderSize(37n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.gOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(38n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.hOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
          }
          valueSize += fieldHeaderSize(39n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.iOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = 8 * payload.length;
          }
          valueSize += fieldHeaderSize(40n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.jOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(41n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.kOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(42n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.lOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(43n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.mOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(44n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(45n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.oOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(46n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: FooOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.aRequired;
          payloadSize = 0;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
        }

        {
          const payload = value.bRequired;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          if (payloadSize !== 0) {
            dataView.setFloat64(offset, payload, true);
          }
        }

        {
          const payload = value.cRequired;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.dRequired;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.eRequired;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.fRequired;
          payloadSize = payload.byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const buffer = new Uint8Array(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.gRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.hRequired;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.iRequired;
          payloadSize = 8 * payload.length;
          offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 8;
              dataView.setFloat64(offset, payload, true);
            }
          }
        }

        {
          const payload = value.jRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(payload);
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.kRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.lRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 1;
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.mRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = payload.byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = new Uint8Array(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.nRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = textEncoder.encode(payload).byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = textEncoder.encode(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.oRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  offset = Comprehensive.Main.EmptyStruct.serialize(dataView, offset, payload);
                }
              }
            }
          }
        }

        {
          const payload = value.aAsymmetric;
          payloadSize = 0;
          offset = serializeFieldHeader(dataView, offset, 16n, payloadSize, false);
        }

        {
          const payload = value.bAsymmetric;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
          if (payloadSize !== 0) {
            dataView.setFloat64(offset, payload, true);
          }
        }

        {
          const payload = value.cAsymmetric;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.dAsymmetric;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          offset = serializeFieldHeader(dataView, offset, 19n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.eAsymmetric;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          offset = serializeFieldHeader(dataView, offset, 20n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.fAsymmetric;
          payloadSize = payload.byteLength;
          offset = serializeFieldHeader(dataView, offset, 21n, payloadSize, false);
          {
            const buffer = new Uint8Array(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.gAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 22n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.hAsymmetric;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          offset = serializeFieldHeader(dataView, offset, 23n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.iAsymmetric;
          payloadSize = 8 * payload.length;
          offset = serializeFieldHeader(dataView, offset, 24n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 8;
              dataView.setFloat64(offset, payload, true);
            }
          }
        }

        {
          const payload = value.jAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 25n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(payload);
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.kAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 26n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.lAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 27n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 1;
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.mAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 28n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = payload.byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = new Uint8Array(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.nAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 29n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = textEncoder.encode(payload).byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = textEncoder.encode(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.oAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 30n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  offset = Comprehensive.Main.EmptyStruct.serialize(dataView, offset, payload);
                }
              }
            }
          }
        }

        {
          const payload = value.aOptional;
          if (payload !== undefined) {
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 32n, payloadSize, false);
          }
        }

        {
          const payload = value.bOptional;
          if (payload !== undefined) {
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 33n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
          }
        }

        {
          const payload = value.cOptional;
          if (payload !== undefined) {
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 34n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.dOptional;
          if (payload !== undefined) {
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 35n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.eOptional;
          if (payload !== undefined) {
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 36n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.fOptional;
          if (payload !== undefined) {
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 37n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.gOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 38n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.hOptional;
          if (payload !== undefined) {
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 39n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.iOptional;
          if (payload !== undefined) {
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 40n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
          }
        }

        {
          const payload = value.jOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 41n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.kOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 42n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.lOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 43n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.mOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 44n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
          }
        }

        {
          const payload = value.nOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 45n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
          }
        }

        {
          const payload = value.oOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 46n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = Comprehensive.Main.EmptyStruct.size(payload);
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    offset = Comprehensive.Main.EmptyStruct.serialize(dataView, offset, payload);
                  }
                }
              }
            }
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, FooIn] {
        let aRequiredField, bRequiredField, cRequiredField, dRequiredField, eRequiredField, \
            fRequiredField, gRequiredField, hRequiredField, iRequiredField, jRequiredField, \
            kRequiredField, lRequiredField, mRequiredField, nRequiredField, oRequiredField, \
            aAsymmetricField, bAsymmetricField, cAsymmetricField, dAsymmetricField, \
            eAsymmetricField, fAsymmetricField, gAsymmetricField, hAsymmetricField, \
            iAsymmetricField, jAsymmetricField, kAsymmetricField, lAsymmetricField, \
            mAsymmetricField, nAsymmetricField, oAsymmetricField, aOptionalField, bOptionalField, \
            cOptionalField, dOptionalField, eOptionalField, fOptionalField, gOptionalField, \
            hOptionalField, iOptionalField, jOptionalField, kOptionalField, lOptionalField, \
            mOptionalField, nOptionalField, oOptionalField;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
            }
            case 1n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              bRequiredField = payload;
            }
            case 2n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              cRequiredField = payload;
            }
            case 3n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              dRequiredField = payload;
            }
            case 4n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              eRequiredField = payload;
            }
            case 5n: {
              let payload = dataView.buffer.slice(offset, offset + payloadSize);
              offset += payloadSize;
              fRequiredField = payload;
            }
            case 6n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              gRequiredField = payload;
            }
            case 7n: {
              let payload;
              {
                let newPayload;
                const payloadSize: number = 0;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              hRequiredField = payload;
            }
            case 8n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              iRequiredField = payload;
            }
            case 9n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              jRequiredField = payload;
            }
            case 10n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              kRequiredField = payload;
            }
            case 11n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              lRequiredField = payload;
            }
            case 12n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(offset, offset + payloadSize);
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              mRequiredField = payload;
            }
            case 13n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                        payloadSize));
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              nRequiredField = payload;
            }
            case 14n: {
              let payload: Comprehensive.Main.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Main.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = \
                              Comprehensive.Main.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              oRequiredField = payload;
            }
            case 16n: {
            }
            case 17n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              bAsymmetricField = payload;
            }
            case 18n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              cAsymmetricField = payload;
            }
            case 19n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              dAsymmetricField = payload;
            }
            case 20n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              eAsymmetricField = payload;
            }
            case 21n: {
              let payload = dataView.buffer.slice(offset, offset + payloadSize);
              offset += payloadSize;
              fAsymmetricField = payload;
            }
            case 22n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              gAsymmetricField = payload;
            }
            case 23n: {
              let payload;
              {
                let newPayload;
                const payloadSize: number = 0;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              hAsymmetricField = payload;
            }
            case 24n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              iAsymmetricField = payload;
            }
            case 25n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              jAsymmetricField = payload;
            }
            case 26n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              kAsymmetricField = payload;
            }
            case 27n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              lAsymmetricField = payload;
            }
            case 28n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(offset, offset + payloadSize);
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              mAsymmetricField = payload;
            }
            case 29n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                        payloadSize));
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              nAsymmetricField = payload;
            }
            case 30n: {
              let payload: Comprehensive.Main.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Main.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = \
                              Comprehensive.Main.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              oAsymmetricField = payload;
            }
            case 32n: {
            }
            case 33n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0;
                    break;
                  default:
                    payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    break;
                }
              }
              bOptionalField = payload;
            }
            case 34n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              cOptionalField = payload;
            }
            case 35n: {
              let payload;
              {
                switch (payloadSize) {
                  case 0:
                    payload = 0n;
                    break;
                  case 8:
                    payload = dataView.getBigUint64(offset, true);
                    offset += 8;
                    break;
                  default:
                    [offset, payload] = deserializeVarint(dataView, offset);
                    break;
                }
              }
              payload = zigzagDecode(payload);
              dOptionalField = payload;
            }
            case 36n: {
              let payload;
              {
                let newPayload;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = payload !== 0n;
                }
                payload = newPayload;
              }
              eOptionalField = payload;
            }
            case 37n: {
              let payload = dataView.buffer.slice(offset, offset + payloadSize);
              offset += payloadSize;
              fOptionalField = payload;
            }
            case 38n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              gOptionalField = payload;
            }
            case 39n: {
              let payload;
              {
                let newPayload;
                const payloadSize: number = 0;
                {
                  let payload;
                  {
                    switch (payloadSize) {
                      case 0:
                        payload = 0n;
                        break;
                      case 8:
                        payload = dataView.getBigUint64(offset, true);
                        offset += 8;
                        break;
                      default:
                        [offset, payload] = deserializeVarint(dataView, offset);
                        break;
                    }
                  }
                  newPayload = Array(Number(payload)).fill(undefined);
                }
                payload = newPayload;
              }
              hOptionalField = payload;
            }
            case 40n: {
              let payload: number[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload = dataView.getFloat64(offset, true);
                    offset += 8;
                    payloadAlias.push(payload);
                  }
                }
              }
              iOptionalField = payload;
            }
            case 41n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payloadAlias.push(payload);
                  }
                }
              }
              jOptionalField = payload;
            }
            case 42n: {
              let payload: bigint[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    [offset, payload] = deserializeVarint(dataView, offset);
                    payload = zigzagDecode(payload);
                    payloadAlias.push(payload);
                  }
                }
              }
              kOptionalField = payload;
            }
            case 43n: {
              let payload: boolean[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payload;
                    {
                      let newPayload;
                      {
                        let payload;
                        [offset, payload] = deserializeVarint(dataView, offset);
                        newPayload = payload !== 0n;
                      }
                      payload = newPayload;
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              lOptionalField = payload;
            }
            case 44n: {
              let payload: ArrayBuffer[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = dataView.buffer.slice(offset, offset + payloadSize);
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              mOptionalField = payload;
            }
            case 45n: {
              let payload: string[] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                        payloadSize));
                    offset += payloadSize;
                    payloadAlias.push(payload);
                  }
                }
              }
              nOptionalField = payload;
            }
            case 46n: {
              let payload: Comprehensive.Main.EmptyStructIn[][] = [];
              {
                let payloadAlias = payload;
                {
                  while (true) {
                    let payloadSizeBig;
                    [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                    const payloadSize = Number(payloadSizeBig);
                    let payload: Comprehensive.Main.EmptyStructIn[] = [];
                    {
                      let payloadAlias = payload;
                      {
                        while (true) {
                          let payloadSizeBig;
                          [offset, payloadSizeBig] = deserializeVarint(dataView, offset);
                          const payloadSize = Number(payloadSizeBig);
                          let payload;
                          [offset, payload] = \
                              Comprehensive.Main.EmptyStruct.deserialize(dataView, offset);
                          payloadAlias.push(payload);
                        }
                      }
                    }
                    payloadAlias.push(payload);
                  }
                }
              }
              oOptionalField = payload;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if (bRequiredField === undefined || cRequiredField === undefined || dRequiredField === \
            undefined || eRequiredField === undefined || fRequiredField === undefined || \
            gRequiredField === undefined || hRequiredField === undefined || iRequiredField === \
            undefined || jRequiredField === undefined || kRequiredField === undefined || \
            lRequiredField === undefined || mRequiredField === undefined || nRequiredField === \
            undefined || oRequiredField === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return [
          offset,
          {
            aRequired: aRequiredField,
            bRequired: bRequiredField,
            cRequired: cRequiredField,
            dRequired: dRequiredField,
            eRequired: eRequiredField,
            fRequired: fRequiredField,
            gRequired: gRequiredField,
            hRequired: hRequiredField,
            iRequired: iRequiredField,
            jRequired: jRequiredField,
            kRequired: kRequiredField,
            lRequired: lRequiredField,
            mRequired: mRequiredField,
            nRequired: nRequiredField,
            oRequired: oRequiredField,
            aAsymmetric: aAsymmetricField,
            bAsymmetric: bAsymmetricField,
            cAsymmetric: cAsymmetricField,
            dAsymmetric: dAsymmetricField,
            eAsymmetric: eAsymmetricField,
            fAsymmetric: fAsymmetricField,
            gAsymmetric: gAsymmetricField,
            hAsymmetric: hAsymmetricField,
            iAsymmetric: iAsymmetricField,
            jAsymmetric: jAsymmetricField,
            kAsymmetric: kAsymmetricField,
            lAsymmetric: lAsymmetricField,
            mAsymmetric: mAsymmetricField,
            nAsymmetric: nAsymmetricField,
            oAsymmetric: oAsymmetricField,
            aOptional: aOptionalField,
            bOptional: bOptionalField,
            cOptional: cOptionalField,
            dOptional: dOptionalField,
            eOptional: eOptionalField,
            fOptional: fOptionalField,
            gOptional: gOptionalField,
            hOptional: hOptionalField,
            iOptional: iOptionalField,
            jOptional: jOptionalField,
            kOptional: kOptionalField,
            lOptional: lOptionalField,
            mOptional: mOptionalField,
            nOptional: nOptionalField,
            oOptional: oOptionalField,
          }
        ];
      }

      export function outToIn(value: FooOut): FooIn {
        return value;
      }
    }
  }

  export namespace Main {
    export type EmptyStructOut = {
    };

    export type EmptyStructIn = {
    };

    export namespace EmptyStruct {
      export function size(value: EmptyStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: EmptyStructOut,
      ): number {
        let payloadSize = 0;

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, EmptyStructIn] {
        return [
          offset,
          {
          }
        ];
      }

      export function outToIn(value: EmptyStructOut): EmptyStructIn {
        return value;
      }
    }

    export type EmptyChoiceOut = never;

    export type EmptyChoiceIn = never;

    export namespace EmptyChoice {
      export function size(value: EmptyChoiceOut): number {
        return 0;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: EmptyChoiceOut,
      ): number {
        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, EmptyChoiceIn] {
        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          offset = newOffset;
          switch (index) {
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: EmptyChoiceOut): EmptyChoiceIn {
        return value;
      }
    }

    export type FooAndBarOut = {
      x: Comprehensive.Foo.FooOut;
      y: Comprehensive.Bar.BarOut;
    };

    export type FooAndBarIn = {
      x: Comprehensive.Foo.FooIn;
      y: Comprehensive.Bar.BarIn;
    };

    export namespace FooAndBar {
      export function size(value: FooAndBarOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = Comprehensive.Foo.Foo.size(payload);
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.y;
          payloadSize = Comprehensive.Bar.Bar.size(payload);
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: FooAndBarOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = Comprehensive.Foo.Foo.size(payload);
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          offset = Comprehensive.Foo.Foo.serialize(dataView, offset, payload);
        }

        {
          const payload = value.y;
          payloadSize = Comprehensive.Bar.Bar.size(payload);
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          offset = Comprehensive.Bar.Bar.serialize(dataView, offset, payload);
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, FooAndBarIn] {
        let xField, yField;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              let payload;
              [offset, payload] = Comprehensive.Foo.Foo.deserialize(dataView, offset);
              xField = payload;
            }
            case 1n: {
              let payload;
              [offset, payload] = Comprehensive.Bar.Bar.deserialize(dataView, offset);
              yField = payload;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if (xField === undefined || yField === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return [
          offset,
          {
            x: xField,
            y: yField,
          }
        ];
      }

      export function outToIn(value: FooAndBarOut): FooAndBarIn {
        return value;
      }
    }

    export type FooOrBarOut =
      | { field: 'x'; value: Comprehensive.Foo.FooOut }
      | { field: 'y'; value: Comprehensive.Bar.BarOut };

    export type FooOrBarIn =
      | { field: 'x'; value: Comprehensive.Foo.FooIn }
      | { field: 'y'; value: Comprehensive.Bar.BarIn };

    export namespace FooOrBar {
      export function size(value: FooOrBarOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'x': {
            const payload = value.value;
            payloadSize = Comprehensive.Foo.Foo.size(payload);
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'y': {
            const payload = value.value;
            payloadSize = Comprehensive.Bar.Bar.size(payload);
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize;
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: FooOrBarOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'x': {
            const payload = value.value;
            payloadSize = Comprehensive.Foo.Foo.size(payload);
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            offset = Comprehensive.Foo.Foo.serialize(dataView, offset, payload);
            return offset;
          }
          case 'y': {
            const payload = value.value;
            payloadSize = Comprehensive.Bar.Bar.size(payload);
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            offset = Comprehensive.Bar.Bar.serialize(dataView, offset, payload);
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, FooOrBarIn] {
        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              let payload;
              [offset, payload] = Comprehensive.Foo.Foo.deserialize(dataView, offset);
              return [
                offset,
                {
                  field: 'x',
                  value: payload,
                },
              ];
            }
            case 1n: {
              let payload;
              [offset, payload] = Comprehensive.Bar.Bar.deserialize(dataView, offset);
              return [
                offset,
                {
                  field: 'y',
                  value: payload,
                },
              ];
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: FooOrBarOut): FooOrBarIn {
        return value;
      }
    }
  }
}

export namespace Main {
}

export namespace SchemaEvolution {
  export namespace After {
    export type ExampleStructOut = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional?: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric: string;
      asymmetricToOptional?: string;
      optionalNoneToAsymmetric: string;
      optionalNoneToOptional?: string;
      optionalSomeToRequired: string;
      optionalSomeToAsymmetric: string;
      optionalSomeToOptional?: string;
      nonexistentToAsymmetric: string;
      nonexistentToOptional?: string;
    };

    export type ExampleStructIn = {
      requiredToRequired: string;
      requiredToAsymmetric?: string;
      requiredToOptional?: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric?: string;
      asymmetricToOptional?: string;
      optionalNoneToAsymmetric?: string;
      optionalNoneToOptional?: string;
      optionalSomeToRequired: string;
      optionalSomeToAsymmetric?: string;
      optionalSomeToOptional?: string;
      nonexistentToAsymmetric?: string;
      nonexistentToOptional?: string;
    };

    export namespace ExampleStruct {
      export function size(value: ExampleStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(2n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(4n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalNoneToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalNoneToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(12n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nonexistentToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(17n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nonexistentToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(18n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalNoneToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.optionalNoneToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalSomeToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.optionalSomeToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.optionalSomeToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.nonexistentToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.nonexistentToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleStructIn] {
        let requiredToRequiredField, requiredToAsymmetricField, requiredToOptionalField, \
            asymmetricToRequiredField, asymmetricToAsymmetricField, asymmetricToOptionalField, \
            optionalNoneToAsymmetricField, optionalNoneToOptionalField, \
            optionalSomeToRequiredField, optionalSomeToAsymmetricField, \
            optionalSomeToOptionalField, nonexistentToAsymmetricField, nonexistentToOptionalField;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              requiredToRequiredField = payload;
            }
            case 1n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              requiredToAsymmetricField = payload;
            }
            case 2n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              requiredToOptionalField = payload;
            }
            case 4n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              asymmetricToRequiredField = payload;
            }
            case 5n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              asymmetricToAsymmetricField = payload;
            }
            case 6n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              asymmetricToOptionalField = payload;
            }
            case 9n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalNoneToAsymmetricField = payload;
            }
            case 10n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalNoneToOptionalField = payload;
            }
            case 12n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalSomeToRequiredField = payload;
            }
            case 13n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalSomeToAsymmetricField = payload;
            }
            case 14n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalSomeToOptionalField = payload;
            }
            case 17n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              nonexistentToAsymmetricField = payload;
            }
            case 18n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              nonexistentToOptionalField = payload;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if (requiredToRequiredField === undefined || asymmetricToRequiredField === undefined || \
            optionalSomeToRequiredField === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return [
          offset,
          {
            requiredToRequired: requiredToRequiredField,
            requiredToAsymmetric: requiredToAsymmetricField,
            requiredToOptional: requiredToOptionalField,
            asymmetricToRequired: asymmetricToRequiredField,
            asymmetricToAsymmetric: asymmetricToAsymmetricField,
            asymmetricToOptional: asymmetricToOptionalField,
            optionalNoneToAsymmetric: optionalNoneToAsymmetricField,
            optionalNoneToOptional: optionalNoneToOptionalField,
            optionalSomeToRequired: optionalSomeToRequiredField,
            optionalSomeToAsymmetric: optionalSomeToAsymmetricField,
            optionalSomeToOptional: optionalSomeToOptionalField,
            nonexistentToAsymmetric: nonexistentToAsymmetricField,
            nonexistentToOptional: nonexistentToOptionalField,
          }
        ];
      }

      export function outToIn(value: ExampleStructOut): ExampleStructIn {
        return value;
      }
    }

    export type ExampleChoiceOut =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToRequired'; value: string }
      | { field: 'asymmetricToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToOptionalHandled'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToOptionalFallback'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToRequired'; value: string }
      | { field: 'optionalToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToOptionalHandled'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToOptionalFallback'; value: string; fallback: ExampleChoiceOut }
      | { field: 'nonexistentToRequired'; value: string }
      | { field: 'nonexistentToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'nonexistentToOptionalHandled'; value: string; fallback: ExampleChoiceOut }
      | { field: 'nonexistentToOptionalFallback'; value: string; fallback: ExampleChoiceOut };

    export type ExampleChoiceIn =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string }
      | { field: 'asymmetricToRequired'; value: string }
      | { field: 'asymmetricToAsymmetric'; value: string }
      | { field: 'asymmetricToOptionalHandled'; value: string; fallback: ExampleChoiceIn }
      | { field: 'asymmetricToOptionalFallback'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToRequired'; value: string }
      | { field: 'optionalToAsymmetric'; value: string }
      | { field: 'optionalToOptionalHandled'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToOptionalFallback'; value: string; fallback: ExampleChoiceIn }
      | { field: 'nonexistentToRequired'; value: string }
      | { field: 'nonexistentToAsymmetric'; value: string }
      | { field: 'nonexistentToOptionalHandled'; value: string; fallback: ExampleChoiceIn }
      | { field: 'nonexistentToOptionalFallback'; value: string; fallback: ExampleChoiceIn };

    export namespace ExampleChoice {
      export function size(value: ExampleChoiceOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(7n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize;
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(11n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(12n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(13n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nonexistentToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(15n, payloadSize, false) + payloadSize;
          }
          case 'nonexistentToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(16n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nonexistentToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(17n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nonexistentToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(18n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nonexistentToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 15n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'nonexistentToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 16n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nonexistentToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nonexistentToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleChoiceIn] {
        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'requiredToRequired',
                  value: payload,
                },
              ];
            }
            case 1n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'requiredToAsymmetric',
                  value: payload,
                },
              ];
            }
            case 5n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToRequired',
                  value: payload,
                },
              ];
            }
            case 6n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToAsymmetric',
                  value: payload,
                },
              ];
            }
            case 7n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'asymmetricToOptionalHandled',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 8n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'asymmetricToOptionalFallback',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 10n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'optionalToRequired',
                  value: payload,
                },
              ];
            }
            case 11n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'optionalToAsymmetric',
                  value: payload,
                },
              ];
            }
            case 12n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToOptionalHandled',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 13n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToOptionalFallback',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 15n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'nonexistentToRequired',
                  value: payload,
                },
              ];
            }
            case 16n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'nonexistentToAsymmetric',
                  value: payload,
                },
              ];
            }
            case 17n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'nonexistentToOptionalHandled',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 18n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'nonexistentToOptionalFallback',
                  value: payload,
                  fallback,
                },
              ];
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: ExampleChoiceOut): ExampleChoiceIn {
        return value;
      }
    }
  }

  export namespace Before {
    export type ExampleStructOut = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional: string;
      requiredToNonexistent: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric: string;
      asymmetricToOptional: string;
      asymmetricToNonexistent: string;
      optionalNoneToAsymmetric?: string;
      optionalNoneToOptional?: string;
      optionalNoneToNonexistent?: string;
      optionalSomeToRequired?: string;
      optionalSomeToAsymmetric?: string;
      optionalSomeToOptional?: string;
      optionalSomeToNonexistent?: string;
    };

    export type ExampleStructIn = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional: string;
      requiredToNonexistent: string;
      asymmetricToRequired?: string;
      asymmetricToAsymmetric?: string;
      asymmetricToOptional?: string;
      asymmetricToNonexistent?: string;
      optionalNoneToAsymmetric?: string;
      optionalNoneToOptional?: string;
      optionalNoneToNonexistent?: string;
      optionalSomeToRequired?: string;
      optionalSomeToAsymmetric?: string;
      optionalSomeToOptional?: string;
      optionalSomeToNonexistent?: string;
    };

    export namespace ExampleStruct {
      export function size(value: ExampleStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(2n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(3n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(4n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(7n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalNoneToAsymmetric;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalNoneToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalNoneToNonexistent;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(11n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToRequired;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(12n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToAsymmetric;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToNonexistent;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(15n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.optionalNoneToAsymmetric;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalNoneToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalNoneToNonexistent;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalSomeToRequired;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalSomeToAsymmetric;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalSomeToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalSomeToNonexistent;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 15n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleStructIn] {
        let requiredToRequiredField, requiredToAsymmetricField, requiredToOptionalField, \
            requiredToNonexistentField, asymmetricToRequiredField, asymmetricToAsymmetricField, \
            asymmetricToOptionalField, asymmetricToNonexistentField, \
            optionalNoneToAsymmetricField, optionalNoneToOptionalField, \
            optionalNoneToNonexistentField, optionalSomeToRequiredField, \
            optionalSomeToAsymmetricField, optionalSomeToOptionalField, \
            optionalSomeToNonexistentField;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              requiredToRequiredField = payload;
            }
            case 1n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              requiredToAsymmetricField = payload;
            }
            case 2n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              requiredToOptionalField = payload;
            }
            case 3n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              requiredToNonexistentField = payload;
            }
            case 4n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              asymmetricToRequiredField = payload;
            }
            case 5n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              asymmetricToAsymmetricField = payload;
            }
            case 6n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              asymmetricToOptionalField = payload;
            }
            case 7n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              asymmetricToNonexistentField = payload;
            }
            case 9n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalNoneToAsymmetricField = payload;
            }
            case 10n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalNoneToOptionalField = payload;
            }
            case 11n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalNoneToNonexistentField = payload;
            }
            case 12n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalSomeToRequiredField = payload;
            }
            case 13n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalSomeToAsymmetricField = payload;
            }
            case 14n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalSomeToOptionalField = payload;
            }
            case 15n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              optionalSomeToNonexistentField = payload;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if (requiredToRequiredField === undefined || requiredToAsymmetricField === undefined || \
            requiredToOptionalField === undefined || requiredToNonexistentField === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return [
          offset,
          {
            requiredToRequired: requiredToRequiredField,
            requiredToAsymmetric: requiredToAsymmetricField,
            requiredToOptional: requiredToOptionalField,
            requiredToNonexistent: requiredToNonexistentField,
            asymmetricToRequired: asymmetricToRequiredField,
            asymmetricToAsymmetric: asymmetricToAsymmetricField,
            asymmetricToOptional: asymmetricToOptionalField,
            asymmetricToNonexistent: asymmetricToNonexistentField,
            optionalNoneToAsymmetric: optionalNoneToAsymmetricField,
            optionalNoneToOptional: optionalNoneToOptionalField,
            optionalNoneToNonexistent: optionalNoneToNonexistentField,
            optionalSomeToRequired: optionalSomeToRequiredField,
            optionalSomeToAsymmetric: optionalSomeToAsymmetricField,
            optionalSomeToOptional: optionalSomeToOptionalField,
            optionalSomeToNonexistent: optionalSomeToNonexistentField,
          }
        ];
      }

      export function outToIn(value: ExampleStructOut): ExampleStructIn {
        return value;
      }
    }

    export type ExampleChoiceOut =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string }
      | { field: 'asymmetricToRequired'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToOptionalHandled'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToOptionalFallback'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToNonexistent'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToRequired'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToOptionalHandled'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToOptionalFallback'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToNonexistent'; value: string; fallback: ExampleChoiceOut };

    export type ExampleChoiceIn =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string }
      | { field: 'asymmetricToRequired'; value: string }
      | { field: 'asymmetricToAsymmetric'; value: string }
      | { field: 'asymmetricToOptionalHandled'; value: string }
      | { field: 'asymmetricToOptionalFallback'; value: string }
      | { field: 'asymmetricToNonexistent'; value: string }
      | { field: 'optionalToRequired'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToAsymmetric'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToOptionalHandled'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToOptionalFallback'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToNonexistent'; value: string; fallback: ExampleChoiceIn };

    export namespace ExampleChoice {
      export function size(value: ExampleChoiceOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize;
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(7n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(9n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(11n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(12n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(13n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(14n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleChoiceIn] {
        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'requiredToRequired',
                  value: payload,
                },
              ];
            }
            case 1n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'requiredToAsymmetric',
                  value: payload,
                },
              ];
            }
            case 5n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToRequired',
                  value: payload,
                },
              ];
            }
            case 6n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToAsymmetric',
                  value: payload,
                },
              ];
            }
            case 7n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToOptionalHandled',
                  value: payload,
                },
              ];
            }
            case 8n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToOptionalFallback',
                  value: payload,
                },
              ];
            }
            case 9n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'asymmetricToNonexistent',
                  value: payload,
                },
              ];
            }
            case 10n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToRequired',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 11n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToAsymmetric',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 12n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToOptionalHandled',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 13n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToOptionalFallback',
                  value: payload,
                  fallback,
                },
              ];
            }
            case 14n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              const [newNewOffset, fallback] = deserialize(dataView, offset);
              offset = newNewOffset;
              return [
                offset,
                {
                  field: 'optionalToNonexistent',
                  value: payload,
                  fallback,
                },
              ];
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: ExampleChoiceOut): ExampleChoiceIn {
        return value;
      }
    }
  }

  export namespace Main {
    export type SingletonStructOut = {
      x: string;
    };

    export type SingletonStructIn = {
      x: string;
    };

    export namespace SingletonStruct {
      export function size(value: SingletonStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: SingletonStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, SingletonStructIn] {
        let xField;

        while (true) {
          let index, payloadSize;
          try {
            [offset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          } catch (e) {
            if (e instanceof RangeError) {
              break;
            } else {
              throw e;
            }
          }
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              xField = payload;
            }
            default:
              offset += payloadSize;
              break;
          }
        }

        if (xField === undefined) {
          throw new Error('Struct missing one or more field(s).');
        }

        return [
          offset,
          {
            x: xField,
          }
        ];
      }

      export function outToIn(value: SingletonStructOut): SingletonStructIn {
        return value;
      }
    }

    export type SingletonChoiceOut =
      | { field: 'x'; value: string }
      | { field: never };

    export type SingletonChoiceIn =
      | { field: 'x'; value: string }
      | { field: never };

    export namespace SingletonChoice {
      export function size(value: SingletonChoiceOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'x': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          default:
            return unreachable(value);
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: SingletonChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'x': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          default:
            return unreachable(value);
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, SingletonChoiceIn] {
        while (true) {
          const [newOffset, index, payloadSize] = deserializeFieldHeader(dataView, offset);
          offset = newOffset;
          switch (index) {
            case 0n: {
              let payload = textDecoder.decode(dataView.buffer.slice(offset, offset + \
                  payloadSize));
              offset += payloadSize;
              return [
                offset,
                {
                  field: 'x',
                  value: payload,
                },
              ];
            }
            default:
              offset += payloadSize;
              break;
          }
        }
      }

      export function outToIn(value: SingletonChoiceOut): SingletonChoiceIn {
        return value;
      }
    }
  }
}
",
        );
    }
}
