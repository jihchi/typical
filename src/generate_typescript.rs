use {
    crate::{identifier::Identifier, schema},
    std::{
        collections::BTreeMap,
        fmt::{self, Write},
        path::PathBuf,
    },
};

// The string to be used for each indentation level.
const INDENTATION: &str = "  ";

// This is the full list of TypeScript keywords, derived from:
//   https://github.com/microsoft/TypeScript/blob/2161e1852f4f627bbc7571c6b7284f419ec524c9
//   /src/compiler/types.ts#L113-L194
const TYPESCRIPT_KEYWORDS: &[&str] = &[
    "abstract",
    "any",
    "as",
    "assert",
    "asserts",
    "async",
    "await",
    "bigint",
    "boolean",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "constructor",
    "continue",
    "debugger",
    "declare",
    "default",
    "delete",
    "do",
    "else",
    "enum",
    "export",
    "extends",
    "false",
    "finally",
    "for",
    "from",
    "function",
    "get",
    "global",
    "if",
    "implements",
    "import",
    "in",
    "infer",
    "instanceof",
    "interface",
    "intrinsic",
    "is",
    "keyof",
    "let",
    "module",
    "namespace",
    "never",
    "new",
    "null",
    "number",
    "object",
    "of",
    "override",
    "package",
    "private",
    "protected",
    "public",
    "readonly",
    "require",
    "return",
    "set",
    "static",
    "string",
    "super",
    "switch",
    "symbol",
    "this",
    "throw",
    "true",
    "try",
    "type",
    "typeof",
    "undefined",
    "unique",
    "unknown",
    "var",
    "void",
    "while",
    "with",
    "yield",
];

// This struct represents a tree of schemas organized in a module hierarchy.
#[derive(Clone, Debug)]
struct Module {
    children: BTreeMap<Identifier, Module>,
    schema: schema::Schema,
}

// This enum represents a case convention for the `write_identifier` function below.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum CaseConvention {
    Camel,
    Pascal,
}

use CaseConvention::{Camel, Pascal};

// This enum is used to distinguish between the ingress and egress versions of a type.
#[derive(Clone, Copy, Debug, Eq, PartialEq)]
enum Direction {
    Out,
    In,
}

use Direction::{In, Out};

// Generate TypeScript code from a schema and its transitive dependencies.
#[allow(clippy::too_many_lines)]
pub fn generate(
    typical_version: &str,
    schemas: &BTreeMap<schema::Namespace, (schema::Schema, PathBuf, String)>,
) -> String {
    // Construct a tree of modules and schemas. We start with an empty tree.
    let mut tree = Module {
        children: BTreeMap::new(),
        schema: schema::Schema {
            comment: vec![],
            imports: BTreeMap::new(),
            declarations: vec![],
        },
    };

    // Populate the tree with all the schemas.
    for (namespace, (schema, _, _)) in schemas {
        insert_schema(&mut tree, namespace, schema);
    }

    // Write the code.
    let mut buffer = String::new();

    if !tree.children.is_empty() || !tree.schema.declarations.is_empty() {
        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        writeln!(
            &mut buffer,
            "\
// This file was automatically generated by Typical {}.
// Visit https://github.com/stepchowfun/typical for more information.

/* eslint-disable */

function zigzagEncode(value: bigint): bigint {{
  const twice = value << 1n;
  return value < 0n ? -1n - twice : twice;
}}

function zigzagDecode(value: bigint): bigint {{
  const half = (value + 1n) >> 1n;
  return (value & 1n) === 0n ? half : -half;
}}

function varintSizeFromValue(value: bigint): number {{
  if (value < 128n) {{
    return 1;
  }} else if (value < 16_512n) {{
    return 2;
  }} else if (value < 2_113_664n) {{
    return 3;
  }} else if (value < 270_549_120n) {{
    return 4;
  }} else if (value < 34_630_287_488n) {{
    return 5;
  }} else if (value < 4_432_676_798_592n) {{
    return 6;
  }} else if (value < 567_382_630_219_904n) {{
    return 7;
  }} else if (value < 72_624_976_668_147_840n) {{
    return 8;
  }} else {{
    return 9;
  }}
}}

function varintSizeFromFirstByte(firstByte: number): number {{
  let trailingZeros = 0;

  while (trailingZeros < 8 && (firstByte & 1) !== 1) {{
    ++trailingZeros;
    firstByte >>= 1;
  }}

  return trailingZeros + 1;
}}

const dataView64 = new DataView(new ArrayBuffer(8));

function serializeVarint(
  dataView: DataView,
  offset: number,
  value: bigint,
): number {{
  if (value < 128n) {{
    dataView.setUint8(offset, Number(value << 1n) | 0b0000_0001);
    return offset + 1;
  }} else if (value < 16_512n) {{
    value -= 128n;
    dataView.setUint8(offset, Number((value << 2n) % 256n) | 0b0000_0010);
    dataView.setUint8(offset + 1, Number(value >> 6n));
    return offset + 2;
  }} else if (value < 2_113_664n) {{
    value -= 16_512n;
    dataView.setUint8(offset, Number((value << 3n) % 256n) | 0b0000_0100);
    dataView.setUint16(offset + 1, Number((value >> 5n) % 65_536n), true);
    return offset + 3;
  }} else if (value < 270_549_120n) {{
    value -= 2_113_664n;
    dataView.setUint8(offset, Number((value << 4n) % 256n) | 0b0000_1000);
    dataView.setUint8(offset + 1, Number((value >> 4n) % 256n));
    dataView.setUint16(offset + 2, Number((value >> 12n) % 65_536n), true);
    return offset + 4;
  }} else if (value < 34_630_287_488n) {{
    value -= 270_549_120n;
    dataView.setUint8(offset, Number((value << 5n) % 256n) | 0b0001_0000);
    dataView.setUint32(
      offset + 1,
      Number((value >> 3n) % 4_294_967_296n),
      true,
    );
    return offset + 5;
  }} else if (value < 4_432_676_798_592n) {{
    value -= 34_630_287_488n;
    dataView.setUint8(offset, Number((value << 6n) % 256n) | 0b0010_0000);
    dataView.setUint8(offset + 1, Number((value >> 2n) % 256n));
    dataView.setUint32(
      offset + 2,
      Number((value >> 10n) % 4_294_967_296n),
      true,
    );
    return offset + 6;
  }} else if (value < 567_382_630_219_904n) {{
    value -= 4_432_676_798_592n;
    dataView.setUint8(offset, Number((value << 7n) % 256n) | 0b0100_0000);
    dataView.setUint16(offset + 1, Number((value >> 1n) % 65_536n), true);
    dataView.setUint32(
      offset + 3,
      Number((value >> 17n) % 4_294_967_296n),
      true,
    );
    return offset + 7;
  }} else if (value < 72_624_976_668_147_840n) {{
    value -= 567_382_630_219_904n;
    dataView.setUint8(offset, 0b1000_0000);
    dataView.setUint8(offset + 1, Number(value % 256n));
    dataView.setUint16(offset + 2, Number((value >> 8n) % 65_536n), true);
    dataView.setUint32(
      offset + 4,
      Number((value >> 24n) % 4_294_967_296n),
      true,
    );
    return offset + 8;
  }} else {{
    value -= 72_624_976_668_147_840n;
    dataView.setUint8(offset, 0b0000_0000);
    dataView.setBigUint64(offset + 1, value, true);
    return offset + 9;
  }}
}}

function deserializeVarint(
  dataView: DataView,
  offset: number,
): [number, bigint] {{
  const firstByte = dataView.getUint8(offset);
  const sizeMinusOne = varintSizeFromFirstByte(firstByte) - 1;
  const offsetPlusOne = offset + 1;
  dataView64.setBigUint64(offset, 0n, true);
  for (let i = 0; i < sizeMinusOne; ++i) {{
    dataView64.setUint8(i, dataView.getUint8(offsetPlusOne + i));
  }}
  const remainingBytesValue = dataView64.getBigUint64(0, true);
  switch (sizeMinusOne) {{
    case 0:
      return [offset + 1, BigInt(firstByte >> 1)];
    case 1:
      return [
        offset + 2,
        128n + BigInt(firstByte >> 2) + (remainingBytesValue << 6n),
      ];
    case 2:
      return [
        offset + 3,
        16_512n + BigInt(firstByte >> 3) + (remainingBytesValue << 5n),
      ];
    case 3:
      return [
        offset + 4,
        2_113_664n + BigInt(firstByte >> 4) + (remainingBytesValue << 4n),
      ];
    case 4:
      return [
        offset + 5,
        270_549_120n + BigInt(firstByte >> 5) + (remainingBytesValue << 3n),
      ];
    case 5:
      return [
        offset + 6,
        34_630_287_488n + BigInt(firstByte >> 6) + (remainingBytesValue << 2n),
      ];
    case 6:
      return [
        offset + 7,
        4_432_676_798_592n +
          BigInt(firstByte >> 7) +
          (remainingBytesValue << 1n),
      ];
    case 7:
      return [offset + 8, 567_382_630_219_904n + remainingBytesValue];
    default:
      return [
        offset + 9,
        (72_624_976_668_147_840n + remainingBytesValue) %
          18_446_744_073_709_551_616n,
      ];
  }}
}}

function fieldHeaderSize(
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {{
  switch (payloadSize) {{
    case 0:
      return varintSizeFromValue((index << 2n) | BigInt(0b00));
    case 8:
      return varintSizeFromValue((index << 2n) | BigInt(0b01));
    default:
      if (integerEncoded) {{
        return varintSizeFromValue((index << 2n) | BigInt(0b11));
      }} else {{
        return (
          varintSizeFromValue((index << 2n) | BigInt(0b10)) +
          varintSizeFromValue(BigInt(payloadSize))
        );
      }}
  }}
}}

function serializeFieldHeader(
  dataView: DataView,
  offset: number,
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {{
  switch (payloadSize) {{
    case 0:
      return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b00));
    case 1:
      return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b01));
    default:
      if (integerEncoded) {{
        return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b11));
      }} else {{
        offset = serializeVarint(
          dataView,
          offset,
          (index << 2n) | BigInt(0b10),
        );
        return serializeVarint(dataView, offset, BigInt(payloadSize));
      }}
  }}
}}

function deserializeFieldHeader(
  dataView: DataView,
  offset: number,
): [number, bigint, number] {{
  const [newOffset, tag] = deserializeVarint(dataView, offset);
  offset = newOffset;

  const index = tag >> 2n;

  let size;
  switch (tag & 3n) {{
    case 0n:
      size = 0;
    case 1n:
      size = 8;
    case 2n:
      const [newNewOffset, sizeValue] = deserializeVarint(dataView, offset);
      offset = newNewOffset;
      size = Number(sizeValue);
    default:
      size = varintSizeFromFirstByte(dataView.getUint8(offset));
  }}

  return [offset, index, size];
}}

const textEncoder = new TextEncoder();",
            typical_version,
        )
        .unwrap();

        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        writeln!(&mut buffer).unwrap();

        // The `unwrap` is safe because the `std::fmt::Write` impl for `String` is infallible.
        write_module_contents(
            &mut buffer,
            0,
            &schema::Namespace { components: vec![] },
            &tree.children,
            &tree.schema,
        )
        .unwrap();
    }

    buffer
}

// Insert a schema into a module.
fn insert_schema(module: &mut Module, namespace: &schema::Namespace, schema: &schema::Schema) {
    let mut iter = namespace.components.iter();

    if let Some(head) = iter.next() {
        if let Some(child) = module.children.get_mut(head) {
            insert_schema(
                child,
                &schema::Namespace {
                    components: iter.cloned().collect(),
                },
                schema,
            );
        } else {
            let mut child = Module {
                children: BTreeMap::new(),
                schema: schema::Schema {
                    comment: vec![],
                    imports: BTreeMap::new(),
                    declarations: vec![],
                },
            };

            insert_schema(
                &mut child,
                &schema::Namespace {
                    components: iter.cloned().collect(),
                },
                schema,
            );

            module.children.insert(head.clone(), child);
        }
    } else {
        module.schema = schema.clone();
    }
}

// Write a module, including a trailing line break.
fn write_module<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    name: &Identifier,
    module: &Module,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    write!(buffer, "export namespace ")?;
    write_identifier(buffer, name, Pascal, None)?;
    writeln!(buffer, " {{")?;

    let mut new_namespace = namespace.clone();
    new_namespace.components.push(name.clone());

    write_module_contents(
        buffer,
        indentation + 1,
        &new_namespace,
        &module.children,
        &module.schema,
    )?;

    write_indentation(buffer, indentation)?;
    writeln!(buffer, "}}")?;

    Ok(())
}

// Write the contents of a module, including a trailing line break if there was anything to render.
fn write_module_contents<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    children: &BTreeMap<Identifier, Module>,
    schema: &schema::Schema,
) -> Result<(), fmt::Error> {
    let schema_empty = schema.declarations.is_empty();

    for (i, (child_name, child)) in children.iter().enumerate() {
        write_module(buffer, indentation, namespace, child_name, child)?;

        if i < children.len() - 1 || !schema_empty {
            writeln!(buffer)?;
        }
    }

    write_schema(buffer, indentation, namespace, schema)?;

    Ok(())
}

// Write a schema, including a trailing line break if there was anything to render.
#[allow(clippy::too_many_lines)]
fn write_schema<T: Write>(
    buffer: &mut T,
    indentation: usize,
    namespace: &schema::Namespace,
    schema: &schema::Schema,
) -> Result<(), fmt::Error> {
    // Construct a map from import name to namespace.
    let mut imports = BTreeMap::new();
    for (name, import) in &schema.imports {
        // The unwrap is safe due to [ref:namespace_populated].
        imports.insert(name.clone(), import.namespace.clone().unwrap());
    }

    // Write the declarations.
    let mut iter = schema.declarations.iter().peekable();
    while let Some(declaration) = iter.next() {
        match &declaration.variant {
            schema::DeclarationVariant::Struct => {
                write_struct(
                    buffer,
                    indentation,
                    &imports,
                    namespace,
                    &declaration.name,
                    &declaration.fields,
                    Out,
                )?;

                writeln!(buffer)?;

                write_struct(
                    buffer,
                    indentation,
                    &imports,
                    namespace,
                    &declaration.name,
                    &declaration.fields,
                    In,
                )?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "export namespace ")?;
                write_identifier(buffer, &declaration.name, Pascal, None)?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "export function size(value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                writeln!(buffer, "): number {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "let valueSize = 0;")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "let payloadSize = 0;")?;
                for field in &declaration.fields {
                    writeln!(buffer)?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "{{")?;
                    write_indentation(buffer, indentation + 3)?;
                    write!(buffer, "const payload = value.")?;
                    write_identifier(buffer, &field.name, Camel, None)?;
                    writeln!(buffer, ";")?;
                    match field.rule {
                        schema::Rule::Asymmetric | schema::Rule::Required => {
                            write_size_calculation_invocation(
                                buffer,
                                indentation + 3,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                        }
                        schema::Rule::Optional => {
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(buffer, "if (payload === undefined) {{")?;
                            write_indentation(buffer, indentation + 4)?;
                            writeln!(buffer, "payloadSize = 0;")?;
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(buffer, "}} else {{")?;
                            write_size_calculation_invocation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(buffer, "}}")?;
                        }
                    }
                    write_indentation(buffer, indentation + 3)?;
                    writeln!(
                        buffer,
                        "valueSize += fieldHeaderSize({}n, payloadSize, {}) + payloadSize;",
                        field.index,
                        integer_encoded(&field.r#type),
                    )?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                }
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "return valueSize;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "export function serialize(")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "dataView: DataView,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "offset: number,")?;
                write_indentation(buffer, indentation + 2)?;
                write!(buffer, "value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                writeln!(buffer, ",")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "): number {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "let payloadSize = 0;")?;
                for field in &declaration.fields {
                    writeln!(buffer)?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "{{")?;
                    write_indentation(buffer, indentation + 3)?;
                    write!(buffer, "const payload = value.")?;
                    write_identifier(buffer, &field.name, Camel, None)?;
                    writeln!(buffer, ";")?;
                    match field.rule {
                        schema::Rule::Asymmetric | schema::Rule::Required => {
                            write_size_calculation_invocation(
                                buffer,
                                indentation + 3,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(
                                buffer,
                                "offset = serializeFieldHeader(dataView, offset, {}n, \
                                    payloadSize, {});",
                                field.index,
                                integer_encoded(&field.r#type),
                            )?;
                            write_serialization_invocation(
                                buffer,
                                indentation + 3,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                        }
                        schema::Rule::Optional => {
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(buffer, "if (payload !== undefined) {{")?;
                            write_size_calculation_invocation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                            write_indentation(buffer, indentation + 4)?;
                            writeln!(
                                buffer,
                                "offset = serializeFieldHeader(dataView, offset, {}n, \
                                    payloadSize, {});",
                                field.index,
                                integer_encoded(&field.r#type),
                            )?;
                            write_serialization_invocation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                            write_indentation(buffer, indentation + 3)?;
                            writeln!(buffer, "}}")?;
                        }
                    }
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                }
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "return offset;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "export function deserialize(")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "dataView: DataView,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "offset: number,")?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "): [number, ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(In))?;
                writeln!(buffer, "] {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "return [0, undefined!];")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "export function outToIn(value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                write!(buffer, "): ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(In))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "return undefined!;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;
            }
            schema::DeclarationVariant::Choice => {
                write_choice(
                    buffer,
                    indentation,
                    &imports,
                    namespace,
                    &declaration.name,
                    &declaration.fields,
                    Out,
                )?;

                writeln!(buffer)?;

                write_choice(
                    buffer,
                    indentation,
                    &imports,
                    namespace,
                    &declaration.name,
                    &declaration.fields,
                    In,
                )?;

                writeln!(buffer)?;

                write_indentation(buffer, indentation)?;
                write!(buffer, "export namespace ")?;
                write_identifier(buffer, &declaration.name, Pascal, None)?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "export function size(value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                writeln!(buffer, "): number {{")?;
                write_indentation(buffer, indentation + 2)?;
                if declaration.fields.is_empty() {
                    writeln!(buffer, "return 0;")?;
                } else {
                    writeln!(buffer, "let payloadSize = 0;")?;
                    writeln!(buffer)?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "switch (value.field) {{")?;
                    for field in &declaration.fields {
                        write_indentation(buffer, indentation + 3)?;
                        write!(buffer, "case '")?;
                        write_identifier(buffer, &field.name, Camel, None)?;
                        writeln!(buffer, "': {{")?;
                        if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                        } else {
                            write_indentation(buffer, indentation + 4)?;
                            writeln!(buffer, "const payload = value.value;")?;
                            write_size_calculation_invocation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                        }
                        write_indentation(buffer, indentation + 4)?;
                        write!(
                            buffer,
                            "return fieldHeaderSize({}n, payloadSize, {}) + payloadSize",
                            field.index,
                            integer_encoded(&field.r#type),
                        )?;
                        match field.rule {
                            schema::Rule::Asymmetric | schema::Rule::Optional => {
                                writeln!(buffer, " + size(value.fallback);")?;
                            }
                            schema::Rule::Required => {
                                writeln!(buffer, ";")?;
                            }
                        }
                        write_indentation(buffer, indentation + 3)?;
                        writeln!(buffer, "}}")?;
                    }
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                }
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "export function serialize(")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "dataView: DataView,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "offset: number,")?;
                write_indentation(buffer, indentation + 2)?;
                write!(buffer, "value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                writeln!(buffer, ",")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "): number {{")?;
                write_indentation(buffer, indentation + 2)?;
                if declaration.fields.is_empty() {
                    writeln!(buffer, "return offset;")?;
                } else {
                    writeln!(buffer, "let payloadSize = 0;")?;
                    writeln!(buffer)?;
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "switch (value.field) {{")?;
                    for field in &declaration.fields {
                        write_indentation(buffer, indentation + 3)?;
                        write!(buffer, "case '")?;
                        write_identifier(buffer, &field.name, Camel, None)?;
                        writeln!(buffer, "': {{")?;
                        write_indentation(buffer, indentation + 4)?;
                        if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
                            writeln!(
                                buffer,
                                "offset = serializeFieldHeader(dataView, offset, {}n, 0, {});",
                                field.index,
                                integer_encoded(&field.r#type),
                            )?;
                        } else {
                            writeln!(buffer, "const payload = value.value;")?;
                            write_size_calculation_invocation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                            write_indentation(buffer, indentation + 4)?;
                            writeln!(
                                buffer,
                                "offset = serializeFieldHeader(dataView, offset, {}n, \
                                    payloadSize, {});",
                                field.index,
                                integer_encoded(&field.r#type),
                            )?;
                            write_serialization_invocation(
                                buffer,
                                indentation + 4,
                                &imports,
                                namespace,
                                &field.r#type.variant,
                                true,
                            )?;
                        }
                        match field.rule {
                            schema::Rule::Asymmetric | schema::Rule::Optional => {
                                write_indentation(buffer, indentation + 4)?;
                                writeln!(
                                    buffer,
                                    "offset = serialize(dataView, offset, value.fallback);",
                                )?;
                            }
                            schema::Rule::Required => {}
                        }
                        write_indentation(buffer, indentation + 4)?;
                        writeln!(buffer, "return offset;")?;
                        write_indentation(buffer, indentation + 3)?;
                        writeln!(buffer, "}}")?;
                    }
                    write_indentation(buffer, indentation + 2)?;
                    writeln!(buffer, "}}")?;
                }
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "export function deserialize(")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "dataView: DataView,")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "offset: number,")?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "): [number, ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(In))?;
                writeln!(buffer, "] {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "return [0, undefined!];")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                writeln!(buffer)?;
                write_indentation(buffer, indentation + 1)?;
                write!(buffer, "export function outToIn(value: ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(Out))?;
                write!(buffer, "): ")?;
                write_identifier(buffer, &declaration.name, Pascal, Some(In))?;
                writeln!(buffer, " {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "return undefined!;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")?;
            }
        }

        if iter.peek().is_some() {
            writeln!(buffer)?;
        }
    }

    Ok(())
}

// Write a struct, including a trailing line break.
fn write_struct<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    name: &Identifier,
    fields: &[schema::Field],
    direction: Direction,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    write!(buffer, "export type ")?;
    write_identifier(buffer, name, Pascal, Some(direction))?;
    writeln!(buffer, " = {{")?;

    for field in fields {
        write_indentation(buffer, indentation + 1)?;
        write_identifier(buffer, &field.name, Camel, None)?;
        match field.rule {
            schema::Rule::Asymmetric => match direction {
                Direction::Out => {}
                Direction::In => {
                    write!(buffer, "?")?;
                }
            },
            schema::Rule::Optional => {
                write!(buffer, "?")?;
            }
            schema::Rule::Required => {}
        }
        write!(buffer, ": ")?;
        write_type(buffer, imports, namespace, &field.r#type.variant, direction)?;
        writeln!(buffer, ";")?;
    }

    write_indentation(buffer, indentation)?;
    writeln!(buffer, "}};")?;

    Ok(())
}

// Write a choice, including a trailing line break.
fn write_choice<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    name: &Identifier,
    fields: &[schema::Field],
    direction: Direction,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    write!(buffer, "export type ")?;
    write_identifier(buffer, name, Pascal, Some(direction))?;
    write!(buffer, " =")?;

    for field in fields {
        writeln!(buffer)?;
        write_indentation(buffer, indentation + 1)?;
        write!(buffer, "| {{ field: '")?;
        write_identifier(buffer, &field.name, Camel, None)?;
        write!(buffer, "'")?;
        let fallback = match field.rule {
            schema::Rule::Asymmetric => match direction {
                Direction::Out => true,
                Direction::In => false,
            },
            schema::Rule::Optional => true,
            schema::Rule::Required => false,
        };
        if fallback {
            if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
            } else {
                write!(buffer, "; value: ")?;
                write_type(buffer, imports, namespace, &field.r#type.variant, direction)?;
            }
            write!(buffer, "; fallback: ")?;
            write_identifier(buffer, name, Pascal, Some(direction))?;
        } else if matches!(field.r#type.variant, schema::TypeVariant::Unit) {
        } else {
            write!(buffer, "; value: ")?;
            write_type(buffer, imports, namespace, &field.r#type.variant, direction)?;
        }
        write!(buffer, " }}")?;
    }

    if fields.is_empty() {
        write!(buffer, " never")?;
    }

    writeln!(buffer, ";")?;

    Ok(())
}

// Write a type.
fn write_type<T: Write>(
    buffer: &mut T,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    type_variant: &schema::TypeVariant,
    direction: Direction,
) -> Result<(), fmt::Error> {
    match type_variant {
        schema::TypeVariant::Array(inner_type) => {
            write_type(buffer, imports, namespace, &inner_type.variant, direction)?;
            write!(buffer, "[]")?;
        }
        schema::TypeVariant::Bool => {
            write!(buffer, "boolean")?;
        }
        schema::TypeVariant::Bytes => {
            write!(buffer, "ArrayBuffer")?;
        }
        schema::TypeVariant::Custom(import, name) => {
            let type_namespace = schema::Namespace {
                components: import.as_ref().map_or_else(
                    || namespace.components.clone(),
                    |import| imports[import].components.clone(),
                ),
            };

            for component in type_namespace.components {
                write_identifier(buffer, &component, Pascal, None)?;
                write!(buffer, ".")?;
            }

            write_identifier(buffer, name, Pascal, Some(direction))?;
        }
        schema::TypeVariant::F64 => {
            write!(buffer, "number")?;
        }
        schema::TypeVariant::S64 | schema::TypeVariant::U64 => {
            write!(buffer, "bigint")?;
        }
        schema::TypeVariant::String => {
            write!(buffer, "string")?;
        }
        schema::TypeVariant::Unit => {
            write!(buffer, "undefined")?;
        }
    }

    Ok(())
}

// Write an identifier with an optional direction suffix in a way that Rust will be happy with.
fn write_identifier<T: Write>(
    buffer: &mut T,
    identifier: &Identifier,
    case: CaseConvention,
    suffix: Option<Direction>,
) -> Result<(), fmt::Error> {
    let identifier_with_suffix = suffix.map_or_else(
        || identifier.clone(),
        |suffix| {
            identifier.join(
                &match suffix {
                    Direction::In => "In",
                    Direction::Out => "Out",
                }
                .into(),
            )
        },
    );

    let converted_identifier = match case {
        CaseConvention::Camel => identifier_with_suffix.camel_case(),
        CaseConvention::Pascal => identifier_with_suffix.pascal_case(),
    };

    if TYPESCRIPT_KEYWORDS
        .iter()
        .any(|keyword| converted_identifier == *keyword)
    {
        write!(buffer, "_")?;
    }

    write!(buffer, "{}", converted_identifier)?;

    Ok(())
}

// Write the given level of indentation.
fn write_indentation<T: Write>(buffer: &mut T, indentation: usize) -> Result<(), fmt::Error> {
    for _ in 0..indentation {
        write!(buffer, "{}", INDENTATION)?;
    }

    Ok(())
}

// Write the logic to invoke the size calculation logic for a value.
//
// Context variables:
// - `payloadSize`
// - `payload`
#[allow(clippy::too_many_lines)]
fn write_size_calculation_invocation<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    type_variant: &schema::TypeVariant,
    is_field: bool,
) -> Result<(), fmt::Error> {
    match type_variant {
        schema::TypeVariant::Array(inner_type) => match &inner_type.variant {
            schema::TypeVariant::Array(_)
            | schema::TypeVariant::Bytes
            | schema::TypeVariant::Custom(_, _)
            | schema::TypeVariant::String => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "let arraySize = 0;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const oldPayload = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "for (let i = 0; i < oldPayload.length; ++i) {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "const payload = oldPayload[i];")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "let payloadSize = 0;")?;
                write_size_calculation_invocation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(
                    buffer,
                    "arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;",
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = arraySize;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Bool | schema::TypeVariant::S64 | schema::TypeVariant::U64 => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "let arraySize = 0;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const oldPayload = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "for (let i = 0; i < oldPayload.length; ++i) {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "const payload = oldPayload[i];")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "let payloadSize = 0;")?;
                write_size_calculation_invocation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "arraySize += payloadSize;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = arraySize;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::F64 => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "payloadSize = 8 * payload.length;")
            }
            schema::TypeVariant::Unit => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const oldPayload = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "const payload = BigInt(oldPayload.length);")?;
                write_size_calculation_invocation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &schema::TypeVariant::U64,
                    is_field,
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
        },
        schema::TypeVariant::Bool => {
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "if (payload) {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 1;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}} else {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 0;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(buffer, "payloadSize = 1;")
            }
        }
        schema::TypeVariant::Bytes => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "payloadSize = payload.byteLength;")
        }
        schema::TypeVariant::String => {
            write_indentation(buffer, indentation)?;
            writeln!(
                buffer,
                "payloadSize = textEncoder.encode(payload).byteLength;",
            )
        }
        schema::TypeVariant::Custom(import, name) => {
            let type_namespace = schema::Namespace {
                components: import.as_ref().map_or_else(
                    || namespace.components.clone(),
                    |import| imports[import].components.clone(),
                ),
            };

            write_indentation(buffer, indentation)?;
            write!(buffer, "payloadSize = ")?;

            for component in type_namespace.components {
                write_identifier(buffer, &component, Pascal, None)?;
                write!(buffer, ".")?;
            }

            write_identifier(buffer, name, Pascal, None)?;
            writeln!(buffer, ".size(payload);")
        }
        schema::TypeVariant::F64 => {
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "dataView64.setFloat64(0, payload, true);")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "if (dataView64.getBigUint64(0, true) === 0n) {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 0;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}} else {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 8;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(buffer, "payloadSize = 8;")
            }
        }
        schema::TypeVariant::S64 => {
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const zigzag = zigzagEncode(payload);")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "if (zigzag === 0n) {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "payloadSize = 0;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}} else if (zigzag < 567_382_630_219_904n) {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "payloadSize = varintSizeFromValue(zigzag);")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}} else {{")?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(buffer, "payloadSize = 8;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(
                    buffer,
                    "payloadSize = varintSizeFromValue(zigzagEncode(payload));",
                )
            }
        }
        schema::TypeVariant::U64 => {
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "if (payload === 0n) {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 0;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}} else if (payload < 567_382_630_219_904n) {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = varintSizeFromValue(payload);")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}} else {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "payloadSize = 8;")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(buffer, "payloadSize = varintSizeFromValue(payload);")
            }
        }
        schema::TypeVariant::Unit => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "payloadSize = 0;")
        }
    }
}

// Write the logic to invoke the serialization logic for a value, including a trailing line break.
//
// Context variables:
// - `dataView`
// - `offset`
// - `payloadSize`
// - `payload`
#[allow(clippy::too_many_lines)]
fn write_serialization_invocation<T: Write>(
    buffer: &mut T,
    indentation: usize,
    imports: &BTreeMap<Identifier, schema::Namespace>,
    namespace: &schema::Namespace,
    type_variant: &schema::TypeVariant,
    is_field: bool,
) -> Result<(), fmt::Error> {
    match type_variant {
        schema::TypeVariant::Array(inner_type) => match &inner_type.variant {
            schema::TypeVariant::Array(_)
            | schema::TypeVariant::Bytes
            | schema::TypeVariant::Custom(_, _)
            | schema::TypeVariant::String => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const oldPayload = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "for (const payload of oldPayload) {{")?;
                write_size_calculation_invocation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 2)?;
                writeln!(
                    buffer,
                    "offset = serializeVarint(dataView, offset, BigInt(payloadSize));",
                )?;
                write_serialization_invocation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Bool
            | schema::TypeVariant::S64
            | schema::TypeVariant::U64
            | schema::TypeVariant::F64 => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const oldPayload = payload;")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "for (const payload of oldPayload) {{")?;
                write_size_calculation_invocation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_serialization_invocation(
                    buffer,
                    indentation + 2,
                    imports,
                    namespace,
                    &inner_type.variant,
                    false,
                )?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "}}")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
            schema::TypeVariant::Unit => {
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "{{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "const varint = BigInt(payload.length);")?;
                write_u64_serialization_invocation(buffer, indentation + 1, is_field)?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            }
        },
        schema::TypeVariant::Bool => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "{{")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "const varint = payload ? 1n : 0n;")?;
            write_u64_serialization_invocation(buffer, indentation + 1, is_field)?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "}}")
        }
        schema::TypeVariant::Bytes => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "{{")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "const buffer = new Uint8Array(payload);")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "for (let i = 0; i < buffer.byteLength; ++i) {{")?;
            write_indentation(buffer, indentation + 2)?;
            writeln!(buffer, "dataView.setUint8(offset + i, buffer[i]);")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "}}")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "offset += buffer.byteLength;")?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "}}")
        }
        schema::TypeVariant::Custom(import, name) => {
            let type_namespace = schema::Namespace {
                components: import.as_ref().map_or_else(
                    || namespace.components.clone(),
                    |import| imports[import].components.clone(),
                ),
            };

            write_indentation(buffer, indentation)?;
            write!(buffer, "offset = ")?;

            for component in type_namespace.components {
                write_identifier(buffer, &component, Pascal, None)?;
                write!(buffer, ".")?;
            }

            write_identifier(buffer, name, Pascal, None)?;
            writeln!(buffer, ".serialize(dataView, offset, payload);")
        }
        schema::TypeVariant::F64 => {
            write_indentation(buffer, indentation)?;
            if is_field {
                writeln!(buffer, "if (payloadSize !== 0) {{")?;
                write_indentation(buffer, indentation + 1)?;
                writeln!(buffer, "dataView.setFloat64(offset, payload, true);")?;
                write_indentation(buffer, indentation)?;
                writeln!(buffer, "}}")
            } else {
                writeln!(buffer, "dataView.setFloat64(offset, payload, true);")
            }
        }
        schema::TypeVariant::S64 => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "{{")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "const varint = zigzagEncode(payload);")?;
            write_u64_serialization_invocation(buffer, indentation + 1, is_field)?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "}}")
        }
        schema::TypeVariant::String => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "{{")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "const buffer = textEncoder.encode(payload);")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "for (let i = 0; i < buffer.byteLength; ++i) {{")?;
            write_indentation(buffer, indentation + 2)?;
            writeln!(buffer, "dataView.setUint8(offset + i, buffer[i]);")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "}}")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "offset += buffer.byteLength;")?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "}}")
        }
        schema::TypeVariant::U64 => {
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "{{")?;
            write_indentation(buffer, indentation + 1)?;
            writeln!(buffer, "const varint = payload;")?;
            write_u64_serialization_invocation(buffer, indentation + 1, is_field)?;
            write_indentation(buffer, indentation)?;
            writeln!(buffer, "}}")
        }
        schema::TypeVariant::Unit => Ok(()),
    }
}

// Write the logic to invoke the serialization logic for a varint, including a trailing line break.
//
// Context variables:
// - `dataView`
// - `offset`
// - `varint`
fn write_u64_serialization_invocation<T: Write>(
    buffer: &mut T,
    indentation: usize,
    is_field: bool,
) -> Result<(), fmt::Error> {
    write_indentation(buffer, indentation)?;
    if is_field {
        writeln!(buffer, "if (varint > 567_382_630_219_903n) {{")?;
        write_indentation(buffer, indentation + 1)?;
        writeln!(buffer, "dataView.setBigUint64(offset, varint, true);")?;
        write_indentation(buffer, indentation + 1)?;
        writeln!(buffer, "offset += 8;")?;
        write_indentation(buffer, indentation)?;
        writeln!(buffer, "}} else if (varint !== 0n) {{")?;
        write_indentation(buffer, indentation + 1)?;
        writeln!(
            buffer,
            "offset = serializeVarint(dataView, offset, varint);",
        )?;
        write_indentation(buffer, indentation)?;
        writeln!(buffer, "}}")
    } else {
        writeln!(
            buffer,
            "offset = serializeVarint(dataView, offset, varint);",
        )
    }
}

// Write the logic to invoke the deserialization logic for a value, including a trailing line break.
//
// Context variables:
// - `dataView`
// - `offset`
// - `payload`
#[allow(clippy::unnecessary_wraps)] // DO NOT COMMIT
fn _write_deserialization_invocation<T: Write>(
    _buffer: &mut T,
    _indentation: usize,
    _imports: &BTreeMap<Identifier, schema::Namespace>,
    _namespace: &schema::Namespace,
    _type_variant: &schema::TypeVariant,
    _is_field: bool,
) -> Result<(), fmt::Error> {
    Ok(())
}

// Determine whether a type is encoded as a varint.
fn integer_encoded(r#type: &schema::Type) -> bool {
    match &r#type.variant {
        schema::TypeVariant::Bool | schema::TypeVariant::S64 | schema::TypeVariant::U64 => true,
        schema::TypeVariant::Array(_)
        | schema::TypeVariant::Bytes
        | schema::TypeVariant::Custom(_, _)
        | schema::TypeVariant::F64
        | schema::TypeVariant::String
        | schema::TypeVariant::Unit => false,
    }
}

#[cfg(test)]
mod tests {
    use {
        crate::{generate_typescript::generate, schema_loader::load_schemas, validator::validate},
        std::path::Path,
    };

    #[allow(clippy::too_many_lines)]
    #[test]
    fn generate_example() {
        let schemas = load_schemas(Path::new("integration_tests/types/main.t")).unwrap();
        validate(&schemas).unwrap();

        assert_eq!(
            generate("0.0.0", &schemas),
            "\
// This file was automatically generated by Typical 0.0.0.
// Visit https://github.com/stepchowfun/typical for more information.

/* eslint-disable */

function zigzagEncode(value: bigint): bigint {
  const twice = value << 1n;
  return value < 0n ? -1n - twice : twice;
}

function zigzagDecode(value: bigint): bigint {
  const half = (value + 1n) >> 1n;
  return (value & 1n) === 0n ? half : -half;
}

function varintSizeFromValue(value: bigint): number {
  if (value < 128n) {
    return 1;
  } else if (value < 16_512n) {
    return 2;
  } else if (value < 2_113_664n) {
    return 3;
  } else if (value < 270_549_120n) {
    return 4;
  } else if (value < 34_630_287_488n) {
    return 5;
  } else if (value < 4_432_676_798_592n) {
    return 6;
  } else if (value < 567_382_630_219_904n) {
    return 7;
  } else if (value < 72_624_976_668_147_840n) {
    return 8;
  } else {
    return 9;
  }
}

function varintSizeFromFirstByte(firstByte: number): number {
  let trailingZeros = 0;

  while (trailingZeros < 8 && (firstByte & 1) !== 1) {
    ++trailingZeros;
    firstByte >>= 1;
  }

  return trailingZeros + 1;
}

const dataView64 = new DataView(new ArrayBuffer(8));

function serializeVarint(
  dataView: DataView,
  offset: number,
  value: bigint,
): number {
  if (value < 128n) {
    dataView.setUint8(offset, Number(value << 1n) | 0b0000_0001);
    return offset + 1;
  } else if (value < 16_512n) {
    value -= 128n;
    dataView.setUint8(offset, Number((value << 2n) % 256n) | 0b0000_0010);
    dataView.setUint8(offset + 1, Number(value >> 6n));
    return offset + 2;
  } else if (value < 2_113_664n) {
    value -= 16_512n;
    dataView.setUint8(offset, Number((value << 3n) % 256n) | 0b0000_0100);
    dataView.setUint16(offset + 1, Number((value >> 5n) % 65_536n), true);
    return offset + 3;
  } else if (value < 270_549_120n) {
    value -= 2_113_664n;
    dataView.setUint8(offset, Number((value << 4n) % 256n) | 0b0000_1000);
    dataView.setUint8(offset + 1, Number((value >> 4n) % 256n));
    dataView.setUint16(offset + 2, Number((value >> 12n) % 65_536n), true);
    return offset + 4;
  } else if (value < 34_630_287_488n) {
    value -= 270_549_120n;
    dataView.setUint8(offset, Number((value << 5n) % 256n) | 0b0001_0000);
    dataView.setUint32(
      offset + 1,
      Number((value >> 3n) % 4_294_967_296n),
      true,
    );
    return offset + 5;
  } else if (value < 4_432_676_798_592n) {
    value -= 34_630_287_488n;
    dataView.setUint8(offset, Number((value << 6n) % 256n) | 0b0010_0000);
    dataView.setUint8(offset + 1, Number((value >> 2n) % 256n));
    dataView.setUint32(
      offset + 2,
      Number((value >> 10n) % 4_294_967_296n),
      true,
    );
    return offset + 6;
  } else if (value < 567_382_630_219_904n) {
    value -= 4_432_676_798_592n;
    dataView.setUint8(offset, Number((value << 7n) % 256n) | 0b0100_0000);
    dataView.setUint16(offset + 1, Number((value >> 1n) % 65_536n), true);
    dataView.setUint32(
      offset + 3,
      Number((value >> 17n) % 4_294_967_296n),
      true,
    );
    return offset + 7;
  } else if (value < 72_624_976_668_147_840n) {
    value -= 567_382_630_219_904n;
    dataView.setUint8(offset, 0b1000_0000);
    dataView.setUint8(offset + 1, Number(value % 256n));
    dataView.setUint16(offset + 2, Number((value >> 8n) % 65_536n), true);
    dataView.setUint32(
      offset + 4,
      Number((value >> 24n) % 4_294_967_296n),
      true,
    );
    return offset + 8;
  } else {
    value -= 72_624_976_668_147_840n;
    dataView.setUint8(offset, 0b0000_0000);
    dataView.setBigUint64(offset + 1, value, true);
    return offset + 9;
  }
}

function deserializeVarint(
  dataView: DataView,
  offset: number,
): [number, bigint] {
  const firstByte = dataView.getUint8(offset);
  const sizeMinusOne = varintSizeFromFirstByte(firstByte) - 1;
  const offsetPlusOne = offset + 1;
  dataView64.setBigUint64(offset, 0n, true);
  for (let i = 0; i < sizeMinusOne; ++i) {
    dataView64.setUint8(i, dataView.getUint8(offsetPlusOne + i));
  }
  const remainingBytesValue = dataView64.getBigUint64(0, true);
  switch (sizeMinusOne) {
    case 0:
      return [offset + 1, BigInt(firstByte >> 1)];
    case 1:
      return [
        offset + 2,
        128n + BigInt(firstByte >> 2) + (remainingBytesValue << 6n),
      ];
    case 2:
      return [
        offset + 3,
        16_512n + BigInt(firstByte >> 3) + (remainingBytesValue << 5n),
      ];
    case 3:
      return [
        offset + 4,
        2_113_664n + BigInt(firstByte >> 4) + (remainingBytesValue << 4n),
      ];
    case 4:
      return [
        offset + 5,
        270_549_120n + BigInt(firstByte >> 5) + (remainingBytesValue << 3n),
      ];
    case 5:
      return [
        offset + 6,
        34_630_287_488n + BigInt(firstByte >> 6) + (remainingBytesValue << 2n),
      ];
    case 6:
      return [
        offset + 7,
        4_432_676_798_592n +
          BigInt(firstByte >> 7) +
          (remainingBytesValue << 1n),
      ];
    case 7:
      return [offset + 8, 567_382_630_219_904n + remainingBytesValue];
    default:
      return [
        offset + 9,
        (72_624_976_668_147_840n + remainingBytesValue) %
          18_446_744_073_709_551_616n,
      ];
  }
}

function fieldHeaderSize(
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {
  switch (payloadSize) {
    case 0:
      return varintSizeFromValue((index << 2n) | BigInt(0b00));
    case 8:
      return varintSizeFromValue((index << 2n) | BigInt(0b01));
    default:
      if (integerEncoded) {
        return varintSizeFromValue((index << 2n) | BigInt(0b11));
      } else {
        return (
          varintSizeFromValue((index << 2n) | BigInt(0b10)) +
          varintSizeFromValue(BigInt(payloadSize))
        );
      }
  }
}

function serializeFieldHeader(
  dataView: DataView,
  offset: number,
  index: bigint,
  payloadSize: number,
  integerEncoded: boolean,
): number {
  switch (payloadSize) {
    case 0:
      return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b00));
    case 1:
      return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b01));
    default:
      if (integerEncoded) {
        return serializeVarint(dataView, offset, (index << 2n) | BigInt(0b11));
      } else {
        offset = serializeVarint(
          dataView,
          offset,
          (index << 2n) | BigInt(0b10),
        );
        return serializeVarint(dataView, offset, BigInt(payloadSize));
      }
  }
}

function deserializeFieldHeader(
  dataView: DataView,
  offset: number,
): [number, bigint, number] {
  const [newOffset, tag] = deserializeVarint(dataView, offset);
  offset = newOffset;

  const index = tag >> 2n;

  let size;
  switch (tag & 3n) {
    case 0n:
      size = 0;
    case 1n:
      size = 8;
    case 2n:
      const [newNewOffset, sizeValue] = deserializeVarint(dataView, offset);
      offset = newNewOffset;
      size = Number(sizeValue);
    default:
      size = varintSizeFromFirstByte(dataView.getUint8(offset));
  }

  return [offset, index, size];
}

const textEncoder = new TextEncoder();

export namespace CircularDependency {
  export namespace Dependency {
    export namespace Main {
      export type StructFromBelowOut = {
        x: CircularDependency.Main.StructFromAboveOut;
      };

      export type StructFromBelowIn = {
        x: CircularDependency.Main.StructFromAboveIn;
      };

      export namespace StructFromBelow {
        export function size(value: StructFromBelowOut): number {
          let valueSize = 0;
          let payloadSize = 0;

          {
            const payload = value.x;
            payloadSize = CircularDependency.Main.StructFromAbove.size(payload);
            valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }

          return valueSize;
        }

        export function serialize(
          dataView: DataView,
          offset: number,
          value: StructFromBelowOut,
        ): number {
          let payloadSize = 0;

          {
            const payload = value.x;
            payloadSize = CircularDependency.Main.StructFromAbove.size(payload);
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            offset = CircularDependency.Main.StructFromAbove.serialize(dataView, offset, payload);
          }

          return offset;
        }

        export function deserialize(
          dataView: DataView,
          offset: number,
        ): [number, StructFromBelowIn] {
          return [0, undefined!];
        }

        export function outToIn(value: StructFromBelowOut): StructFromBelowIn {
          return undefined!;
        }
      }
    }
  }

  export namespace Main {
    export type StructFromAboveOut = {
    };

    export type StructFromAboveIn = {
    };

    export namespace StructFromAbove {
      export function size(value: StructFromAboveOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: StructFromAboveOut,
      ): number {
        let payloadSize = 0;

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, StructFromAboveIn] {
        return [0, undefined!];
      }

      export function outToIn(value: StructFromAboveOut): StructFromAboveIn {
        return undefined!;
      }
    }
  }
}

export namespace Comprehensive {
  export namespace Bar {
    export type BarOut =
      | { field: 'aRequired' }
      | { field: 'bRequired'; value: number }
      | { field: 'cRequired'; value: bigint }
      | { field: 'dRequired'; value: bigint }
      | { field: 'eRequired'; value: boolean }
      | { field: 'fRequired'; value: ArrayBuffer }
      | { field: 'gRequired'; value: string }
      | { field: 'hRequired'; value: undefined[] }
      | { field: 'iRequired'; value: number[] }
      | { field: 'jRequired'; value: bigint[] }
      | { field: 'kRequired'; value: bigint[] }
      | { field: 'lRequired'; value: boolean[] }
      | { field: 'mRequired'; value: ArrayBuffer[] }
      | { field: 'nRequired'; value: string[] }
      | { field: 'oRequired'; value: string[][] }
      | { field: 'aAsymmetric'; fallback: BarOut }
      | { field: 'bAsymmetric'; value: number; fallback: BarOut }
      | { field: 'cAsymmetric'; value: bigint; fallback: BarOut }
      | { field: 'dAsymmetric'; value: bigint; fallback: BarOut }
      | { field: 'eAsymmetric'; value: boolean; fallback: BarOut }
      | { field: 'fAsymmetric'; value: ArrayBuffer; fallback: BarOut }
      | { field: 'gAsymmetric'; value: string; fallback: BarOut }
      | { field: 'hAsymmetric'; value: undefined[]; fallback: BarOut }
      | { field: 'iAsymmetric'; value: number[]; fallback: BarOut }
      | { field: 'jAsymmetric'; value: bigint[]; fallback: BarOut }
      | { field: 'kAsymmetric'; value: bigint[]; fallback: BarOut }
      | { field: 'lAsymmetric'; value: boolean[]; fallback: BarOut }
      | { field: 'mAsymmetric'; value: ArrayBuffer[]; fallback: BarOut }
      | { field: 'nAsymmetric'; value: string[]; fallback: BarOut }
      | { field: 'oAsymmetric'; value: string[][]; fallback: BarOut }
      | { field: 'aOptional'; fallback: BarOut }
      | { field: 'bOptional'; value: number; fallback: BarOut }
      | { field: 'cOptional'; value: bigint; fallback: BarOut }
      | { field: 'dOptional'; value: bigint; fallback: BarOut }
      | { field: 'eOptional'; value: boolean; fallback: BarOut }
      | { field: 'fOptional'; value: ArrayBuffer; fallback: BarOut }
      | { field: 'gOptional'; value: string; fallback: BarOut }
      | { field: 'hOptional'; value: undefined[]; fallback: BarOut }
      | { field: 'iOptional'; value: number[]; fallback: BarOut }
      | { field: 'jOptional'; value: bigint[]; fallback: BarOut }
      | { field: 'kOptional'; value: bigint[]; fallback: BarOut }
      | { field: 'lOptional'; value: boolean[]; fallback: BarOut }
      | { field: 'mOptional'; value: ArrayBuffer[]; fallback: BarOut }
      | { field: 'nOptional'; value: string[]; fallback: BarOut }
      | { field: 'oOptional'; value: string[][]; fallback: BarOut };

    export type BarIn =
      | { field: 'aRequired' }
      | { field: 'bRequired'; value: number }
      | { field: 'cRequired'; value: bigint }
      | { field: 'dRequired'; value: bigint }
      | { field: 'eRequired'; value: boolean }
      | { field: 'fRequired'; value: ArrayBuffer }
      | { field: 'gRequired'; value: string }
      | { field: 'hRequired'; value: undefined[] }
      | { field: 'iRequired'; value: number[] }
      | { field: 'jRequired'; value: bigint[] }
      | { field: 'kRequired'; value: bigint[] }
      | { field: 'lRequired'; value: boolean[] }
      | { field: 'mRequired'; value: ArrayBuffer[] }
      | { field: 'nRequired'; value: string[] }
      | { field: 'oRequired'; value: string[][] }
      | { field: 'aAsymmetric' }
      | { field: 'bAsymmetric'; value: number }
      | { field: 'cAsymmetric'; value: bigint }
      | { field: 'dAsymmetric'; value: bigint }
      | { field: 'eAsymmetric'; value: boolean }
      | { field: 'fAsymmetric'; value: ArrayBuffer }
      | { field: 'gAsymmetric'; value: string }
      | { field: 'hAsymmetric'; value: undefined[] }
      | { field: 'iAsymmetric'; value: number[] }
      | { field: 'jAsymmetric'; value: bigint[] }
      | { field: 'kAsymmetric'; value: bigint[] }
      | { field: 'lAsymmetric'; value: boolean[] }
      | { field: 'mAsymmetric'; value: ArrayBuffer[] }
      | { field: 'nAsymmetric'; value: string[] }
      | { field: 'oAsymmetric'; value: string[][] }
      | { field: 'aOptional'; fallback: BarIn }
      | { field: 'bOptional'; value: number; fallback: BarIn }
      | { field: 'cOptional'; value: bigint; fallback: BarIn }
      | { field: 'dOptional'; value: bigint; fallback: BarIn }
      | { field: 'eOptional'; value: boolean; fallback: BarIn }
      | { field: 'fOptional'; value: ArrayBuffer; fallback: BarIn }
      | { field: 'gOptional'; value: string; fallback: BarIn }
      | { field: 'hOptional'; value: undefined[]; fallback: BarIn }
      | { field: 'iOptional'; value: number[]; fallback: BarIn }
      | { field: 'jOptional'; value: bigint[]; fallback: BarIn }
      | { field: 'kOptional'; value: bigint[]; fallback: BarIn }
      | { field: 'lOptional'; value: boolean[]; fallback: BarIn }
      | { field: 'mOptional'; value: ArrayBuffer[]; fallback: BarIn }
      | { field: 'nOptional'; value: string[]; fallback: BarIn }
      | { field: 'oOptional'; value: string[][]; fallback: BarIn };

    export namespace Bar {
      export function size(value: BarOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'aRequired': {
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'bRequired': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize;
          }
          case 'cRequired': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(2n, payloadSize, true) + payloadSize;
          }
          case 'dRequired': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(3n, payloadSize, true) + payloadSize;
          }
          case 'eRequired': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(4n, payloadSize, true) + payloadSize;
          }
          case 'fRequired': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize;
          }
          case 'gRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize;
          }
          case 'hRequired': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(7n, payloadSize, false) + payloadSize;
          }
          case 'iRequired': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize;
          }
          case 'jRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(9n, payloadSize, false) + payloadSize;
          }
          case 'kRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize;
          }
          case 'lRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(11n, payloadSize, false) + payloadSize;
          }
          case 'mRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(12n, payloadSize, false) + payloadSize;
          }
          case 'nRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(13n, payloadSize, false) + payloadSize;
          }
          case 'oRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(14n, payloadSize, false) + payloadSize;
          }
          case 'aAsymmetric': {
            return fieldHeaderSize(16n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'bAsymmetric': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(17n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'cAsymmetric': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(18n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'dAsymmetric': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(19n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'eAsymmetric': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(20n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'fAsymmetric': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(21n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'gAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(22n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'hAsymmetric': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(23n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'iAsymmetric': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(24n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'jAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(25n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'kAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(26n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'lAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(27n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'mAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(28n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(29n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'oAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(30n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'aOptional': {
            return fieldHeaderSize(32n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'bOptional': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(33n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'cOptional': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            return fieldHeaderSize(34n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'dOptional': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            return fieldHeaderSize(35n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'eOptional': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            return fieldHeaderSize(36n, payloadSize, true) + payloadSize + size(value.fallback);
          }
          case 'fOptional': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            return fieldHeaderSize(37n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'gOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(38n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'hOptional': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            return fieldHeaderSize(39n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'iOptional': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            return fieldHeaderSize(40n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'jOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(41n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'kOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(42n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'lOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(43n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'mOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(44n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(45n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'oOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            return fieldHeaderSize(46n, payloadSize, false) + payloadSize + size(value.fallback);
          }
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: BarOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'aRequired': {
            offset = serializeFieldHeader(dataView, offset, 0n, 0, false);
            return offset;
          }
          case 'bRequired': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
            return offset;
          }
          case 'cRequired': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'dRequired': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'eRequired': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'fRequired': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'gRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'hRequired': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            return offset;
          }
          case 'iRequired': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
            return offset;
          }
          case 'jRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'kRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'lRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            return offset;
          }
          case 'mRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            return offset;
          }
          case 'nRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            return offset;
          }
          case 'oRequired': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = textEncoder.encode(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
            return offset;
          }
          case 'aAsymmetric': {
            offset = serializeFieldHeader(dataView, offset, 16n, 0, false);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'bAsymmetric': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'cAsymmetric': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'dAsymmetric': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 19n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'eAsymmetric': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 20n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'fAsymmetric': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 21n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'gAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 22n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'hAsymmetric': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 23n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'iAsymmetric': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 24n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'jAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 25n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'kAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 26n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'lAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 27n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'mAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 28n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 29n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'oAsymmetric': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 30n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = textEncoder.encode(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'aOptional': {
            offset = serializeFieldHeader(dataView, offset, 32n, 0, false);
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'bOptional': {
            const payload = value.value;
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 33n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'cOptional': {
            const payload = value.value;
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 34n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'dOptional': {
            const payload = value.value;
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 35n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'eOptional': {
            const payload = value.value;
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 36n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'fOptional': {
            const payload = value.value;
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 37n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'gOptional': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 38n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'hOptional': {
            const payload = value.value;
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 39n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'iOptional': {
            const payload = value.value;
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 40n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'jOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 41n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'kOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 42n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'lOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 43n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'mOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 44n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 45n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'oOptional': {
            const payload = value.value;
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 46n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = textEncoder.encode(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, BarIn] {
        return [0, undefined!];
      }

      export function outToIn(value: BarOut): BarIn {
        return undefined!;
      }
    }
  }

  export namespace Foo {
    export type FooOut = {
      aRequired: undefined;
      bRequired: number;
      cRequired: bigint;
      dRequired: bigint;
      eRequired: boolean;
      fRequired: ArrayBuffer;
      gRequired: string;
      hRequired: undefined[];
      iRequired: number[];
      jRequired: bigint[];
      kRequired: bigint[];
      lRequired: boolean[];
      mRequired: ArrayBuffer[];
      nRequired: string[];
      oRequired: string[][];
      aAsymmetric: undefined;
      bAsymmetric: number;
      cAsymmetric: bigint;
      dAsymmetric: bigint;
      eAsymmetric: boolean;
      fAsymmetric: ArrayBuffer;
      gAsymmetric: string;
      hAsymmetric: undefined[];
      iAsymmetric: number[];
      jAsymmetric: bigint[];
      kAsymmetric: bigint[];
      lAsymmetric: boolean[];
      mAsymmetric: ArrayBuffer[];
      nAsymmetric: string[];
      oAsymmetric: string[][];
      aOptional?: undefined;
      bOptional?: number;
      cOptional?: bigint;
      dOptional?: bigint;
      eOptional?: boolean;
      fOptional?: ArrayBuffer;
      gOptional?: string;
      hOptional?: undefined[];
      iOptional?: number[];
      jOptional?: bigint[];
      kOptional?: bigint[];
      lOptional?: boolean[];
      mOptional?: ArrayBuffer[];
      nOptional?: string[];
      oOptional?: string[][];
    };

    export type FooIn = {
      aRequired: undefined;
      bRequired: number;
      cRequired: bigint;
      dRequired: bigint;
      eRequired: boolean;
      fRequired: ArrayBuffer;
      gRequired: string;
      hRequired: undefined[];
      iRequired: number[];
      jRequired: bigint[];
      kRequired: bigint[];
      lRequired: boolean[];
      mRequired: ArrayBuffer[];
      nRequired: string[];
      oRequired: string[][];
      aAsymmetric?: undefined;
      bAsymmetric?: number;
      cAsymmetric?: bigint;
      dAsymmetric?: bigint;
      eAsymmetric?: boolean;
      fAsymmetric?: ArrayBuffer;
      gAsymmetric?: string;
      hAsymmetric?: undefined[];
      iAsymmetric?: number[];
      jAsymmetric?: bigint[];
      kAsymmetric?: bigint[];
      lAsymmetric?: boolean[];
      mAsymmetric?: ArrayBuffer[];
      nAsymmetric?: string[];
      oAsymmetric?: string[][];
      aOptional?: undefined;
      bOptional?: number;
      cOptional?: bigint;
      dOptional?: bigint;
      eOptional?: boolean;
      fOptional?: ArrayBuffer;
      gOptional?: string;
      hOptional?: undefined[];
      iOptional?: number[];
      jOptional?: bigint[];
      kOptional?: bigint[];
      lOptional?: boolean[];
      mOptional?: ArrayBuffer[];
      nOptional?: string[];
      oOptional?: string[][];
    };

    export namespace Foo {
      export function size(value: FooOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.aRequired;
          payloadSize = 0;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.bRequired;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.cRequired;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(2n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.dRequired;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(3n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.eRequired;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(4n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.fRequired;
          payloadSize = payload.byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.gRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.hRequired;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          valueSize += fieldHeaderSize(7n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.iRequired;
          payloadSize = 8 * payload.length;
          valueSize += fieldHeaderSize(8n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.jRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.kRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.lRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(11n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.mRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(12n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.oRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aAsymmetric;
          payloadSize = 0;
          valueSize += fieldHeaderSize(16n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.bAsymmetric;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(17n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.cAsymmetric;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          valueSize += fieldHeaderSize(18n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.dAsymmetric;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(19n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.eAsymmetric;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(20n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.fAsymmetric;
          payloadSize = payload.byteLength;
          valueSize += fieldHeaderSize(21n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.gAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(22n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.hAsymmetric;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          valueSize += fieldHeaderSize(23n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.iAsymmetric;
          payloadSize = 8 * payload.length;
          valueSize += fieldHeaderSize(24n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.jAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(25n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.kAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(26n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.lAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(27n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.mAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(28n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(29n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.oAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          valueSize += fieldHeaderSize(30n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.aOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = 0;
          }
          valueSize += fieldHeaderSize(32n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.bOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(33n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.cOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
          }
          valueSize += fieldHeaderSize(34n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.dOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
          }
          valueSize += fieldHeaderSize(35n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.eOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
          }
          valueSize += fieldHeaderSize(36n, payloadSize, true) + payloadSize;
        }

        {
          const payload = value.fOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = payload.byteLength;
          }
          valueSize += fieldHeaderSize(37n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.gOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(38n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.hOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
          }
          valueSize += fieldHeaderSize(39n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.iOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = 8 * payload.length;
          }
          valueSize += fieldHeaderSize(40n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.jOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(41n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.kOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(42n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.lOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(43n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.mOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(44n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(45n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.oOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
          }
          valueSize += fieldHeaderSize(46n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: FooOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.aRequired;
          payloadSize = 0;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
        }

        {
          const payload = value.bRequired;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          if (payloadSize !== 0) {
            dataView.setFloat64(offset, payload, true);
          }
        }

        {
          const payload = value.cRequired;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.dRequired;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.eRequired;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.fRequired;
          payloadSize = payload.byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const buffer = new Uint8Array(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.gRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.hRequired;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.iRequired;
          payloadSize = 8 * payload.length;
          offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 8;
              dataView.setFloat64(offset, payload, true);
            }
          }
        }

        {
          const payload = value.jRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(payload);
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.kRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.lRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 1;
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.mRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = payload.byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = new Uint8Array(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.nRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = textEncoder.encode(payload).byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = textEncoder.encode(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.oRequired;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = textEncoder.encode(payload).byteLength;
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  {
                    const buffer = textEncoder.encode(payload);
                    for (let i = 0; i < buffer.byteLength; ++i) {
                      dataView.setUint8(offset + i, buffer[i]);
                    }
                    offset += buffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.aAsymmetric;
          payloadSize = 0;
          offset = serializeFieldHeader(dataView, offset, 16n, payloadSize, false);
        }

        {
          const payload = value.bAsymmetric;
          dataView64.setFloat64(0, payload, true);
          if (dataView64.getBigUint64(0, true) === 0n) {
            payloadSize = 0;
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
          if (payloadSize !== 0) {
            dataView.setFloat64(offset, payload, true);
          }
        }

        {
          const payload = value.cAsymmetric;
          if (payload === 0n) {
            payloadSize = 0;
          } else if (payload < 567_382_630_219_904n) {
            payloadSize = varintSizeFromValue(payload);
          } else {
            payloadSize = 8;
          }
          offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, true);
          {
            const varint = payload;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.dAsymmetric;
          {
            const zigzag = zigzagEncode(payload);
            if (zigzag === 0n) {
              payloadSize = 0;
            } else if (zigzag < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(zigzag);
            } else {
              payloadSize = 8;
            }
          }
          offset = serializeFieldHeader(dataView, offset, 19n, payloadSize, true);
          {
            const varint = zigzagEncode(payload);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.eAsymmetric;
          if (payload) {
            payloadSize = 1;
          } else {
            payloadSize = 0;
          }
          offset = serializeFieldHeader(dataView, offset, 20n, payloadSize, true);
          {
            const varint = payload ? 1n : 0n;
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.fAsymmetric;
          payloadSize = payload.byteLength;
          offset = serializeFieldHeader(dataView, offset, 21n, payloadSize, false);
          {
            const buffer = new Uint8Array(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.gAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 22n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.hAsymmetric;
          {
            const oldPayload = payload;
            {
              const payload = BigInt(oldPayload.length);
              if (payload === 0n) {
                payloadSize = 0;
              } else if (payload < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(payload);
              } else {
                payloadSize = 8;
              }
            }
          }
          offset = serializeFieldHeader(dataView, offset, 23n, payloadSize, false);
          {
            const varint = BigInt(payload.length);
            if (varint > 567_382_630_219_903n) {
              dataView.setBigUint64(offset, varint, true);
              offset += 8;
            } else if (varint !== 0n) {
              offset = serializeVarint(dataView, offset, varint);
            }
          }
        }

        {
          const payload = value.iAsymmetric;
          payloadSize = 8 * payload.length;
          offset = serializeFieldHeader(dataView, offset, 24n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 8;
              dataView.setFloat64(offset, payload, true);
            }
          }
        }

        {
          const payload = value.jAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(payload);
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 25n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(payload);
              {
                const varint = payload;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.kAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 26n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = varintSizeFromValue(zigzagEncode(payload));
              {
                const varint = zigzagEncode(payload);
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.lAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = 1;
              arraySize += payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 27n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = 1;
              {
                const varint = payload ? 1n : 0n;
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.mAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = payload.byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 28n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = payload.byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = new Uint8Array(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.nAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              payloadSize = textEncoder.encode(payload).byteLength;
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 29n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              payloadSize = textEncoder.encode(payload).byteLength;
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const buffer = textEncoder.encode(payload);
                for (let i = 0; i < buffer.byteLength; ++i) {
                  dataView.setUint8(offset + i, buffer[i]);
                }
                offset += buffer.byteLength;
              }
            }
          }
        }

        {
          const payload = value.oAsymmetric;
          {
            let arraySize = 0;
            const oldPayload = payload;
            for (let i = 0; i < oldPayload.length; ++i) {
              const payload = oldPayload[i];
              let payloadSize = 0;
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
            }
            payloadSize = arraySize;
          }
          offset = serializeFieldHeader(dataView, offset, 30n, payloadSize, false);
          {
            const oldPayload = payload;
            for (const payload of oldPayload) {
              {
                let arraySize = 0;
                const oldPayload = payload;
                for (let i = 0; i < oldPayload.length; ++i) {
                  const payload = oldPayload[i];
                  let payloadSize = 0;
                  payloadSize = textEncoder.encode(payload).byteLength;
                  arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                }
                payloadSize = arraySize;
              }
              offset = serializeVarint(dataView, offset, BigInt(payloadSize));
              {
                const oldPayload = payload;
                for (const payload of oldPayload) {
                  payloadSize = textEncoder.encode(payload).byteLength;
                  offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                  {
                    const buffer = textEncoder.encode(payload);
                    for (let i = 0; i < buffer.byteLength; ++i) {
                      dataView.setUint8(offset + i, buffer[i]);
                    }
                    offset += buffer.byteLength;
                  }
                }
              }
            }
          }
        }

        {
          const payload = value.aOptional;
          if (payload !== undefined) {
            payloadSize = 0;
            offset = serializeFieldHeader(dataView, offset, 32n, payloadSize, false);
          }
        }

        {
          const payload = value.bOptional;
          if (payload !== undefined) {
            dataView64.setFloat64(0, payload, true);
            if (dataView64.getBigUint64(0, true) === 0n) {
              payloadSize = 0;
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 33n, payloadSize, false);
            if (payloadSize !== 0) {
              dataView.setFloat64(offset, payload, true);
            }
          }
        }

        {
          const payload = value.cOptional;
          if (payload !== undefined) {
            if (payload === 0n) {
              payloadSize = 0;
            } else if (payload < 567_382_630_219_904n) {
              payloadSize = varintSizeFromValue(payload);
            } else {
              payloadSize = 8;
            }
            offset = serializeFieldHeader(dataView, offset, 34n, payloadSize, true);
            {
              const varint = payload;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.dOptional;
          if (payload !== undefined) {
            {
              const zigzag = zigzagEncode(payload);
              if (zigzag === 0n) {
                payloadSize = 0;
              } else if (zigzag < 567_382_630_219_904n) {
                payloadSize = varintSizeFromValue(zigzag);
              } else {
                payloadSize = 8;
              }
            }
            offset = serializeFieldHeader(dataView, offset, 35n, payloadSize, true);
            {
              const varint = zigzagEncode(payload);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.eOptional;
          if (payload !== undefined) {
            if (payload) {
              payloadSize = 1;
            } else {
              payloadSize = 0;
            }
            offset = serializeFieldHeader(dataView, offset, 36n, payloadSize, true);
            {
              const varint = payload ? 1n : 0n;
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.fOptional;
          if (payload !== undefined) {
            payloadSize = payload.byteLength;
            offset = serializeFieldHeader(dataView, offset, 37n, payloadSize, false);
            {
              const buffer = new Uint8Array(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.gOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 38n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.hOptional;
          if (payload !== undefined) {
            {
              const oldPayload = payload;
              {
                const payload = BigInt(oldPayload.length);
                if (payload === 0n) {
                  payloadSize = 0;
                } else if (payload < 567_382_630_219_904n) {
                  payloadSize = varintSizeFromValue(payload);
                } else {
                  payloadSize = 8;
                }
              }
            }
            offset = serializeFieldHeader(dataView, offset, 39n, payloadSize, false);
            {
              const varint = BigInt(payload.length);
              if (varint > 567_382_630_219_903n) {
                dataView.setBigUint64(offset, varint, true);
                offset += 8;
              } else if (varint !== 0n) {
                offset = serializeVarint(dataView, offset, varint);
              }
            }
          }
        }

        {
          const payload = value.iOptional;
          if (payload !== undefined) {
            payloadSize = 8 * payload.length;
            offset = serializeFieldHeader(dataView, offset, 40n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 8;
                dataView.setFloat64(offset, payload, true);
              }
            }
          }
        }

        {
          const payload = value.jOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(payload);
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 41n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(payload);
                {
                  const varint = payload;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.kOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 42n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = varintSizeFromValue(zigzagEncode(payload));
                {
                  const varint = zigzagEncode(payload);
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.lOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = 1;
                arraySize += payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 43n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = 1;
                {
                  const varint = payload ? 1n : 0n;
                  offset = serializeVarint(dataView, offset, varint);
                }
              }
            }
          }
        }

        {
          const payload = value.mOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = payload.byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 44n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = payload.byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = new Uint8Array(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
          }
        }

        {
          const payload = value.nOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                payloadSize = textEncoder.encode(payload).byteLength;
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 45n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                payloadSize = textEncoder.encode(payload).byteLength;
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const buffer = textEncoder.encode(payload);
                  for (let i = 0; i < buffer.byteLength; ++i) {
                    dataView.setUint8(offset + i, buffer[i]);
                  }
                  offset += buffer.byteLength;
                }
              }
            }
          }
        }

        {
          const payload = value.oOptional;
          if (payload !== undefined) {
            {
              let arraySize = 0;
              const oldPayload = payload;
              for (let i = 0; i < oldPayload.length; ++i) {
                const payload = oldPayload[i];
                let payloadSize = 0;
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
              }
              payloadSize = arraySize;
            }
            offset = serializeFieldHeader(dataView, offset, 46n, payloadSize, false);
            {
              const oldPayload = payload;
              for (const payload of oldPayload) {
                {
                  let arraySize = 0;
                  const oldPayload = payload;
                  for (let i = 0; i < oldPayload.length; ++i) {
                    const payload = oldPayload[i];
                    let payloadSize = 0;
                    payloadSize = textEncoder.encode(payload).byteLength;
                    arraySize += varintSizeFromValue(BigInt(payloadSize)) + payloadSize;
                  }
                  payloadSize = arraySize;
                }
                offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                {
                  const oldPayload = payload;
                  for (const payload of oldPayload) {
                    payloadSize = textEncoder.encode(payload).byteLength;
                    offset = serializeVarint(dataView, offset, BigInt(payloadSize));
                    {
                      const buffer = textEncoder.encode(payload);
                      for (let i = 0; i < buffer.byteLength; ++i) {
                        dataView.setUint8(offset + i, buffer[i]);
                      }
                      offset += buffer.byteLength;
                    }
                  }
                }
              }
            }
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, FooIn] {
        return [0, undefined!];
      }

      export function outToIn(value: FooOut): FooIn {
        return undefined!;
      }
    }
  }

  export namespace Main {
    export type EmptyStructOut = {
    };

    export type EmptyStructIn = {
    };

    export namespace EmptyStruct {
      export function size(value: EmptyStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: EmptyStructOut,
      ): number {
        let payloadSize = 0;

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, EmptyStructIn] {
        return [0, undefined!];
      }

      export function outToIn(value: EmptyStructOut): EmptyStructIn {
        return undefined!;
      }
    }

    export type EmptyChoiceOut = never;

    export type EmptyChoiceIn = never;

    export namespace EmptyChoice {
      export function size(value: EmptyChoiceOut): number {
        return 0;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: EmptyChoiceOut,
      ): number {
        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, EmptyChoiceIn] {
        return [0, undefined!];
      }

      export function outToIn(value: EmptyChoiceOut): EmptyChoiceIn {
        return undefined!;
      }
    }

    export type FooAndBarOut = {
      x: Comprehensive.Foo.FooOut;
      y: Comprehensive.Bar.BarOut;
    };

    export type FooAndBarIn = {
      x: Comprehensive.Foo.FooIn;
      y: Comprehensive.Bar.BarIn;
    };

    export namespace FooAndBar {
      export function size(value: FooAndBarOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = Comprehensive.Foo.Foo.size(payload);
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.y;
          payloadSize = Comprehensive.Bar.Bar.size(payload);
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: FooAndBarOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = Comprehensive.Foo.Foo.size(payload);
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          offset = Comprehensive.Foo.Foo.serialize(dataView, offset, payload);
        }

        {
          const payload = value.y;
          payloadSize = Comprehensive.Bar.Bar.size(payload);
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          offset = Comprehensive.Bar.Bar.serialize(dataView, offset, payload);
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, FooAndBarIn] {
        return [0, undefined!];
      }

      export function outToIn(value: FooAndBarOut): FooAndBarIn {
        return undefined!;
      }
    }

    export type FooOrBarOut =
      | { field: 'x'; value: Comprehensive.Foo.FooOut }
      | { field: 'y'; value: Comprehensive.Bar.BarOut };

    export type FooOrBarIn =
      | { field: 'x'; value: Comprehensive.Foo.FooIn }
      | { field: 'y'; value: Comprehensive.Bar.BarIn };

    export namespace FooOrBar {
      export function size(value: FooOrBarOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'x': {
            const payload = value.value;
            payloadSize = Comprehensive.Foo.Foo.size(payload);
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'y': {
            const payload = value.value;
            payloadSize = Comprehensive.Bar.Bar.size(payload);
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize;
          }
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: FooOrBarOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'x': {
            const payload = value.value;
            payloadSize = Comprehensive.Foo.Foo.size(payload);
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            offset = Comprehensive.Foo.Foo.serialize(dataView, offset, payload);
            return offset;
          }
          case 'y': {
            const payload = value.value;
            payloadSize = Comprehensive.Bar.Bar.size(payload);
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            offset = Comprehensive.Bar.Bar.serialize(dataView, offset, payload);
            return offset;
          }
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, FooOrBarIn] {
        return [0, undefined!];
      }

      export function outToIn(value: FooOrBarOut): FooOrBarIn {
        return undefined!;
      }
    }
  }
}

export namespace Main {
}

export namespace SchemaEvolution {
  export namespace After {
    export type ExampleStructOut = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional?: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric: string;
      asymmetricToOptional?: string;
      optionalNoneToAsymmetric: string;
      optionalNoneToOptional?: string;
      optionalSomeToRequired: string;
      optionalSomeToAsymmetric: string;
      optionalSomeToOptional?: string;
      nonexistentToAsymmetric: string;
      nonexistentToOptional?: string;
    };

    export type ExampleStructIn = {
      requiredToRequired: string;
      requiredToAsymmetric?: string;
      requiredToOptional?: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric?: string;
      asymmetricToOptional?: string;
      optionalNoneToAsymmetric?: string;
      optionalNoneToOptional?: string;
      optionalSomeToRequired: string;
      optionalSomeToAsymmetric?: string;
      optionalSomeToOptional?: string;
      nonexistentToAsymmetric?: string;
      nonexistentToOptional?: string;
    };

    export namespace ExampleStruct {
      export function size(value: ExampleStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(2n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(4n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalNoneToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalNoneToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(12n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nonexistentToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(17n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.nonexistentToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(18n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalNoneToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.optionalNoneToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalSomeToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.optionalSomeToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.optionalSomeToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.nonexistentToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.nonexistentToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleStructIn] {
        return [0, undefined!];
      }

      export function outToIn(value: ExampleStructOut): ExampleStructIn {
        return undefined!;
      }
    }

    export type ExampleChoiceOut =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToRequired'; value: string }
      | { field: 'asymmetricToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToOptionalHandled'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToOptionalFallback'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToRequired'; value: string }
      | { field: 'optionalToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToOptionalHandled'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToOptionalFallback'; value: string; fallback: ExampleChoiceOut }
      | { field: 'nonexistentToRequired'; value: string }
      | { field: 'nonexistentToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'nonexistentToOptionalHandled'; value: string; fallback: ExampleChoiceOut }
      | { field: 'nonexistentToOptionalFallback'; value: string; fallback: ExampleChoiceOut };

    export type ExampleChoiceIn =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string }
      | { field: 'asymmetricToRequired'; value: string }
      | { field: 'asymmetricToAsymmetric'; value: string }
      | { field: 'asymmetricToOptionalHandled'; value: string; fallback: ExampleChoiceIn }
      | { field: 'asymmetricToOptionalFallback'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToRequired'; value: string }
      | { field: 'optionalToAsymmetric'; value: string }
      | { field: 'optionalToOptionalHandled'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToOptionalFallback'; value: string; fallback: ExampleChoiceIn }
      | { field: 'nonexistentToRequired'; value: string }
      | { field: 'nonexistentToAsymmetric'; value: string }
      | { field: 'nonexistentToOptionalHandled'; value: string; fallback: ExampleChoiceIn }
      | { field: 'nonexistentToOptionalFallback'; value: string; fallback: ExampleChoiceIn };

    export namespace ExampleChoice {
      export function size(value: ExampleChoiceOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(7n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize;
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(11n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(12n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(13n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nonexistentToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(15n, payloadSize, false) + payloadSize;
          }
          case 'nonexistentToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(16n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nonexistentToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(17n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'nonexistentToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(18n, payloadSize, false) + payloadSize + size(value.fallback);
          }
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nonexistentToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 15n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'nonexistentToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 16n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nonexistentToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 17n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'nonexistentToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 18n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleChoiceIn] {
        return [0, undefined!];
      }

      export function outToIn(value: ExampleChoiceOut): ExampleChoiceIn {
        return undefined!;
      }
    }
  }

  export namespace Before {
    export type ExampleStructOut = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional: string;
      requiredToNonexistent: string;
      asymmetricToRequired: string;
      asymmetricToAsymmetric: string;
      asymmetricToOptional: string;
      asymmetricToNonexistent: string;
      optionalNoneToAsymmetric?: string;
      optionalNoneToOptional?: string;
      optionalNoneToNonexistent?: string;
      optionalSomeToRequired?: string;
      optionalSomeToAsymmetric?: string;
      optionalSomeToOptional?: string;
      optionalSomeToNonexistent?: string;
    };

    export type ExampleStructIn = {
      requiredToRequired: string;
      requiredToAsymmetric: string;
      requiredToOptional: string;
      requiredToNonexistent: string;
      asymmetricToRequired?: string;
      asymmetricToAsymmetric?: string;
      asymmetricToOptional?: string;
      asymmetricToNonexistent?: string;
      optionalNoneToAsymmetric?: string;
      optionalNoneToOptional?: string;
      optionalNoneToNonexistent?: string;
      optionalSomeToRequired?: string;
      optionalSomeToAsymmetric?: string;
      optionalSomeToOptional?: string;
      optionalSomeToNonexistent?: string;
    };

    export namespace ExampleStruct {
      export function size(value: ExampleStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(1n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(2n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.requiredToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(3n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(4n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(5n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(6n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.asymmetricToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(7n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalNoneToAsymmetric;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(9n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalNoneToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(10n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalNoneToNonexistent;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(11n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToRequired;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(12n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToAsymmetric;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(13n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToOptional;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(14n, payloadSize, false) + payloadSize;
        }

        {
          const payload = value.optionalSomeToNonexistent;
          if (payload === undefined) {
            payloadSize = 0;
          } else {
            payloadSize = textEncoder.encode(payload).byteLength;
          }
          valueSize += fieldHeaderSize(15n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.requiredToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 2n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.requiredToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 3n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToRequired;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 4n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToAsymmetric;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToOptional;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.asymmetricToNonexistent;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        {
          const payload = value.optionalNoneToAsymmetric;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalNoneToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalNoneToNonexistent;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalSomeToRequired;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalSomeToAsymmetric;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalSomeToOptional;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        {
          const payload = value.optionalSomeToNonexistent;
          if (payload !== undefined) {
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 15n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleStructIn] {
        return [0, undefined!];
      }

      export function outToIn(value: ExampleStructOut): ExampleStructIn {
        return undefined!;
      }
    }

    export type ExampleChoiceOut =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string }
      | { field: 'asymmetricToRequired'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToOptionalHandled'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToOptionalFallback'; value: string; fallback: ExampleChoiceOut }
      | { field: 'asymmetricToNonexistent'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToRequired'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToAsymmetric'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToOptionalHandled'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToOptionalFallback'; value: string; fallback: ExampleChoiceOut }
      | { field: 'optionalToNonexistent'; value: string; fallback: ExampleChoiceOut };

    export type ExampleChoiceIn =
      | { field: 'requiredToRequired'; value: string }
      | { field: 'requiredToAsymmetric'; value: string }
      | { field: 'asymmetricToRequired'; value: string }
      | { field: 'asymmetricToAsymmetric'; value: string }
      | { field: 'asymmetricToOptionalHandled'; value: string }
      | { field: 'asymmetricToOptionalFallback'; value: string }
      | { field: 'asymmetricToNonexistent'; value: string }
      | { field: 'optionalToRequired'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToAsymmetric'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToOptionalHandled'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToOptionalFallback'; value: string; fallback: ExampleChoiceIn }
      | { field: 'optionalToNonexistent'; value: string; fallback: ExampleChoiceIn };

    export namespace ExampleChoice {
      export function size(value: ExampleChoiceOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(1n, payloadSize, false) + payloadSize;
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(5n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(6n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(7n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(8n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'asymmetricToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(9n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(10n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(11n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(12n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(13n, payloadSize, false) + payloadSize + size(value.fallback);
          }
          case 'optionalToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(14n, payloadSize, false) + payloadSize + size(value.fallback);
          }
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: ExampleChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'requiredToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'requiredToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 1n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
          case 'asymmetricToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 5n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 6n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 7n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 8n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'asymmetricToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 9n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToRequired': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 10n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToAsymmetric': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 11n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToOptionalHandled': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 12n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToOptionalFallback': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 13n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
          case 'optionalToNonexistent': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 14n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            offset = serialize(dataView, offset, value.fallback);
            return offset;
          }
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, ExampleChoiceIn] {
        return [0, undefined!];
      }

      export function outToIn(value: ExampleChoiceOut): ExampleChoiceIn {
        return undefined!;
      }
    }
  }

  export namespace Main {
    export type SingletonStructOut = {
      x: string;
    };

    export type SingletonStructIn = {
      x: string;
    };

    export namespace SingletonStruct {
      export function size(value: SingletonStructOut): number {
        let valueSize = 0;
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = textEncoder.encode(payload).byteLength;
          valueSize += fieldHeaderSize(0n, payloadSize, false) + payloadSize;
        }

        return valueSize;
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: SingletonStructOut,
      ): number {
        let payloadSize = 0;

        {
          const payload = value.x;
          payloadSize = textEncoder.encode(payload).byteLength;
          offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
          {
            const buffer = textEncoder.encode(payload);
            for (let i = 0; i < buffer.byteLength; ++i) {
              dataView.setUint8(offset + i, buffer[i]);
            }
            offset += buffer.byteLength;
          }
        }

        return offset;
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, SingletonStructIn] {
        return [0, undefined!];
      }

      export function outToIn(value: SingletonStructOut): SingletonStructIn {
        return undefined!;
      }
    }

    export type SingletonChoiceOut =
      | { field: 'x'; value: string };

    export type SingletonChoiceIn =
      | { field: 'x'; value: string };

    export namespace SingletonChoice {
      export function size(value: SingletonChoiceOut): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'x': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            return fieldHeaderSize(0n, payloadSize, false) + payloadSize;
          }
        }
      }

      export function serialize(
        dataView: DataView,
        offset: number,
        value: SingletonChoiceOut,
      ): number {
        let payloadSize = 0;

        switch (value.field) {
          case 'x': {
            const payload = value.value;
            payloadSize = textEncoder.encode(payload).byteLength;
            offset = serializeFieldHeader(dataView, offset, 0n, payloadSize, false);
            {
              const buffer = textEncoder.encode(payload);
              for (let i = 0; i < buffer.byteLength; ++i) {
                dataView.setUint8(offset + i, buffer[i]);
              }
              offset += buffer.byteLength;
            }
            return offset;
          }
        }
      }

      export function deserialize(
        dataView: DataView,
        offset: number,
      ): [number, SingletonChoiceIn] {
        return [0, undefined!];
      }

      export function outToIn(value: SingletonChoiceOut): SingletonChoiceIn {
        return undefined!;
      }
    }
  }
}
",
        );
    }
}
